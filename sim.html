<!DOCTYPE html>
<!-- 96% chatgpt, 3% claude sonnet, 1% me just asking ai to write this line -->
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1" name="viewport"/>
  <title>Alt-Sim</title>
  <meta name="description" content="Calc base multiplier and randomize around your stats for better results."/>
    <meta name="theme-color" content="#36393f">
<meta name="msapplication-TileColor" content="#36393f">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!--<script async src="https://www.googletagmanager.com/gtag/js?id=G-5XWWWBSH8P"></script>-->
<!--<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-5XWWWBSH8P');
</script>-->
<style>*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}

:root{
  --bg:#36393f;--text:#b9bbbe;--label:#dcddde;--primary:#5865f2;--secondary:#4f545c;--danger:#ed4245;--border:#202225;
  --card-bg:#2f3136;--input-bg:#40444b;--hover-bg:#34373c;--input-disabled:#2f3136;--text-muted:#8e9297;--text-subtle:#72767d;
  --radius:8px;--shadow:0 2px 8px rgba(0,0,0,.15);--transition:.28s ease-in-out;
  --font-size-xs:.75rem;--font-size-sm:.875rem;--font-size-base:1rem;--font-size-lg:1.125rem;--font-size-xl:1.25rem;--font-size-2xl:1.5rem;--font-size-3xl:1.875rem;
  --line-height-tight:1.25;--line-height-normal:1.5;--line-height-relaxed:1.625;
  --font-weight-normal:400;--font-weight-medium:500;--font-weight-semibold:600;--font-weight-bold:700;
  --letter-spacing-tight:-.025em;--letter-spacing-normal:0;--letter-spacing-wide:.025em
}

html{font-size:100%;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}

body{
  font-family:'Inter','Roboto','Helvetica Neue',Arial,sans-serif;
  font-size:var(--font-size-base);font-weight:var(--font-weight-normal);
  line-height:var(--line-height-normal);letter-spacing:var(--letter-spacing-normal);
  background:var(--bg);color:var(--text);padding-bottom:env(safe-area-inset-bottom);
  -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;
  scroll-behavior:smooth;-webkit-overflow-scrolling:touch;overscroll-behavior-y:none;
  -ms-scroll-chaining:none;-ms-touch-action:pan-y;touch-action:pan-y;
  -webkit-tap-highlight-color:transparent
}

h1,h2,h3,h4,h5,h6{
  font-weight:var(--font-weight-semibold);line-height:var(--line-height-tight);
  letter-spacing:var(--letter-spacing-tight);color:var(--label);margin-bottom:.75rem
}

h1{font-size:var(--font-size-3xl);margin-bottom:1rem}
h2{font-size:var(--font-size-2xl);margin-bottom:.875rem}
h3{font-size:var(--font-size-xl);margin-bottom:.75rem}
h4{font-size:var(--font-size-lg);margin-bottom:.625rem}
h5,h6{font-size:var(--font-size-base);margin-bottom:.5rem}

p{font-size:var(--font-size-base);line-height:var(--line-height-normal);margin-bottom:1rem;color:var(--text)}
small{font-size:var(--font-size-sm);line-height:var(--line-height-normal);color:var(--text-muted)}

a{color:var(--primary);text-decoration:none;transition:color .2s ease}
a:hover{color:#7289da}
a:focus{outline:2px solid var(--primary);outline-offset:2px}

.container{max-width:800px;margin:0 auto;padding:24px}

.form-row{display:grid;grid-template-columns:repeat(2,1fr);gap:20px;margin-bottom:24px}
.form-group{display:flex;flex-direction:column;margin-bottom:8px}
.form-group label{
  font-size:var(--font-size-sm);font-weight:var(--font-weight-medium);
  line-height:var(--line-height-tight);color:var(--label);
  margin-bottom:8px;letter-spacing:var(--letter-spacing-wide)
}

.input-wrap input,.input-wrap select{
  height:44px;width:100%;padding:12px 16px;border:1px solid var(--border);
  border-radius:var(--radius);background:var(--input-bg);box-shadow:var(--shadow);
  color:var(--text);font-size:var(--font-size-base);line-height:1;
  transition:var(--transition);background-clip:padding-box;display:flex;align-items:center
}

.input-wrap select{padding-right:40px;appearance:none;cursor:pointer}

.input-wrap input:focus,.input-wrap select:focus{
  border-color:var(--primary);outline:none;
  box-shadow:0 0 0 2px rgba(88,101,242,.3);background:var(--hover-bg)
}

.input-wrap input:disabled,.input-wrap select:disabled{
  background:var(--input-disabled);color:var(--text-subtle);opacity:.7;
  cursor:not-allowed;box-shadow:none;border-color:#1e2124
}

.select-wrap{position:relative}
.select-wrap::after{
  content:"";position:absolute;right:10px;top:50%;width:16px;height:16px;
  transform:translateY(-50%);
  background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%23b9bbbe'><path d='M4 6l4 4 4-4z'/></svg>");
  background-repeat:no-repeat;background-size:contain;pointer-events:none;
  transition:transform .3s ease
}
.select-wrap:focus-within::after{transform:translateY(-50%) rotate(180deg)}

select.invalid-value,select.invalid-value:focus,input.invalid-value,input.invalid-value:focus{
  box-shadow:none;border-color:#c13537;transition:border-color .5s ease
}

.btn-row{display:flex;gap:16px;margin-top:32px}

.btn-row button{
  height:44px;padding:0 20px;border:none;border-radius:var(--radius);
  cursor:pointer;color:#fff;font-size:var(--font-size-base);
  font-weight:var(--font-weight-medium);line-height:var(--line-height-normal);
  letter-spacing:var(--letter-spacing-wide);transition:var(--transition)
}

#submitBtn{background:#4752c4} #submitBtn:hover{background:#3c45a5} #submitBtn:active,#submitBtn:focus{background:#343a8f}

#resetRekomenBtn{background:#5a6069}
#resetRekomenBtn:hover{background:#646b75}
#resetRekomenBtn:active,#resetRekomenBtn:focus{background:#6e7681}

#resetAllBtn{background:#c13537}
#resetAllBtn:hover{background:#a82d2f}
#resetAllBtn:active,#resetAllBtn:focus{background:#8f2527}

#testSpear{background:#cc8400}
#testSpear:hover{background:#b37400}
#testSpear:active,#testSpear:focus{background:#996300}

#testReaper{background:#7e3ff2}
#testReaper:hover{background:#6931d9}
#testReaper:active,#testReaper:focus{background:#5625b0}

button:disabled{opacity:.5;cursor:not-allowed;pointer-events:none}

#hasil,#recommendations{
  background:var(--hover-bg);padding:24px;margin-top:24px;
  border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow)
}

#hasil>p{font-size:var(--font-size-base);line-height:var(--line-height-normal);margin-bottom:1rem;color:var(--text)}

#hasil>p#breakdown-summary{
  font-size:var(--font-size-lg);font-weight:var(--font-weight-medium);
  line-height:var(--line-height-tight);color:var(--label);margin-bottom:1.25rem;
  padding:16px 20px;background:var(--card-bg);border:1px solid var(--border);
  border-radius:var(--radius)
}

#recommendations{display:grid;grid-template-columns:repeat(2,1fr);gap:24px}

.table-wrapper{
  width:100%;overflow-x:auto;border-radius:var(--radius);
  background:var(--card-bg);box-shadow:var(--shadow);margin:8px 0;
  border:1px solid var(--border)
}

#recommendations table{
  width:100%;border-collapse:collapse;background:transparent;
  border:none;table-layout:auto;font-variant-numeric:tabular-nums
}

#recommendations caption{
  text-align:left;padding:18px 20px 16px;background:var(--card-bg);
  border-bottom:1px solid var(--border);border-radius:var(--radius) var(--radius) 0 0;
  color:var(--label);font-size:var(--font-size-lg);font-weight:var(--font-weight-semibold);
  line-height:var(--line-height-tight);letter-spacing:var(--letter-spacing-tight)
}

#recommendations th{
  padding:12px 8px;text-align:center;background:var(--card-bg);color:var(--label);
  border-right:1px solid var(--border);border-bottom:1px solid var(--border);
  font-size:var(--font-size-sm);font-weight:var(--font-weight-semibold);
  line-height:var(--line-height-tight);letter-spacing:var(--letter-spacing-wide);
  text-transform:uppercase;font-variant:small-caps;word-wrap:break-word;
  hyphens:auto;max-width:60px;vertical-align:bottom
}

#recommendations td{
  padding:14px 10px;text-align:center;color:var(--text);
  border-right:1px solid var(--border);border-bottom:1px solid var(--border);
  font-size:var(--font-size-base);font-weight:var(--font-weight-medium);
  line-height:var(--line-height-normal);letter-spacing:var(--letter-spacing-normal);
  vertical-align:middle;background:var(--card-bg);transition:background-color .2s ease;
  white-space:nowrap;min-width:65px
}

#recommendations tbody tr:hover td{background:var(--hover-bg)}

#recommendations th:last-child,#recommendations td:last-child{border-right:none}
#recommendations tbody tr:last-child td{border-bottom:none}

#recommendations td span{
  display:inline-flex;align-items:center;justify-content:center;
  gap:4px;font-variant-numeric:tabular-nums
}

#recommendations td span::before{font-size:calc(var(--font-size-xs)*.4)}

span.up::before{content:"\25B2";color:#57f287;margin-right:1px;position:relative;top:.5px}
span.down::before{content:"\25BC";color:#3498db;margin-right:1px;position:relative;top:.5px}
span.neutral::before{content:"\25A0";color:var(--text-subtle);margin-right:1px;position:relative;top:.5px}

td.mult{
  font-weight:var(--font-weight-bold);color:var(--label);
  font-size:var(--font-size-lg);letter-spacing:var(--letter-spacing-tight)
}

td.delta{
  color:#57f287;font-weight:var(--font-weight-bold);
  font-size:var(--font-size-lg);letter-spacing:var(--letter-spacing-tight)
}

.sticky{
  position:fixed;bottom:calc(24px + env(safe-area-inset-bottom));right:24px;
  width:48px;height:48px;display:flex;align-items:center;justify-content:center;
  border-radius:var(--radius);box-shadow:var(--shadow);cursor:pointer;z-index:1000;
  border:none;background-repeat:no-repeat;background-position:center;background-size:26px;
  transition:transform .3s cubic-bezier(.4,0,.2,1),opacity .3s cubic-bezier(.4,0,.2,1)
}

.sticky.collapsed{opacity:0;pointer-events:none;z-index:999}
.sticky:not(.collapsed){opacity:1;pointer-events:auto}

#toggleStickyBtn.sticky{z-index:1001}
#toggleStickyBtn.sticky.collapsed{opacity:1!important;pointer-events:auto!important;z-index:1001!important}

#testSpear.sticky,#testReaper.sticky{background:center/26px no-repeat}

#testSpear.sticky{
  background-color:#cc8400;
  background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 24 24'%3E%3Cpath fill='%23fff' d='M17 10h-3.61l2.28 2.28zm0-8H7v1.61l6.13 6.13zm-13.59.86L2 4.27l5 5V13h3v9l3.58-6.15L17.73 20l1.41-1.41z'/%3E%3C/svg%3E")
}

#testReaper.sticky{
  background-color:#7e3ff2;
  background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 24 24'%3E%3Cpath fill='%23fff' d='M17 10h-3.61l2.28 2.28zm0-8H7v1.61l6.13 6.13zm-13.59.86L2 4.27l5 5V13h3v9l3.58-6.15L17.73 20l1.41-1.41z'/%3E%3C/svg%3E")
}

#testSpear.sticky.activated,#testReaper.sticky.activated{overflow:hidden;background:center/26px no-repeat}
#testSpear.sticky.activated{background-color:#cc8400}
#testReaper.sticky.activated{background-color:#7e3ff2}

#testSpear.sticky.activated::before,#testReaper.sticky.activated::before{
  content:'';position:absolute;top:-20px;left:-20px;width:88px;height:88px;
  background:conic-gradient(hsla(0,0%,100%,0) 0deg,hsla(42,100%,72%,.35) 40deg,hsla(42,100%,68%,.75) 80deg,hsla(255,100%,78%,.8) 120deg,hsla(255,100%,72%,.6) 160deg,hsla(220,100%,78%,.55) 200deg,hsla(220,100%,85%,.4) 240deg,hsla(0,0%,100%,.3) 280deg,hsla(0,0%,100%,.15) 320deg,hsla(0,0%,100%,0) 360deg);
  border-radius:50%;filter:blur(4px);opacity:.7;
  animation:rotate-shine 3s linear infinite;z-index:1
}

#testSpear.sticky.activated::after,#testReaper.sticky.activated::after{
  content:'';position:absolute;top:50%;left:50%;width:26px;height:26px;
  transform:translate(-50%,-50%);background:center/26px no-repeat;
  background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' height='48' viewBox='0 -960 960 960' width='48'%3E%3Cpath fill='%23fff' d='m460-272 186-268H520l81-280H340v360h120v188ZM400-80v-320H280v-480h400l-80 280h160L400-80Zm60-380H340h120Z'/%3E%3C/svg%3E");
  z-index:2
}

@keyframes rotate-shine{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}

#resetRekomenBtn.sticky{
  background:#5a6069 url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 24 24'%3E%3Cpath d='M17.65 6.35A7.95 7.95 0 0 0 12 4a8 8 0 1 0 7.9 9h-2.02a6 6 0 1 1-5.88-7c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z'/%3E%3C/svg%3E") center/26px no-repeat
}

#resetAllBtn.sticky{
  background:#c13537 url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 -960 960 960'%3E%3Cpath fill='%23fff' d='M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm400-600H280v520h400v-520ZM360-280h80v-360h-80v360Zm160 0h80v-360h-80v360ZM280-720v520-520Z'/%3E%3C/svg%3E") center/26px no-repeat
}

#breakdown-swap.sticky{
  background:#c13537 url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='white' viewBox='0 -960 960 960'%3E%3Cpath d='M769-88 645-212l-88 88-43-43q-17-17-17-42t17-42l199-199q17-17 42-17t42 17l43 43-88 88 123 124q9 9 9 21t-9 21l-64 65q-9 9-21 9t-21-9Zm111-636L427-271l19 20q17 17 17 42t-17 42l-43 43-88-88L191-88q-9 9-21 9t-21-9l-65-65q-9-9-9-21t9-21l124-124-88-88 43-43q-17-17 42-17t42 17l20 19 453-453h160v160ZM320-568l38-38 38-38-38 38-38 38Zm-42 42L80-724v-160h160l198 198-42 42-181-180h-75v75l180 181-42 42Zm105 212 437-435v-75h-75L308-389l75 75Zm0 0-37-38-38-37 38 37 37 38Z'/%3E%3C/svg%3E") center/26px no-repeat;
  color:transparent;text-shadow:none;appearance:none;width:48px;max-width:48px;
  min-width:48px;padding:0;text-indent:-9999px
}

#backToHasilBtn.sticky{
  background:#4a9b5e url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 24 24'%3E%3Cpath d='M4 12l1.41 1.41L11 7.83V20h2V7.83l5.59 5.58L20 12l-8-8-8 8z'/%3E%3C/svg%3E") center/26px no-repeat
}

#toggleStickyBtn.sticky.active{
  background:var(--primary) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%23fff' d='M18.3 5.71L12 12l-6.3-6.29-1.41 1.41L10.59 13.4l-6.3 6.3 1.41 1.41L12 14.83l6.29 6.29 1.42-1.41-6.3-6.3 6.3-6.29z'/%3E%3C/svg%3E") center/26px no-repeat
}

#toggleStickyBtn.sticky{
  background:var(--primary) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%23fff' d='M3 6h18v2H3V6zm0 5h18v2H3v-2zm0 5h18v2H3v-2z'/%3E%3C/svg%3E") center/26px no-repeat
}

.breakdown-swap-wrapper{display:flex;align-items:center;gap:12px;margin:20px 0}

.breakdown-swap-wrapper label{
  color:var(--label);white-space:nowrap;font-size:var(--font-size-sm);
  font-weight:var(--font-weight-medium);line-height:var(--line-height-normal)
}

.breakdown-swap{
  appearance:none;
  background:var(--input-bg) url("data:image/svg+xml;utf8,<svg fill='%23b9bbbe' height='20' viewBox='0 0 24 24' width='20' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/></svg>") no-repeat right 12px center/16px;
  border:1px solid var(--border);border-radius:var(--radius);padding:10px 36px 10px 16px;
  cursor:pointer;outline:none;transition:border-color .28s ease-in-out,box-shadow .28s ease-in-out,background-color .28s ease-in-out;
  width:180px;max-width:50%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;
  color:var(--text);font-size:var(--font-size-sm);line-height:var(--line-height-normal)
}

.breakdown-swap:hover{border-color:var(--text-subtle);background-color:var(--hover-bg)}
.breakdown-swap:focus{border-color:var(--primary);box-shadow:0 0 0 2px rgba(88,101,242,.3);background:var(--hover-bg)}

#multiplier-breakdown{
  background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);
  padding:0 20px 20px;color:var(--text);margin:8px 0
}

#multiplier-breakdown>p:first-of-type{
  color:var(--label);margin-bottom:16px;font-size:var(--font-size-lg);
  font-weight:var(--font-weight-semibold);line-height:var(--line-height-tight);padding-top:16px
}

#multiplier-breakdown>p:nth-of-type(2){
  margin-bottom:20px;background:var(--input-bg);padding:14px 18px;
  border-radius:var(--radius);border:1px solid var(--border);
  font-variant-numeric:tabular-nums;color:var(--label);
  font-size:var(--font-size-lg);line-height:var(--line-height-normal);
  font-weight:var(--font-weight-semibold)
}

#multiplier-breakdown blockquote.noted{
  margin:16px 0;padding:14px 18px;border:1px solid var(--border);
  background:var(--input-bg);color:var(--text);border-radius:var(--radius);
  font-size:var(--font-size-sm);line-height:var(--line-height-relaxed)
}

.factor-breakdown{margin:0;padding:0;list-style:none;color:var(--text)}

.factor-breakdown>li{
  margin:14px 0;font-size:var(--font-size-base);line-height:var(--line-height-relaxed);
  color:var(--label);font-weight:var(--font-weight-medium)
}

.factor-breakdown li ul{
  margin:12px 0 0 16px;padding-left:16px;list-style:none;
  color:var(--text);border-left:2px solid var(--border)
}

.factor-breakdown li ul li{
  margin:10px 0;font-size:var(--font-size-sm);line-height:var(--line-height-relaxed);
  font-weight:var(--font-weight-normal)
}

.factor-breakdown li ul li.note{
  color:var(--text-muted);font-style:italic;padding-left:0;margin-left:0;
  font-size:var(--font-size-xs)
}

.factor-breakdown>li span.neutral-flag{
  color:var(--text-subtle);margin-left:8px;
  font-family:ui-monospace,'Fira Code',monospace;font-size:var(--font-size-xs)
}

#howto{
  margin:0 auto 24px;width:100%;border:1px solid var(--border);
  border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden
}

#howto summary{
  display:flex;align-items:center;justify-content:space-between;
  padding:16px 16px 16px 20px;cursor:pointer;color:var(--label);
  background:var(--card-bg);border:none;
  box-shadow:inset 0 1px 3px rgba(0,0,0,.1);border-radius:var(--radius) var(--radius) 0 0;
  font-size:var(--font-size-base);font-weight:var(--font-weight-medium);
  line-height:var(--line-height-normal);transition:background-color .2s ease
}

#howto summary:hover{background:var(--hover-bg)}
#howto summary::-webkit-details-marker{display:none}
#howto summary span{color:var(--label)}

#howto summary::after{
  content:"";flex-shrink:0;width:16px;height:16px;margin-left:12px;
  background:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%23dcddde'><path d='M4 6l4 4 4-4z'/></svg>") center/16px no-repeat;
  transition:transform .3s ease
}

#howto[open] summary{border-radius:var(--radius) var(--radius) 0 0}
#howto[open] summary::after{transform:rotate(180deg)}

#howto .body{
  padding:16px 20px 20px;background:var(--card-bg);border:none;
  border-top:1px solid var(--border);box-shadow:inset 0 1px 3px rgba(0,0,0,.1);
  border-radius:0 0 var(--radius) var(--radius);overflow:hidden;max-height:0;transition:max-height .4s ease
}

#howto .content{overflow:hidden;transition:max-height .4s ease;max-height:0}

#howto ol{counter-reset:step;margin:0;padding:0;list-style:none}

#howto ol>li{
  position:relative;margin:18px 0;padding-left:36px;color:var(--label);
  font-size:var(--font-size-base);font-weight:var(--font-weight-medium);
  line-height:var(--line-height-relaxed)
}

#howto ol>li::before{
  counter-increment:step;content:counter(step)".";position:absolute;left:0;top:0;
  color:var(--primary);font-weight:var(--font-weight-bold);
  font-size:var(--font-size-lg);line-height:var(--line-height-tight)
}

#howto ol>li strong{color:var(--label);font-weight:var(--font-weight-semibold)}

#howto ul{margin:12px 0 0;padding:0;list-style:none}

#howto ul li{
  position:relative;margin:10px 0;padding-left:24px;color:var(--text);
  font-size:var(--font-size-sm);font-weight:var(--font-weight-normal);
  line-height:var(--line-height-normal)
}

#howto ul li::before{
  content:"\2022";position:absolute;left:0;top:0;color:var(--primary);
  font-weight:var(--font-weight-medium)
}

#howto li ul{margin:8px 0 0;padding-left:16px;border-left:2px solid var(--border)}

#howto li ul li{
  margin:6px 0;font-size:var(--font-size-xs);color:var(--text-muted);padding-left:20px
}

#howto li ul li::before{content:"\25E6";color:var(--text-subtle);font-size:var(--font-size-sm)}

#howto li.muted{color:var(--text-muted);font-style:italic;font-size:var(--font-size-sm)}
#howto em{color:var(--text-muted);font-style:italic}

code{
  font-family:'Fira Code',ui-monospace,monospace;background:var(--input-bg);
  color:var(--label);padding:3px 6px;border-radius:4px;
  font-size:var(--font-size-sm);border:1px solid var(--border)
}

blockquote code{background:var(--card-bg)}

#version{
  margin-bottom:32px;display:flex;justify-content:space-between;
  align-items:flex-start;gap:16px
}

#version p{
  margin-bottom:0;font-size:var(--font-size-xs);
  line-height:var(--line-height-normal);color:var(--text-muted)
}

#version p:first-child{display:flex;align-items:center;gap:6px}

#version p:last-child{
  font-style:italic;color:var(--text-subtle);text-align:right;white-space:nowrap
}

#version button,#version a,.toggle-precision,a.job-sim{
  font-family:'Fira Code',ui-monospace,monospace;text-decoration:none;
  outline:none;border:0;background:none;color:#5865f2;
  font-size:var(--font-size-xs);line-height:var(--line-height-normal);
  font-weight:var(--font-weight-medium);cursor:pointer;transition:color .2s ease
}
a.job-sim { 
  color: #ff8c42;
  display: inline-block;
  outline: none;
  background: transparent;
  border: none;
  text-decoration: underline dotted;
}
a.job-sim:hover { color: #ff6b1a; }
a.job-sim:visited { color: #ffa726; }

#version a{font-weight:var(--font-weight-medium)}

#version button:hover,#version a:hover,.toggle-precision:hover{color:#6366f1}
#version p i {
  color: var(--label);
}
.toggle-precision{
  padding:0 4px;text-decoration:underline dotted;font-size:var(--font-size-base);
  font-family:inherit;font-weight:inherit
}

.footer{
  margin-top:32px;color:var(--text-muted);font-size:var(--font-size-xs);
  line-height:var(--line-height-relaxed);text-align:left
}

svg{display:inline-block;margin:0 2px -2px 0}

hr.separ{
  margin:20px auto 16px;border:none;height:2px;background-color:var(--border);
  border-radius:var(--radius)
}

.snackbar{
  position:fixed;left:50%;transform:translateX(-50%) translateY(30px);
  bottom:16px;background:rgba(0,0,0,.8);color:#fff;padding:10px 14px;
  border-radius:var(--radius);opacity:0;pointer-events:none;text-align:center;
  box-shadow:var(--shadow);font-size:var(--font-size-sm);
  line-height:var(--line-height-normal);transition:opacity .3s ease,transform .3s ease
}

.snackbar.show{
  opacity:1;pointer-events:auto;transform:translateX(-50%) translateY(0);
  animation:snackbarBounce .4s ease
}

@keyframes snackbarBounce{
  0%{transform:translateX(-50%) translateY(30px)}
  60%{transform:translateX(-50%) translateY(-6px)}
  80%{transform:translateX(-50%) translateY(3px)}
  100%{transform:translateX(-50%) translateY(0)}
}

.changelog{position:relative;max-width:70%;margin:auto;color:var(--text)}

.changelog .header-log{position:relative;margin-bottom:1.5rem}

.changelog h2{
  margin-bottom:1.2rem;color:var(--primary);border-bottom:2px solid var(--border);
  padding-bottom:.6rem;font-size:var(--font-size-2xl);font-weight:var(--font-weight-semibold);
  line-height:var(--line-height-tight);letter-spacing:var(--letter-spacing-tight)
}

.changelog .version{margin-bottom:2rem}

.changelog .version h3{
  color:var(--label);margin:0 0 1rem;font-size:var(--font-size-xl);
  font-weight:var(--font-weight-medium);line-height:var(--line-height-tight)
}

.changelog .version ul{list-style:none;padding-left:.25rem;margin:0}

.changelog .version ul li{
  position:relative;margin:.75rem 0;padding-left:1.25rem;
  font-size:var(--font-size-base);line-height:var(--line-height-relaxed);color:var(--text)
}

.changelog .version ul li::before{content:"\2022";color:var(--primary);position:absolute;left:0}

.changelog .version ul ul{margin-top:.5rem;padding-left:1rem;border-left:1px solid var(--border)}

.changelog .version ul ul li{font-size:var(--font-size-sm);margin:.5rem 0}

.changelog .sub-cats{
  display:inline-block;font-weight:var(--font-weight-semibold);
  color:var(--label);font-size:var(--font-size-base)
}

#log{
  position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.6);
  z-index:1000;align-items:center;justify-content:center;padding:24px;display:none
}

#log.show,#log[style*="flex"]{display:flex!important}

#log .changelog{
  background:var(--card-bg);width:100%;max-width:70%;max-height:500px;
  padding:24px;border-radius:var(--radius);box-shadow:0 4px 20px rgba(0,0,0,.4);
  animation:fadeInUp .3s ease;position:relative;overflow-y:auto;
  border:1px solid var(--border)
}

#log .close{
  position:absolute;top:16px;right:16px;color:var(--text-subtle);cursor:pointer;
  transition:var(--transition);font-size:var(--font-size-lg);font-weight:var(--font-weight-bold);
  width:24px;height:24px;display:flex;align-items:center;justify-content:center;
  border-radius:4px
}

#log .close:hover{color:var(--label);background:var(--hover-bg)}

.hidden{display:none!important}

.tooltip-wrap, .dmgstack-tips {
  position: absolute;
  z-index: 9999;
  background: rgba(0, 0, 0, 0.85);
  color: #b9bbbe;
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
  font-size: 12px;
  line-height: 1.5;
  padding: 12px 16px;
  max-width: 480px;
  
  /* Smooth transition setup */
  opacity: 0;
  transform: translateY(-12px) scale(0.95);
  transition: all 0.2s cubic-bezier(0.2, 0, 0.2, 1);
  pointer-events: none;
  
  /* Performance optimizations */
  will-change: transform, opacity;
  backface-visibility: hidden;
}

.tooltip-wrap.visible, .dmgstack-tips.visible {
  opacity: 1;
  transform: translateY(0) scale(1);
  pointer-events: auto;
}

.tooltip-wrap strong, .dmgstack-tips strong {
  color: #dcddde;
  font-weight: 600;
}

.tooltip-button, .dmgstack-tooltip {
  border: none;
  background: transparent;
  padding-top: 0;
  margin: 0;
  display: inline-flex;
  align-items: end;
  justify-content: center;
  cursor: pointer;
  position: absolute;
}

.tooltip-button:focus,
.dmgstack-tooltip:focus,
.tooltip-button:active,
.dmgstack-tooltip:active {
  outline: none;
  border: none;
  box-shadow: none;
  background: transparent;
}
/*
.tooltip-button:focus-visible,
.dmgstack-tooltip:focus-visible {
  outline: 2px solid #5865f2;
  outline-offset: 2px;
  border-radius: 3px;
}
*/
.tooltip-button svg, .dmgstack-tooltip svg {

  margin-left: 3px;
  width: 16px;
  height: 16px;
  pointer-events: none;
  fill: #b9bbbe;
  transition: fill 0.15s ease, transform 0.15s ease;
}

.tooltip-button:hover svg, .dmgstack-tooltip:hover svg {
  fill: #5865f2;
  transform: scale(1.1);
}

.tooltip-button:active svg, .dmgstack-tooltip:active svg {
  transform: scale(0.95);
}
@keyframes fadeInUp{
  from{opacity:0;transform:translateY(20px)}
  to{opacity:1;transform:translateY(0)}
}

@keyframes pulseFlashAnim{
  0%{opacity:0;transform:scale(.8)}
  25%{opacity:.6;transform:scale(1.2)}
  50%{opacity:.8;transform:scale(1.4)}
  75%{opacity:.4;transform:scale(1.6)}
  100%{opacity:0;transform:scale(1.8)}
}

@keyframes lightningFlicker{
  0%{filter:brightness(1)}
  15%{filter:brightness(1.8) contrast(1.3)}
  18%{filter:brightness(.9) contrast(1)}
  22%{filter:brightness(2.2) contrast(1.5)}
  25%{filter:brightness(1.1) contrast(1)}
  35%{filter:brightness(1.6) contrast(1.2)}
  40%{filter:brightness(1) contrast(1)}
  50%{filter:brightness(1.9) contrast(1.4)}
  55%{filter:brightness(1.2) contrast(1)}
  65%{filter:brightness(1.5) contrast(1.1)}
  75%{filter:brightness(1) contrast(1)}
  85%{filter:brightness(1.3) contrast(1.1)}
  100%{filter:brightness(1) contrast(1)}
}

@keyframes lightningAnim{
  0%{opacity:0;transform:scale(.8)}
  30%{opacity:1;transform:scale(1.3)}
  70%{opacity:.8;transform:scale(1.5)}
  100%{opacity:0;transform:scale(1.8)}
}

@media (max-width:800px){
  .container{padding:20px}
  .form-row{grid-template-columns:1fr;gap:16px;margin-bottom:20px}
  .form-group{margin-bottom:0}
  .btn-row{flex-direction:column;gap:12px;margin-top:24px}
  #recommendations{grid-template-columns:1fr;gap:20px}
  #hasil,#recommendations{padding:20px;margin-top:20px}
  #howto summary{padding:12px 12px 12px 16px;font-size:var(--font-size-sm)}
  #howto .body{padding:12px 16px 16px}
  #howto ol>li{margin:16px 0;font-size:var(--font-size-sm);padding-left:32px}
  #howto ol>li::before{font-size:var(--font-size-base)}
  #howto ul li{font-size:var(--font-size-xs)}
  #recommendations caption{font-size:var(--font-size-base);padding:14px 16px 12px}
  #recommendations th{padding:12px 10px;font-size:var(--font-size-sm)}
  #recommendations td{padding:10px 8px;font-size:var(--font-size-sm)}
  td.mult,td.delta{font-size:var(--font-size-base)}
}

@media (max-width:768px){
  .tooltip-wrap,.dmgstack-tips{max-width:280px;font-size:11px;padding:8px 12px}
}

@media (max-width:480px){
  .container{padding:16px}
  #multiplier-breakdown{background:var(--card-bg);box-shadow:var(--shadow)}
  #hasil,#recommendations{background:transparent;padding:0;border:none;box-shadow:none;margin-top:16px}
  #hasil>p#breakdown-summary,#multiplier-breakdown .noted{
    background:var(--bg);box-shadow:inset 0 0 5px 2px rgba(0,0,0,.3);
    padding:16px 18px;margin-bottom:16px;border-radius:var(--radius);border:1px solid var(--border)
  }
  #log{padding:16px}
  #log .changelog{max-width:80%;max-height:500px;padding:20px}
  .changelog h2{font-size:var(--font-size-xl);margin-bottom:1rem;padding-bottom:.5rem}
  .changelog .version h3{font-size:var(--font-size-base);margin-bottom:.5rem}
  .changelog .version ul li{font-size:var(--font-size-sm);margin:.375rem 0}
  .breakdown-swap-wrapper{justify-content:space-between;gap:8px}
  .breakdown-swap-wrapper label{max-width:35%;font-size:var(--font-size-xs)}
  .breakdown-swap{max-width:60%;font-size:var(--font-size-xs)}
  .sticky{bottom:calc(20px + env(safe-area-inset-bottom));right:20px}
  #recommendations caption{font-size:var(--font-size-base);padding:12px 14px}
  #recommendations th{
    padding:8px;font-size:var(--font-size-xs);white-space:nowrap;
    overflow:hidden;text-overflow:ellipsis
  }
  #recommendations td{padding:8px;font-size:var(--font-size-xs)}


.table-wrapper::-webkit-scrollbar {
  display: none; /* untuk Chrome, Safari, Edge */
}

.table-wrapper {
  -ms-overflow-style: none;  /* untuk IE dan Edge lama */
  scrollbar-width: none;     /* untuk Firefox */
}
  td.mult,td.delta{font-size:var(--font-size-sm)}
  .factor-breakdown>li{font-size:var(--font-size-sm)}
  .factor-breakdown li ul li{font-size:var(--font-size-xs)}
  #howto summary{padding:10px 10px 10px 14px;font-size:var(--font-size-sm)}
  #howto .body{padding:10px 14px 14px;overflow:hidden;max-height:0;transition:max-height .4s ease}
  #howto ol>li{margin:14px 0;font-size:var(--font-size-sm);padding-left:28px}
  #howto ol>li::before{font-size:var(--font-size-base)}
  #howto ul li{font-size:var(--font-size-xs);padding-left:20px}
  #howto li ul li{font-size:var(--font-size-xs);padding-left:18px}
  .tooltip-wrap,.dmgstack-tips{max-width:280px;font-size:11px;padding:8px 12px}
  td.build {
  white-space:nowrap;
    overflow:hidden;text-overflow:ellipsis;padding:0 12px!important;font-size: 25px;
}
}</style>
<script>// head start
(function() {
  'use strict';
  
  // Safe property getter with dot notation
  if (typeof window.safeGet !== 'function') {
    window.safeGet = function(obj, path) {
      if (!path || typeof path !== 'string') return undefined;
      try {
        return path.split('.').reduce(function(acc, key) {
          return (acc && acc[key] !== undefined) ? acc[key] : undefined;
        }, obj);
      } catch (e) {
        return undefined;
      }
    };
  }
  
  // Touch handler initialization
  const initTouchHandler = function() {
    const container = document.getElementById("altsim");
    if (!container) return;
    
    let lastTouchTime = 0;
    
    // Better performance on iOS with passive listeners
    container.addEventListener("touchstart", function() {
      lastTouchTime = Date.now();
    }, { passive: true, capture: true });
    
    container.addEventListener("click", function(e) {
      if (Date.now() - lastTouchTime < 300) {
        const target = e.target;
        
        // Only block clicks on locked input wrappers - fully automatic
        if (isInsideLockedInputWrap(target)) {
          e.stopImmediatePropagation();
          e.preventDefault();
        }
      }
    }, { capture: true });
  };
  
  // Check if element is inside a locked input wrapper
  const isInsideLockedInputWrap = function(element) {
    let current = element;
    while (current && current !== document.body) {
      if (current.classList &&
        current.classList.contains('input-wrap') &&
        current.classList.contains('locked')) {
        return true;
      }
      current = current.parentNode;
    }
    return false;
  };
  
  // Snackbar position manager for responsive design
  const initSnackbarManager = function() {
    const reposition = function() {
      const sb = document.querySelector('.snackbar.show');
      if (sb) {
        if (!sb.hasAttribute('data-compat-bottom')) {
          const cur = sb.style.bottom;
          if (cur) sb.setAttribute('data-compat-bottom', cur);
        }
        sb.style.bottom = sb.getAttribute('data-compat-bottom') || '20px';
      }
    };
    window.addEventListener('resize', reposition, { passive: true });
  };
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener("DOMContentLoaded", function() {
      initTouchHandler();
      initSnackbarManager();
    });
  } else {
    initTouchHandler();
    initSnackbarManager();
  }
})();
// head end
</script>

<!-- end compat-shim -->

</head>
 <body>
   <div id="top"></div>
<div class="container" id="altsim">
<div id="version">
  <p><a href="https://discord.gg/9j2WnTAnMu" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="evenodd" clip-rule="evenodd" viewBox="0 0 512 512"><path fill="#5865F2" d="M105 0h302c57.928.155 104.845 47.072 105 104.996V407c-.155 57.926-47.072 104.844-104.996 104.998L105 512C47.074 511.844.156 464.926.002 407.003L0 105C.156 47.072 47.074.155 104.997 0H105z"/><g data-name=""><g data-name="Discord Logos"><path fill="#fff" fill-rule="nonzero" d="M368.896 153.381a269.506 269.506 0 00-67.118-20.637 186.88 186.88 0 00-8.57 17.475 250.337 250.337 0 00-37.247-2.8c-12.447 0-24.955.946-37.25 2.776-2.511-5.927-5.427-11.804-8.592-17.454a271.73 271.73 0 00-67.133 20.681c-42.479 62.841-53.991 124.112-48.235 184.513a270.622 270.622 0 0082.308 41.312c6.637-8.959 12.582-18.497 17.63-28.423a173.808 173.808 0 01-27.772-13.253c2.328-1.688 4.605-3.427 6.805-5.117 25.726 12.083 53.836 18.385 82.277 18.385 28.442 0 56.551-6.302 82.279-18.387 2.226 1.817 4.503 3.557 6.805 5.117a175.002 175.002 0 01-27.823 13.289 197.847 197.847 0 0017.631 28.4 269.513 269.513 0 0082.363-41.305l-.007.007c6.754-70.045-11.538-130.753-48.351-184.579zM201.968 300.789c-16.04 0-29.292-14.557-29.292-32.465s12.791-32.592 29.241-32.592 29.599 14.684 29.318 32.592c-.282 17.908-12.919 32.465-29.267 32.465zm108.062 0c-16.066 0-29.267-14.557-29.267-32.465s12.791-32.592 29.267-32.592c16.475 0 29.522 14.684 29.241 32.592-.281 17.908-12.894 32.465-29.241 32.465z" data-name="Discord Logo - Large - White"/></g></g></svg>Ragnarok X University</a></p>
  <p><i>v1.1.1</i> [<button id="openLog" type="button">Changelog</button>]</p>

</div>
<details id="howto">
  <summary>
    <span>How to Use</span>
  </summary>
  <div class="body">
<ol>
  <li>
    <strong>Dropdowns</strong>
    <ul>
      <li>Set <strong>Attack Type</strong>, <strong>Weapon</strong>, and <strong>Weapon Attribute</strong>.</li>
      <li>
        For <strong>MVP/MINI</strong>:
        <ul>
          <li>
            Selecting a specific MVP/Mini will auto <strong>sync and lock</strong> its <strong>size, race, and attribute</strong>.
            <em>(Example: <strong>Phreeoni = Large / Brute / Neutral</strong>. The fields stay fixed and you’ll need to fill the related numbers.)</em>
            <ul>
              <li>
                If you only have a <strong>Race enchant (or only Attribute)</strong>, just set the other field to <code>0</code>.
                <ul>
                  <li>Example: <strong>Brute 0 / Neutral 20</strong></li>
                  <li>Example: <strong>Brute 30 / Neutral 0</strong></li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Selecting an <strong>Average Lv.</strong> can skip or set target race/attribute manually.</li>
          <li><em>If you don’t have race and/or attribute enchants, better go with <strong>Average Lv. Boss</strong> and skip those.</em></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    Equipment
    <ul>
      <li>Choose the set you’re using <strong>(Vesper / Blue / White)</strong>.</li>
    </ul>
  </li>
  <li>
    <strong>Stat Inputs</strong>
    <ul>
      <li>Enter your stats exactly as shown in game.</li>
      <li>
        Extra: <strong>Final DMG Bonus %</strong>
        <ul>
          <li>
            <strong><s>F. P/M DMG BONUS</s></strong>
            <ul>
              <li>Shown in <strong>detailed stats</strong> as <strong>Final Damage Stack / Final Damage Bonus</strong>. Make sure <strong>no buffs</strong> are on. If you don’t see it, set <strong>0</strong>.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Only <strong>numbers</strong>, don’t type <strong><s>“%”</s></strong>.</li>
      <li><strong>Decimals</strong> are fine. <em>(Example: <strong>888.88</strong>)</em></li>
    </ul>
  </li>
  <li>
    <strong>Calculate</strong>
    <ul>
      <li>Once everything is filled, hit <strong>Calculate</strong>.</li>
    </ul>
  </li>
  <li>
    <strong>Results</strong>
    <ul>
      <li>You’ll see <strong>base multiplier</strong> and a breakdown of your stats.</li>
    </ul>
  </li>
  <li>
    Simulate Flash
    <ul>
      <li>
        <strong>Spear of Eternity</strong> and <strong>Reaper Scythe</strong>.
        <ul>
          <li><em>Each has 10s duration / 20s cooldown with <strong>+84% or +28%</strong> bonus. This tool normalize <strong>to 42</strong> and <strong>14</strong> for <strong>100% uptime</strong>(?)</em></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <strong>Swap Target</strong>
    <ul>
      <li>Lets you <strong>switch bosses</strong> without starting over.</li>
      <li>If the new boss has <strong>different size/race/element</strong>, the inputs unlock and you’ll need to <strong>re-input stats</strong>.</li>
      <li>
        If it’s the
        <strong>
          same type</strong>, the calc <strong>updates instantly</strong>.
      </li>
      <li>
        <em>Examples:</em>
        <ul>
          <li><strong>Phreeoni 140 → Deviling 150</strong> → re-enter <strong>Medium / Demon / Shadow</strong>.</li>
          <li><strong>Phreeoni 140 → Phreeoni 150</strong> → auto updates, no changes.</li>
          <li><strong>Phreeoni 150 → Avg. 140</strong> → race/element are <strong>cleared</strong>, treated as average <strong>Large Boss Lv.140</strong>.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <strong>Recommendations</strong>
    <ul>
      <li>At the bottom you’ll see a table with recommended <strong><s>ratios</s></strong> stat allocations.</li>
      <li>Hit <strong>Refresh</strong> to roll new sets until you see one you can actually use.</li>
    </ul>
  </li>
</ol>
  </div>
</details>
  <div class="form-row">
    <div class="form-group">
      <label for="penCritSelect" id="atkTypeLabel">Attack Type</label>
      <div class="input-wrap select-wrap">
        <select id="penCritSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="weaponSelect" id="weaponLabel">Weapon Type</label>
      <div class="input-wrap select-wrap">
        <select id="weaponSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="weaponElementSelect" id="wElemLabel">Weapon Attribute</label>
      <div class="input-wrap select-wrap">
        <select id="weaponElementSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="targetDefSelect" id="tDefLabel">MVP/MINI</label>
      <div class="input-wrap select-wrap">
        <select id="targetDefSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="targetSizeSelect" id="tSizeLabel">Target Size</label>
      <div class="input-wrap select-wrap">
        <select id="targetSizeSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="targetRaceSelect" id="tRaceLabel">Target Race<button type="button" id="targetRaceTips" class="tooltip-button"><svg xmlns="http://www.w3.org/2000/svg" height="70" fill="#dcddde" viewBox="0 -960 960 960" width="70"><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg></button></label>
      <div class="input-wrap select-wrap">
        <select id="targetRaceSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="targetElementSelect" id="tAttrLabel">Target Attribute<button type="button" id="targetAttrTips" class="tooltip-button"><svg xmlns="http://www.w3.org/2000/svg" height="70" fill="#dcddde" viewBox="0 -960 960 960" width="70"><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg></button></label>
      <div class="input-wrap select-wrap">
        <select id="targetElementSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="vesperSet" id="vesperSetLabel">Vesper Set</label>
      <div class="input-wrap select-wrap">
        <select id="vesperSet"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="blueSet" id="blueSetLabel">Blue Set</label>
      <div class="input-wrap select-wrap">
        <select id="blueSet"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="whiteSet" id="whiteSetLabel">White Set (110*3)</label>
      <div class="input-wrap select-wrap">
        <select id="whiteSet"></select>
      </div>
    </div>
  </div>

  <div class="form-row">
    <div class="form-group pen-group">
      <label for="pen" id="penLabel">Final P M PEN %</label>
      <div class="input-wrap">
        <input id="pen" type="number" min="1" max="3333" disabled placeholder="total converted raw pen + fpen %" />
      </div>
    </div>
    <div class="form-group crit-group">
      <label for="crit" id="critLabel">Critical DMG Bonus %</label>
      <div class="input-wrap">
        <input id="crit" type="number" min="1" max="3333" disabled placeholder="crit damage bonus %" />
      </div>
    </div>
    <div class="form-group">
      <label for="dmg" id="dmgLabel">Final P M DMG Bonus %</label>
      <div class="input-wrap">
        <input id="dmg" type="number" min="1" max="2222" placeholder="input f. p/m dmg bns..." />
      </div>
    </div>
    <div class="form-group">
      <label for="elemEnhance" id="elemEnhLabel">Element Enhance %</label>
      <div class="input-wrap">
        <input id="elemEnhance" type="number" min="1" max="2222"/>
      </div>
    </div>
    <div class="form-group">
      <label for="sizeEnhance" id="sizeLabel">DMG to Size %</label>
      <div class="input-wrap">
        <input id="sizeEnhance" type="number" min="1" max="2222"/>
      </div>
    </div>
    <div class="form-group">
      <label for="race">DMG to <span id="raceLabel">Race</span><button type="button" id="dmgRaceTips" class="tooltip-button"><svg xmlns="http://www.w3.org/2000/svg" height="70" fill="#dcddde" viewBox="0 -960 960 960" width="70"><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg></button></label>
      <div class="input-wrap">
        <input id="race" type="number" min="0" max="888" disabled />
      </div>
    </div>
    <div class="form-group">
      <label for="attr">DMG to <span id="attrLabel"></span> Attribute<button type="button" id="dmgAttrTips" class="tooltip-button"><svg xmlns="http://www.w3.org/2000/svg" height="70" fill="#dcddde" viewBox="0 -960 960 960" width="70"><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg></button></label>
      <div class="input-wrap">
        <input id="attr" type="number" min="0" max="888" disabled />
      </div>
    </div>
    <div class="form-group">
      <label for="dmgStack" id="dmgStackLabel">Extra: Final DMG Bonus<button type="button" id="dmgStackTips" class="dmgstack-tooltip"><svg xmlns="http://www.w3.org/2000/svg" height="70" fill="#dcddde" viewBox="0 -960 960 960" width="70"><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg></button></label>
      <div class="input-wrap">
        <input id="dmgStack" type="number" min="0" max="888" placeholder="input final dmg bonus%..." />
        
      </div>
    </div>

  </div>

  <div class="btn-row">
    <button id="submitBtn" type="button">Calculate</button>
    <button id="testSpear" type="button" disabled>Simulate Spear</button>
    <button id="testReaper" type="button" disabled>Simulate Reaper</button>
    <button class="reset-recommendations reset-rek-btn" id="resetRekomenBtn" type="button" disabled>Refresh Recommendations</button>
    <button id="resetAllBtn" type="button" disabled>Reset All</button>
  </div>

  <div id="hasil">
    Input stats to see the result...</div>

  <div id="recommendations">
    Recommended stat allocations will show up here. This tool randomizes your stats to find the best combination for higher output.
  </div>
  <div class="footer"><i>Have an issue?</i><br/>
  Silja [Odin-Nastia] <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="evenodd" clip-rule="evenodd" viewBox="0 0 512 512"><path fill="#5865F2" d="M105 0h302c57.928.155 104.845 47.072 105 104.996V407c-.155 57.926-47.072 104.844-104.996 104.998L105 512C47.074 511.844.156 464.926.002 407.003L0 105C.156 47.072 47.074.155 104.997 0H105z"/><g data-name=""><g data-name="Discord Logos"><path fill="#fff" fill-rule="nonzero" d="M368.896 153.381a269.506 269.506 0 00-67.118-20.637 186.88 186.88 0 00-8.57 17.475 250.337 250.337 0 00-37.247-2.8c-12.447 0-24.955.946-37.25 2.776-2.511-5.927-5.427-11.804-8.592-17.454a271.73 271.73 0 00-67.133 20.681c-42.479 62.841-53.991 124.112-48.235 184.513a270.622 270.622 0 0082.308 41.312c6.637-8.959 12.582-18.497 17.63-28.423a173.808 173.808 0 01-27.772-13.253c2.328-1.688 4.605-3.427 6.805-5.117 25.726 12.083 53.836 18.385 82.277 18.385 28.442 0 56.551-6.302 82.279-18.387 2.226 1.817 4.503 3.557 6.805 5.117a175.002 175.002 0 01-27.823 13.289 197.847 197.847 0 0017.631 28.4 269.513 269.513 0 0082.363-41.305l-.007.007c6.754-70.045-11.538-130.753-48.351-184.579zM201.968 300.789c-16.04 0-29.292-14.557-29.292-32.465s12.791-32.592 29.241-32.592 29.599 14.684 29.318 32.592c-.282 17.908-12.919 32.465-29.267 32.465zm108.062 0c-16.066 0-29.267-14.557-29.267-32.465s12.791-32.592 29.267-32.592c16.475 0 29.522 14.684 29.241 32.592-.281 17.908-12.894 32.465-29.241 32.465z" data-name="Discord Logo - Large - White"/></g></g></svg>sanditama#7047</div>
</div>

<div class="log" id="log">
  <div class="changelog">
    <div class="header-log"><span class="close" id="closeLog">&times;</span>
    <h2>Changelog</h2>
    </div>
    <div class="version">
  <h3>[Unreleased]</h3>
  <ul>
    <li>MINIGAME!</li>
  </ul>
</div>
<div class="version">
  <h3>[v1.1.1] - Sept 21, 2025</h3>
  <ul>
    <li><span class="sub-cats">Added</span>
      <ul>
        <li>Tooltips (help) for inputing data</li>
      </ul>
    </li>
    <!--li><span class="sub-cats">Updated</span>
      <ul>
      </ul>
    </li-->
    <li><span class="sub-cats">Improved</span>
      <ul>
        <li>Input validation</li>
        <li>optimize flow n logic 3 eq set selection</li>
        <li>Button feedback</li>
        <li>push your stats to table</li>
        <li>ui/ux (mobile prior)</li>
        <li>cross-browser compatibility</li>
      </ul>
    </li>
  </ul>
</div>

<div class="version">
  <h3>[v1.1.0] - Sept 18, 2025</h3>
  <ul>
    <li><span class="sub-cats">Added</span>
      <ul>
        <li>Welcome dark theme</li>
        <li>Equipment SET
          <ul>
            <li>Vesper</li>
            <li>Blue</li>
            <li>White 110</li>
          </ul>
        </li>
        <li>Final DMG Bonus field</li>
        <li>Simulate "Interactive" Divinity Flash
          <ul>
            <li>Spear of Eternity</li>
            <li>Reaper Scythe</li>
          </ul>
        </li>
      </ul>
    </li>
    <li><span class="sub-cats">Updated</span>
      <ul>
        <li>Calculation Formula</li>
      </ul>
    </li>
    <li><span class="sub-cats">Improved</span>
      <ul>
        <li>UI/UX
          <ul>
            <li>Input validation tips</li>
            <li>each button has its own feedback</li>

          </ul>
        </li>
        <li>Balancing recommendations
          <ul>
            <li></li>
            <li></li>
          </ul>
        </li>
        <li></li>
        <li>Swap Boss
          <ul>
            <li>stats editable after swap</li>
            <li>can skip race / attr field (set to 0)</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div class="version">
  <h3>[v1.0.9] - Sept 11, 2025</h3>
  <ul>
    <li><span class="sub-cats">Added</span>
      <ul>
        <li>All MVP/MINI Lv. 140 & Lv. 150 includes
          <ul>
            <li>DEF stats</li>
            <li>Size</li>
            <li>Race</li>
            <li>and Attribute</li>
          </ul>
        </li>
      </ul>
    </li>
    <li><span class="sub-cats">Updated</span>
      <ul>
        <li>"How to Use" section</li>
      </ul>
    </li>
    <li><span class="sub-cats">Improved</span>
      <ul>
        <li>Results
          <ul>
            <li>more precise stats calc</li>
            <li>show/hide precise nums</li>
          </ul>
        </li>
        <li>Balancing recommendations
          <ul>
            <li>better logic for race and/or attr</li>
            <li>extra cats when race & attr too low</li>
          </ul>
        </li>
        <li>Sticky "smooth" button</li>
        <li>Swap Boss
          <ul>
            <li>stats editable after swap</li>
            <li>can skip race / attr field (set to 0)</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>
<div class="version">
  <h3>[v1.0.8] - Aug 31, 2025</h3>
  <ul>
    <li><span class="sub-cats">Added</span>
      <ul>
        <li>Changelog</li>
        <li>"How to Use" section at top of page</li>
        <li>Target DEF dropdown (used in calc)
          <ul>
            <li>Dummy (0 DEF)</li>
            <li>Avg. MVP/MINI Lv. 130</li>
            <li>Avg. MVP/MINI Lv. 140</li>
            <li>Avg. MVP/MINI Lv. 150</li>
          </ul>
        </li>
        <li>Swap target DEF</li>
        <li>Double tap/click guard</li>
        <li>Sticky collapsible button on scroll (mobile)</li>
      </ul>
    </li>
    
    <li><span class="sub-cats">Updated</span>
      <ul>
        <li>Calc formula
          <ul>
            <li>added counter DEF</li>
          </ul>
        </li>
      </ul>
    </li>
    
    <li><span class="sub-cats">Improved</span>
      <ul>
        <li>cross-browser support</li>
        <li>main flow + logic</li>
        <li>input validation</li>
        <li>results breakdown by factor</li>
        <li>recommendation table logic</li>
      </ul>
    </li>
  </ul>
</div>
<div class="version">
  <h3>[v1.0.0] - Aug 28, 2025</h3>
  <ul>
    <li>Initial release
      <ul>
        <li>6 dropdowns + 6 numeric inputs</li>
        <li>3 buttons</li>
        <li>Result card</li>
        <li>randomize stats in rec table</li>
      </ul>
    </li>
  </ul>
</div>
  </div>
</div>
<div aria-live="polite" class="snackbar" id="snackbar" role="status">
  </div>
<script>
// ========== ROX DATA CONSTANTS ==========
// def stats from Nila 
const DEFENSE_TABLE = {
  "0def": { def: 0, dmgred: 0 },
  "130boss": { def: 194.36, dmgred:156.81 },
  "140boss": { def: 158.37, dmgred: 212.41 },
  "150boss": { def: 194.77, dmgred: 304.07},
  "Phreeoni Lv.140": { def: 106.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Brute", attributeMob: "Neutral" },
  "Mistress Lv.140": { def: 130.18, dmgred: 272.80, sizeMob: "Small", raceMob: "Insect", attributeMob: "Wind" },
  "Eddga Lv.140": { def: 106.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Brute", attributeMob: "Fire" },
  "Kraken Lv.140": { def: 130.18, dmgred: 272.80, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Maya Lv.140": { def: 98.97, dmgred: 136.40, sizeMob: "Large", raceMob: "Insect", attributeMob: "Earth" },
  "Orc Hero Lv.140": { def: 82.47, dmgred: 136.40, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Pharaoh Lv.140": { def: 98.97, dmgred: 136.40, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Shadow" },
  "Orc Lord Lv.140": { def: 82.47, dmgred: 136.40, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Doppelganger Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Amon Ra Lv.140": { def: 106.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Morroc Lv.140": { def: 131.97, dmgred: 136.40, sizeMob: "Large", raceMob: "Demon", attributeMob: "Shadow" },
  "Time Holder Lv.140": { def: 164.97, dmgred: 136.40, sizeMob: "Large", raceMob: "Demon", attributeMob: "Neutral" },
  "Tao Gunka Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Demon", attributeMob: "Neutral" },
  "Lost Dragon Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Shadow" },
  "Fallen Bishop Lv.140": { def: 164.97, dmgred: 136.40, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Lord of the Dead Lv.140": { def: 131.97, dmgred: 136.40, sizeMob: "Large", raceMob: "Demon", attributeMob: "Shadow" },
  "Arc Angeling Lv.140": { def: 164.97, dmgred: 136.40, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" },
  "Gioia Lv.140": { def: 212.68, dmgred: 272.80, sizeMob: "Large", raceMob: "Formless", attributeMob: "Wind" },
  "RSX-0806 Lv.140": { def: 238.66, dmgred: 202.00, sizeMob: "Medium", raceMob: "Formless", attributeMob: "Neutral" },
  "Nidhoggr's Shadow Lv.140": { def: 181.21, dmgred: 134.00, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Shadow" },
  "Gloom Under Night Lv.140": { def: 306.00, dmgred: 300.00, sizeMob: "Large", raceMob: "Formless", attributeMob: "Ghost" },
  "Retribution Lv.140": { def: 256.50, dmgred: 300.00, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Shadow" },
  "Dragon Fly Lv.140": { def: 106.98, dmgred: 204.60, sizeMob: "Small", raceMob: "Insect", attributeMob: "Wind" },
  "Eclipse Lv.140": { def: 130.18, dmgred: 272.80, sizeMob: "Small", raceMob: "Brute", attributeMob: "Neutral" },
  "Mastering Lv.140": { def: 130.18, dmgred: 272.80, sizeMob: "Medium", raceMob: "Plant", attributeMob: "Water" },
  "Ghostring Lv.140": { def: 106.98, dmgred: 204.60, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Ghost" },
  "Toad Lv.140": { def: 98.97, dmgred: 136.40, sizeMob: "Small", raceMob: "Fish", attributeMob: "Water" },
  "King Dramoh Lv.140": { def: 82.47, dmgred: 136.40, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Angeling Lv.140": { def: 98.97, dmgred: 136.40, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" },
  "Deviling Lv.140": { def: 82.47, dmgred: 136.40, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Dark Priest Lv.140": { def: 212.68, dmgred: 272.80, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Undead" },
  "Vagabond Wolf Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Medium", raceMob: "Brute", attributeMob: "Earth" },
  "Chimera Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Brute", attributeMob: "Fire" },
  "Mysteltainn Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Formless", attributeMob: "Shadow" },
  "Ogretooth Lv.140": { def: 212.68, dmgred: 306.35, sizeMob: "Medium", raceMob: "Formless", attributeMob: "Shadow" },
  "Necromancer Lv.140": { def: 131.97, dmgred: 150.75, sizeMob: "Medium", raceMob: "Undead", attributeMob: "Undead" },
  "Coelacanth Lv.140": { def: 139.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Naght Sieger Lv.140": { def: 212.68, dmgred: 272.80, sizeMob: "Large", raceMob: "Demon", attributeMob: "Ghost" },
  "Observation Lv.140": { def: 146.68, dmgred: 272.80, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Neutral" },
  "Skeggiold Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Small", raceMob: "Angel", attributeMob: "Holy" },
  "Queen Scaraba Lv.140": { def: 212.30, dmgred: 268.70, sizeMob: "Small", raceMob: "Insect", attributeMob: "Earth" },
  "Faceworm Queen Lv.140": { def: 245.30, dmgred: 268.70, sizeMob: "Small", raceMob: "Insect", attributeMob: "Poison" },
  "Ktullanux Lv.140": { def: 256.50, dmgred: 542.27, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Water" },
  "Shelter Lv.140": { def: 251.18, dmgred: 258.00, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" },
  "Phreeoni Lv.150": { def: 136.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Brute", attributeMob: "Neutral" },
  "Mistress Lv.150": { def: 161.98, dmgred: 361.00, sizeMob: "Small", raceMob: "Insect", attributeMob: "Wind" },
  "Eddga Lv.150": { def: 136.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Brute", attributeMob: "Fire" },
  "Kraken Lv.150": { def: 161.98, dmgred: 361.00, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Maya Lv.150": { def: 118.76, dmgred: 186.70, sizeMob: "Large", raceMob: "Insect", attributeMob: "Earth" },
  "Orc Hero Lv.150": { def: 110.67, dmgred: 261.40, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Pharaoh Lv.150": { def: 118.76, dmgred: 186.70, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Shadow" },
  "Orc Lord Lv.150": { def: 110.67, dmgred: 261.40, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Doppelganger Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Amon Ra Lv.150": { def: 136.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Morroc Lv.150": { def: 169.17, dmgred: 261.40, sizeMob: "Large", raceMob: "Demon", attributeMob: "Shadow" },
  "Time Holder Lv.150": { def: 196.76, dmgred: 186.70, sizeMob: "Large", raceMob: "Demon", attributeMob: "Neutral" },
  "Tao Gunka Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Demon", attributeMob: "Neutral" },
  "Lost Dragon Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Shadow" },
  "Fallen Bishop Lv.150": { def: 196.76, dmgred: 186.70, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Lord of the Dead Lv.150": { def: 169.17, dmgred: 261.40, sizeMob: "Large", raceMob: "Demon", attributeMob: "Shadow" },
  "Arc Angeling Lv.150": { def: 196.76, dmgred: 186.70, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" },
  "Gioia Lv.150": { def: 259.48, dmgred: 361.00, sizeMob: "Large", raceMob: "Formless", attributeMob: "Wind" },
  "RSX-0806 Lv.150": { def: 293.16, dmgred: 317.00, sizeMob: "Medium", raceMob: "Formless", attributeMob: "Neutral" },
  "Nidhoggr's Shadow Lv.150": { def: 228.13, dmgred: 266.00, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Shadow" },
  "Gloom Under Night Lv.150": { def: 357.57, dmgred: 367.00, sizeMob: "Large", raceMob: "Formless", attributeMob: "Ghost" },
  "Retribution Lv.150": { def: 299.07, dmgred: 367.00, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Shadow" },
  "Dragon Fly Lv.150": { def: 136.62, dmgred: 311.20, sizeMob: "Small", raceMob: "Insect", attributeMob: "Wind" },
  "Eclipse Lv.150": { def: 161.98, dmgred: 361.00, sizeMob: "Small", raceMob: "Brute", attributeMob: "Neutral" },
  "Mastering Lv.150": { def: 161.98, dmgred: 361.00, sizeMob: "Medium", raceMob: "Plant", attributeMob: "Water" },
  "Ghostring Lv.150": { def: 136.62, dmgred: 311.20, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Ghost" },
  "Toad Lv.150": { def: 118.76, dmgred: 186.70, sizeMob: "Small", raceMob: "Fish", attributeMob: "Water" },
  "King Dramoh Lv.150": { def: 110.67, dmgred: 261.40, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Angeling Lv.150": { def: 118.76, dmgred: 186.70, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" },
  "Deviling Lv.150": { def: 110.66, dmgred: 261.40, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Dark Priest Lv.150": { def: 259.48, dmgred: 361.00, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Undead" },
  "Vagabond Wolf Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Medium", raceMob: "Brute", attributeMob: "Earth" },
  "Chimera Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Brute", attributeMob: "Fire" },
  "Mysteltainn Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Formless", attributeMob: "Shadow" },
  "Ogretooth Lv.150": { def: 259.48, dmgred: 385.89, sizeMob: "Medium", raceMob: "Formless", attributeMob: "Shadow" },
  "Necromancer Lv.150": { def: 169.17, dmgred: 272.00, sizeMob: "Medium", raceMob: "Undead", attributeMob: "Undead" },
  "Coelacanth Lv.150": { def: 175.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Naght Sieger Lv.150": { def: 259.48, dmgred: 361.00, sizeMob: "Large", raceMob: "Demon", attributeMob: "Ghost" },
  "Observation Lv.150": { def: 181.48, dmgred: 361.00, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Neutral" },
  "Skeggiold Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Small", raceMob: "Angel", attributeMob: "Holy" },
  "Queen Scaraba Lv.150": { def: 258.55, dmgred: 351.40, sizeMob: "Small", raceMob: "Insect", attributeMob: "Earth" },
  "Faceworm Queen Lv.150": { def: 297.55, dmgred: 351.40, sizeMob: "Small", raceMob: "Insect", attributeMob: "Poison" },
  "Ktullanux Lv.150": { def: 299.07, dmgred: 575.77, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Water" },
  "Shelter Lv.150": { def: 293.16, dmgred: 317.00, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" }
};
const ELEMENT_COUNTER_TABLE = {
  Neutral:{Neutral:1,Fire:1,Water:1,Earth:1,Wind:1,Poison:1,Holy:1,Shadow:1,Ghost:0.70,Undead:1},
  Fire:{Neutral:1,Fire:0.25,Water:1,Earth:1.25,Wind:1,Poison:1,Holy:0.75,Shadow:1,Ghost:1,Undead:1.125},
  Water:{Neutral:1,Fire:1.25,Water:0.25,Earth:1,Wind:0.90,Poison:1,Holy:0.75,Shadow:1,Ghost:1,Undead:1},
  Earth:{Neutral:1,Fire:0.90,Water:1,Earth:0.25,Wind:1.25,Poison:1,Holy:0.75,Shadow:1,Ghost:1,Undead:1},
  Wind:{Neutral:1,Fire:1,Water:1.375,Earth:0.90,Wind:0.25,Poison:1,Holy:0.70,Shadow:1,Ghost:1,Undead:1},
  Poison:{Neutral:1,Fire:1.125,Water:1,Earth:1.125,Wind:1.125,Poison:0,Holy:0.75,Shadow:0.50,Ghost:1,Undead:-0.25},
  Holy:{Neutral:1,Fire:1,Water:1,Earth:1,Wind:1,Poison:1,Holy:0,Shadow:1.375,Ghost:1,Undead:1.375},
  Shadow:{Neutral:1.125,Fire:1,Water:1,Earth:1,Wind:1,Poison:0.50,Holy:1.375,Shadow:0,Ghost:1,Undead:-0.25},
  Ghost:{Neutral:0.90,Fire:1,Water:1,Earth:1,Wind:1,Poison:1,Holy:0.75,Shadow:0.75,Ghost:1.375,Undead:1},
  Undead:{Neutral:1,Fire:1,Water:1,Earth:1,Wind:1,Poison:0.50,Holy:1.375,Shadow:0,Ghost:1.25,Undead:0}
};
const WEAPON_SIZE_MODIFIER_TABLE = {
  "Empty Handed":{Large:0.5,Medium:0.5,Small:0.5},
  "One-Handed Sword":{Large:0.75,Medium:1,Small:0.75},
  "Two-Handed Sword":{Large:1,Medium:0.75,Small:0.75},
  "Two-Handed Spear":{Large:1,Medium:0.75,Small:0.75},
  "Dagger":{Large:0.75,Medium:0.75,Small:1},
  "Katar":{Large:0.75,Medium:1,Small:0.75},
  "Light Knuckle":{Large:0.75,Medium:0.75,Small:1},
  "Heavy Knuckle":{Large:1,Medium:0.75,Small:0.75},
  "GS":{Large:1,Medium:1,Small:1},
  "Ninja Sword":{Large:1,Medium:0.75,Small:0.75},
  "Huuma Shuriken":{Large:1,Medium:1,Small:1},
  "Tome":{Large:0.75,Medium:1,Small:1},
  "Book":{Large:1,Medium:1,Small:1},
  "Two-Handed Rod":{Large:1,Medium:1,Small:1},
  "One-Handed Rod":{Large:1,Medium:1,Small:1},
  "Mace":{Large:1,Medium:0.75,Small:0.75},
  "One-Handed Axe":{Large:0.75,Medium:0.75,Small:0.75},
  "Two-Handed Axe":{Large:0.5,Medium:0.75,Small:0.75},
  "Bow":{Large:0.75,Medium:1,Small:1},
  "Instrument":{Large:0.75,Medium:1,Small:0.75},
  "Whip":{Large:0.75,Medium:1,Small:0.75}
};
const BLUE_SET = {
  3: {
    30: 5,
    40: 7.5,
    50: 10,
    60: 12.5,
    70: 15,
    80: 17.5,
    90: 20,
    100: 22.5,
    110: 25,
    120: 27.5,
    130: 30,
    140: 32.5,
    150: 35
  /*
  },
  8: {
    30: 5,
    40: 10,
    50: 15,
    60: 20,
    70: 25,
    80: 30,
    90: 35,
    100: 40,
    110: 45,
    120: 50,
    130: 55,
    140: 60,
    150: 65
  */
  }
};
const VESPER_SET = {
  0: 8,
  1: 16,
  2: 24,
  3: 32,
  4: 40,
  5: 48,
  6: 56,
  7: 64,
  8: 72,
  9: 80
};
const WHITE_SET = {
  "Tier 0" : 30,
  "Tier 1" : 36,
  "Tier 2" : 42,
  "Tier 3" : 48,
  "Tier 4" : 54
}
const RACE_TYPES = ["Angel","Demon","Formless","Insect","Fish","Demi-Human","Undead","Dragon","Plant","Brute"];

// ========== DOM ELEMENTS CACHE ==========
const DOM_ELEMENTS = {
  topOfPage: document.getElementById('top'),
  atkType: document.getElementById('penCritSelect'),
  weapon: document.getElementById('weaponSelect'),
  wElem: document.getElementById('weaponElementSelect'),
  tSize: document.getElementById('targetSizeSelect'),
  tRace: document.getElementById('targetRaceSelect'),
  tAttr: document.getElementById('targetElementSelect'),
  tDef: document.getElementById('targetDefSelect'),
  blueSet: document.getElementById("blueSet"),
  blueSetLabel: document.getElementById("blueSetLabel"),
  vesperSet: document.getElementById("vesperSet"),
  vesperSetLabel: document.getElementById("vesperSetLabel"),
  whiteSet: document.getElementById("whiteSet"),
  whiteSetLabel: document.getElementById("whiteSetLabel"),
  tDefLabel: document.getElementById('tDefLabel'),
  atkTypeLabel: document.getElementById('atkTypeLabel'),
  weaponLabel: document.getElementById('weaponLabel'),
  wElemLabel: document.getElementById('wElemLabel'),
  tSizeLabel: document.getElementById('tSizeLabel'),
  tRaceLabel: document.getElementById('tRaceLabel'),
  tAttrLabel: document.getElementById('tAttrLabel'),
  pen: document.getElementById('pen'),
  crit: document.getElementById('crit'),
  dmgStack: document.getElementById('dmgStack'),
  dmgStackTips: document.getElementById('dmgStackTips'),
  dmg: document.getElementById('dmg'),
  elemEnh: document.getElementById('elemEnhance'),
  sizeEnh: document.getElementById('sizeEnhance'),
  race: document.getElementById('race'),
  attr: document.getElementById('attr'),
  penLabel: document.getElementById('penLabel'),
  critLabel: document.getElementById('critLabel'),
  dmgLabel: document.getElementById('dmgLabel'),
  elemEnhLabel: document.getElementById('elemEnhLabel'),
  sizeLabel: document.getElementById('sizeLabel'),
  raceLabel: document.getElementById('raceLabel'),
  attrLabel: document.getElementById('attrLabel'),
  hasil: document.getElementById('hasil'),
  rec: document.getElementById('recommendations'),
  submit: document.getElementById('submitBtn'),
  resetRek: document.getElementById('resetRekomenBtn'),
  resetAll: document.getElementById('resetAllBtn'),
  testSpear: document.getElementById('testSpear'),
  testReaper: document.getElementById('testReaper'),
  snackbar: document.getElementById('snackbar'),
  log: document.getElementById("log"),
  openLog: document.getElementById("openLog"),
  closeLog: document.getElementById("closeLog")
};
const isEmpty = (v) => v === null || v === undefined || v === '';
const clearNumericInput = (el) => { if (el) el.value = ''; };
const safeNumber = (v) => Math.max(Number(v) || 0, 0);
const formatNumber = (n, fullPrecision = false) => {
  const num = Number(n);
  return fullPrecision ? num : Math.trunc(num * 100) / 100;
};

// ========== CALCULATION HELPER ==========
function getWeaponSizeModifier(weapon, size) {
  const modMap = WEAPON_SIZE_MODIFIER_TABLE[weapon];
  if (!modMap) return 1.0;
  const val = modMap[size];
  return Number.isFinite(val) ? Number(val) : 1.0;
}
function getElementCounter(weaponElem, targetElem) {
  const elemMap = ELEMENT_COUNTER_TABLE[weaponElem] || ELEMENT_COUNTER_TABLE['Neutral'];
  const base = targetElem ? 
    (elemMap[targetElem] ?? elemMap['Neutral'] ?? 1.0) : 
    (elemMap['Neutral'] ?? 1.0);
  return Number.isFinite(base) ? Number(base) : 1.0;
}
function getTargetDefenseData(key) {
  return DEFENSE_TABLE[key] || DEFENSE_TABLE["0def"];
}
function calculateAttackFactor(type, pen, crit, def = 0) {
  if (type === 'pen') {
    const rawPen = (Number(pen) || 0) - (Number(def) || 0);
    if (rawPen <= 0) return 0;
    const effPen = rawPen >= 150 ? ((rawPen * 2) - 150) : rawPen;
    return effPen / 100;
  }
  if (type === 'crit') {
    return (Number(crit) || 0) / 100;
  }
  return 0;
}

// ======== CALCULATION ========
// SSOT FORMULA
function calculateMultiplier({
  atkType, penVal, critVal, dmgVal,
  sizeEnhVal, elemEnhVal, raceVal, attrVal,
  weapon, tSize, wElem, tAttr, tRace, tDefKey,
  extras = {}
}) {
  const { def, dmgred } = getTargetDefenseData(tDefKey);
  const atkF = calculateAttackFactor(atkType, penVal, critVal, def);

  const effDmgVal = Number(dmgVal) - dmgred;
  const sizeMod = getWeaponSizeModifier(weapon, tSize);
  const elemCtr = getElementCounter(wElem, tAttr);

  // Base multiplier (core factors only)
  const baseMult = (1 + atkF) *
    (1 + (effDmgVal / 100)) *
    (sizeMod + (Number(sizeEnhVal) / 100)) *
    (elemCtr + (Number(elemEnhVal) / 100)) *
    (1 + (tAttr ? (Number(attrVal) / 100) : 0)) *
    (1 + (tRace ? (Number(raceVal) / 100) : 0));

  // Extract extras with single conversion
  const blueGroup3Val = Number(extras.blueGroup3Val || extras.blue3 || 0);
  const blueGroup8Val = Number(extras.blueGroup8Val || extras.blue8 || 0);
  const vesperVal = Number(extras.vesperVal || extras.vesper || 0);
  const whiteVal = Number(extras.whiteVal || extras.white || 0);
  const dmgStackVal = Number(extras.dmgStackVal || extras.dmgStack || 0);

  // Pre-calculate groups for efficiency
  const groups = {
    extra1: { sum: 0, items: [] },
    extra2: { sum: 0, items: [] }
  };

  // Build extra bonuses more efficiently
  if (vesperVal > 0) {
    groups.extra1.sum += vesperVal / 100;
    groups.extra1.items.push({ key: 'Vesper', type: 'extra1', value: vesperVal / 100 });
  }
  if (blueGroup3Val > 0) {
    groups.extra1.sum += blueGroup3Val / 100;
    groups.extra1.items.push({ key: 'BlueGroup3', type: 'extra1', value: blueGroup3Val / 100 });
  }
  if (whiteVal > 0) {
    groups.extra1.sum += whiteVal / 100;
    groups.extra1.items.push({ key: 'White', type: 'extra1', value: whiteVal / 100 });
  }
  if (dmgStackVal > 0) {
    groups.extra1.sum += dmgStackVal / 100;
    groups.extra1.items.push({ key: 'DmgStack', type: 'extra1', value: dmgStackVal / 100 });
  }

  // Reaper check (optimized try-catch)
  try {
    if (typeof isTestReaperActive !== 'undefined' && isTestReaperActive) {
      const reaperVal = ((wElem === tAttr) || (wElem === "Neutral" && !tAttr)) ? 0.42 : 0.14;
      groups.extra1.sum += reaperVal;
      groups.extra1.items.push({ key: 'Reaper', type: 'extra1', value: reaperVal });
    }
  } catch(e) {}

  if (blueGroup8Val > 0) {
    groups.extra2.sum += blueGroup8Val / 100;
    groups.extra2.items.push({ key: 'BlueGroup8', type: 'extra2', value: blueGroup8Val / 100 });
  }

  // Spear check (optimized try-catch)
  try {
    if (typeof isTestSpearActive !== 'undefined' && isTestSpearActive) {
      groups.extra2.sum += 0.42;
      groups.extra2.items.push({ key: 'Spear', type: 'extra2', value: 0.42 });
    }
  } catch(e) {}

  // Calculate final multipliers
  const extraGroups = [];
  let extraMult = 1;

  if (groups.extra1.sum > 0) {
    const factor = 1 + groups.extra1.sum;
    extraGroups.push({ type: 'extra1', sum: groups.extra1.sum, factor, items: groups.extra1.items });
    extraMult *= factor;
  }
  if (groups.extra2.sum > 0) {
    const factor = 1 + groups.extra2.sum;
    extraGroups.push({ type: 'extra2', sum: groups.extra2.sum, factor, items: groups.extra2.items });
    extraMult *= factor;
  }

  const totalMult = baseMult * extraMult;

  return {
    mult: totalMult,
    def, dmgred, effDmgVal, atkF,
    parts: {
      baseMult: baseMult,
      extraGroups: extraGroups
    }
  };
}
let isResultShown = false;
function getCurrentCalculationState() {
  // Cache DOM values once
  const domValues = {
    atkType: DOM_ELEMENTS.atkType.value,
    pen: Number(DOM_ELEMENTS.pen.value) || 0,
    crit: Number(DOM_ELEMENTS.crit.value) || 0,
    dmg: Number(DOM_ELEMENTS.dmg.value) || 0,
    sizeEnh: Number(DOM_ELEMENTS.sizeEnh.value) || 0,
    elemEnh: Number(DOM_ELEMENTS.elemEnh.value) || 0,
    race: Number(DOM_ELEMENTS.race.value) || 0,
    attr: Number(DOM_ELEMENTS.attr.value) || 0,
    weapon: DOM_ELEMENTS.weapon.value,
    tSize: DOM_ELEMENTS.tSize.value,
    wElem: DOM_ELEMENTS.wElem.value,
    tAttr: DOM_ELEMENTS.tAttr.value,
    tRace: DOM_ELEMENTS.tRace.value,
    tDef: DOM_ELEMENTS.tDef.value,
    vesperSet: Number(DOM_ELEMENTS.vesperSet.value) || 0,
    whiteSet: Number(DOM_ELEMENTS.whiteSet.value) || 0,
    dmgStack: Number(DOM_ELEMENTS.dmgStack.value) || 0
  };

  // Detect BlueSet group (*3 or *8) by label text
  const blueSelect = DOM_ELEMENTS.blueSet;
  const selectedBlueOption = blueSelect?.options?.[blueSelect.selectedIndex];
  let blueGroup3Val = 0;
  let blueGroup8Val = 0;
  
  if (selectedBlueOption) {
    const optionText = selectedBlueOption.textContent || "";
    const blueValue = Number(blueSelect.value) || 0;
    if (optionText.includes('*3')) {
      blueGroup3Val = blueValue;
    }
    if (optionText.includes('*8')) {
      blueGroup8Val = blueValue;
    }
  }

  // Build extras object (single parameter)
  const extras = {
    blueGroup3Val,
    blueGroup8Val,
    vesperVal: domValues.vesperSet,
    whiteVal: domValues.whiteSet,
    dmgStackVal: domValues.dmgStack
  };

  const result = calculateMultiplier({
    atkType: domValues.atkType,
    penVal: domValues.pen,
    critVal: domValues.crit,
    dmgVal: domValues.dmg,
    sizeEnhVal: domValues.sizeEnh,
    elemEnhVal: domValues.elemEnh,
    raceVal: domValues.race,
    attrVal: domValues.attr,
    weapon: domValues.weapon,
    tSize: domValues.tSize,
    wElem: domValues.wElem,
    tAttr: domValues.tAttr,
    tRace: domValues.tRace,
    tDefKey: domValues.tDef,
    extras
  });

  return {
    atkType: domValues.atkType,
    penVal: domValues.pen,
    critVal: domValues.crit,
    dmgVal: domValues.dmg,
    sizeEnhVal: domValues.sizeEnh,
    elemEnhVal: domValues.elemEnh,
    raceVal: domValues.race,
    attrVal: domValues.attr,
    blueGroup3Val,
    blueGroup8Val,
    vesperVal: domValues.vesperSet,
    whiteVal: domValues.whiteSet,
    dmgStackVal: domValues.dmgStack,
    mult: result.mult,
    def: result.def,
    dmgred: result.dmgred,
    effDmgVal: result.effDmgVal,
    atkF: result.atkF,
    parts: result.parts || {},
    extraGroups: result.parts?.extraGroups || []
  };
}
let processMainCalculationTimeout = null;
function processMainCalculation() {
  // Clear existing timeout
  if (processMainCalculationTimeout) {
    clearTimeout(processMainCalculationTimeout);
  }
  
  processMainCalculationTimeout = setTimeout(() => {
    executeMainCalculation();
  }, 300);
}
function executeMainCalculation() {
  if (!validateRequiredFields()) return;

  const calculationState = getCurrentCalculationState();
  if (!validateStatsVsTarget(calculationState)) return;

  const isPenMode = calculationState.atkType === 'pen';
  const attackFactor = calculateAttackFactor(
    isPenMode ? 'pen' : 'crit',
    calculationState.penVal,
    calculationState.critVal,
    calculationState.def
  );
  const sizeModifier = getWeaponSizeModifier(DOM_ELEMENTS.weapon.value, DOM_ELEMENTS.tSize.value);
  const elementCounter = getElementCounter(DOM_ELEMENTS.wElem.value, DOM_ELEMENTS.tAttr.value);

  const includeRace = !!DOM_ELEMENTS.tRace.value && (calculationState.raceVal > 0);
  const includeAttr = !!DOM_ELEMENTS.tAttr.value && (calculationState.attrVal > 0);
  const includeExtra = (calculationState.blueGroup3Val > 0 || calculationState.blueGroup8Val > 0 || 
                       calculationState.vesperVal > 0 || calculationState.whiteVal > 0 || 
                       calculationState.dmgStackVal > 0);

  // Compute extra group authoritative factors (prefer calculation result)
  let extra1Factor = 1;
  let extra2Factor = 1;
  
  if (calculationState.parts?.extraGroups) {
    const eg1 = calculationState.parts.extraGroups.find(g => g.type === 'extra1');
    const eg2 = calculationState.parts.extraGroups.find(g => g.type === 'extra2');
    extra1Factor = eg1?.factor ?? (1 + (calculationState.blueGroup3Val / 100) + (calculationState.vesperVal / 100) + (calculationState.whiteVal / 100) + (calculationState.dmgStackVal / 100));
    extra2Factor = eg2?.factor ?? (1 + (calculationState.blueGroup8Val / 100));
  } else {
    extra1Factor = 1 + (calculationState.blueGroup3Val / 100) + (calculationState.vesperVal / 100) + (calculationState.whiteVal / 100) + (calculationState.dmgStackVal / 100);
    extra2Factor = 1 + (calculationState.blueGroup8Val / 100);
  }

  const includeExtraTwo = (calculationState.blueGroup8Val > 0 || (typeof isTestSpearActive !== 'undefined' && isTestSpearActive));
  
  const factorList = [
    {
      key: 'main',
      label: (isPenMode ? 'Type (PEN)' : 'Type (CRIT)'),
      val: isPenMode ? calculationState.penVal : calculationState.critVal,
      mult: 1 + attackFactor
    },
    {
      key: 'dmg',
      label: 'Final P/M DMG BNS',
      val: calculationState.dmgVal,
      mult: 1 + (calculationState.effDmgVal || 0) / 100
    },
    {
      key: 'elem',
      label: 'Element',
      val: calculationState.elemEnhVal,
      mult: elementCounter + calculationState.elemEnhVal / 100,
      extra: `counter ${elementCounter}`
    },
    {
      key: 'size',
      label: 'Size',
      val: calculationState.sizeEnhVal,
      mult: sizeModifier + calculationState.sizeEnhVal / 100,
      extra: `mod ${sizeModifier}`
    },
    {
      key: 'race',
      label: 'Race',
      val: calculationState.raceVal,
      mult: 1 + calculationState.raceVal / 100,
      show: includeRace
    },
    {
      key: 'attr',
      label: 'Attribute',
      val: calculationState.attrVal,
      mult: 1 + calculationState.attrVal / 100,
      show: includeAttr
    },
    {
      key: 'extra',
      label: 'Extra#1',
      val: calculationState.blueGroup3Val + calculationState.vesperVal + calculationState.whiteVal + calculationState.dmgStackVal,
      mult: extra1Factor,
      show: includeExtra
    },
    {
      key: 'extraTwo',
      label: 'Extra#2',
      val: calculationState.blueGroup8Val,
      mult: extra2Factor,
      show: includeExtraTwo
    }
  ];

  renderMultiplierBreakdown(calculationState, factorList, elementCounter, sizeModifier, isPenMode);
  generateRecommendationTable(calculationState);

  // Enable test buttons after successful calculation - batch DOM updates
  try {
    const buttons = [DOM_ELEMENTS.testReaper, DOM_ELEMENTS.testSpear, DOM_ELEMENTS.resetRek, DOM_ELEMENTS.resetAll];
    buttons.forEach(btn => { if (btn) btn.disabled = false; });
    DOM_ELEMENTS.submit.disabled = true;
  } catch (e) { console.warn('enable test buttons', e); }

  isResultShown = true;
  lockAllInputs();
}

// ======== BREAKDOWN ========
const createEl = (tag, props = {}, children = []) => {
  const el = document.createElement(tag);
  
  // Set properties efficiently
  Object.entries(props).forEach(([key, value]) => {
    switch (key) {
      case "class": el.className = value; break;
      case "for": el.setAttribute("for", value); break;
      case "text": el.textContent = value; break;
      default: el.setAttribute(key, value);
    }
  });
  
  // Append children efficiently
  const childArray = Array.isArray(children) ? children : [children];
  const fragment = document.createDocumentFragment();
  
  childArray.forEach(child => {
    if (child) {
      fragment.appendChild(typeof child === "string" ? document.createTextNode(child) : child);
    }
  });
  
  el.appendChild(fragment);
  return el;
};
const getDOMCache = () => ({
  targetDefense: DOM_ELEMENTS.tDef,
  targetSize: DOM_ELEMENTS.tSize,
  targetRace: DOM_ELEMENTS.tRace,
  targetAttribute: DOM_ELEMENTS.tAttr,
  weaponElement: DOM_ELEMENTS.wElem,
  weapon: DOM_ELEMENTS.weapon,
  vesperSet: DOM_ELEMENTS.vesperSet,
  blueSet: DOM_ELEMENTS.blueSet,
  whiteSet: DOM_ELEMENTS.whiteSet,
  penetration: DOM_ELEMENTS.pen,
  critical: DOM_ELEMENTS.crit
});
function renderMultiplierBreakdown(calculationState, damageFactorList, elementalCounter, weaponSizeModifier, isPenetrationMode) {
  const resultContainer = DOM_ELEMENTS.hasil;
  const showFullPrecision = resultContainer?.dataset?.showFullPrecision === "1";
  const domCache = getDOMCache();

  // Format numbers based on precision setting
  const formatValue = num => showFullPrecision ? Number(num) || 0 : Math.trunc((Number(num) || 0) * 100) / 100;

  // Get authoritative extra damage groups safely
  const getExtraGroups = () => {
    try {
      const groups = calculationState?.parts?.extraGroups || [];
      return {
        extra1: groups.find(g => g.type === 'extra1') || null,
        extra2: groups.find(g => g.type === 'extra2') || null
      };
    } catch (e) {
      return { extra1: null, extra2: null };
    }
  };

  const { extra1: authExtra1, extra2: authExtra2 } = getExtraGroups();

  // Re-lock all numeric inputs after target swap
  const relockAllInputs = () => {
    document.querySelectorAll(".input-wrap").forEach(wrapper => {
      if (wrapper.dataset.tempUnlocked === "1") return;
      
      const input = wrapper.querySelector("select, input");
      if (!input) return;
      
      try {
        bindInputLockGuard(wrapper);
        wrapper.classList.add("locked");
        input.disabled = true;
      } catch (e) {
        // Silent error handling
      }
    });
  };

  // Factory functions for creating factor items
  const factorCreators = {
    main: (factor) => {
      const defenseLabel = domCache.targetDefense.options[domCache.targetDefense.selectedIndex]?.text || "Target";
      const subList = createEl("ul");

      if (isPenetrationMode) {
        const rawPen = calculationState.penVal || 0;
        const targetDef = calculationState.def || 0;
        const basePen = rawPen - targetDef;

        const items = [
          createEl("li", { text: `Raw PEN + Final PEN: ${formatValue(rawPen)}` }),
          createEl("li", { text: `Target DEF: ${formatValue(targetDef)}` })
        ];

        if (basePen >= 150) {
          const effectivePercent = (basePen * 2) - 150;
          items.push(
            createEl("li", { text: `1.00 + ((( ${formatValue(rawPen)} - ${formatValue(targetDef)} ) × 2 ) - 150 ) / 100` }),
            createEl("li", {}, [`1.00 + ( ${formatValue(effectivePercent)} / 100 ) → `, createEl("code", { text: `×${formatValue(factor.mult)}` })])
          );
        } else {
          items.push(createEl("li", {}, [
            `1.00 + (( ${formatValue(rawPen)} - ${formatValue(targetDef)} ) / 100 ) → `,
            createEl("code", { text: `×${formatValue(factor.mult)}` })
          ]));
        }

        items.forEach(item => subList.appendChild(item));
      } else {
        // CRIT mode
        subList.appendChild(createEl("li", { text: `Crit DMG: ${formatValue(factor.val)}` }));
        subList.appendChild(createEl("li", {}, [
          `1.00 + ( ${formatValue(factor.val)} / 100 ) → `,
          createEl("code", { text: `×${formatValue(factor.mult)}` })
        ]));
      }

      return createEl("li", { text: `Attack Type: ${isPenetrationMode ? "PEN" : "CRIT"} vs ${defenseLabel}` }, subList);
    },

    dmg: (factor) => {
      const items = [
        createEl("li", { text: `P/M BO: ${formatValue(factor.val)}` }),
        createEl("li", { text: `Target Reduction: ${formatValue(calculationState.dmgred || 0)}` }),
        createEl("li", {}, [
          `1.00 + (( ${formatValue(factor.val)} - ${formatValue(calculationState.dmgred || 0)} ) / 100 ) → `,
          createEl("code", { text: `×${formatValue(factor.mult)}` })
        ])
      ];

      return createEl("li", { text: "Final P/M Damage Bonus" }, createEl("ul", {}, items));
    },

    elem: (factor) => {
      const items = [
        createEl("li", { text: `Counter: ${formatValue(elementalCounter)}` }),
        createEl("li", { text: `${domCache.weaponElement.value} Enhance: ${formatValue(factor.val)}` }),
        createEl("li", {}, [
          `${formatValue(elementalCounter)} + ${formatValue(factor.val / 100)} → `,
          createEl("code", { text: `×${formatValue(factor.mult)}` })
        ])
      ];

      if (!domCache.targetAttribute.value) {
        items.push(createEl("li", { text: "Tools assume target Neutral if you're not targeting any attribute." }));
      }

      return createEl("li", {
        text: `Element: ${domCache.weaponElement.value || "Neutral"} vs ${domCache.targetAttribute.value || "Neutral"}`
      }, createEl("ul", {}, items));
    },

    size: (factor) => {
      const items = [
        createEl("li", { text: `Modifier: ${formatValue(weaponSizeModifier)}` }),
        createEl("li", { text: `${domCache.targetSize.value} Enhance: ${formatValue(factor.val)}` }),
        createEl("li", {}, [
          `${formatValue(weaponSizeModifier)} + ${formatValue(factor.val / 100)} → `,
          createEl("code", { text: `×${formatValue(factor.mult)}` })
        ])
      ];

      return createEl("li", {
        text: `Size: ${domCache.weapon.value || "Weapon"} vs ${domCache.targetSize.value}`
      }, createEl("ul", {}, items));
    },

    race: (factor) => {
      const raceLabel = domCache.targetRace.options[domCache.targetRace.selectedIndex]?.text || "Target Race";
      const items = [
        createEl("li", { text: `DMG to ${raceLabel}: ${formatValue(factor.val)}` }),
        createEl("li", {}, [
          `1.00 + ( ${formatValue(factor.val)} / 100 ) → `,
          createEl("code", { text: `×${formatValue(factor.mult)}` })
        ])
      ];

      return createEl("li", { text: `Race: ${raceLabel}` }, createEl("ul", {}, items));
    },

    attr: (factor) => {
      const attrLabel = domCache.targetAttribute.options[domCache.targetAttribute.selectedIndex]?.text || "Target Attribute";
      const items = [
        createEl("li", { text: `DMG to ${attrLabel} Attribute: ${formatValue(factor.val)}` }),
        createEl("li", {}, [
          `1.00 + ( ${formatValue(factor.val)} / 100 ) → `,
          createEl("code", { text: `×${formatValue(factor.mult)}` })
        ])
      ];

      return createEl("li", { text: `Attribute: ${attrLabel}` }, createEl("ul", {}, items));
    },

    extra: (factor) => {
      const subList = createEl("ul");
      
      const extraValues = {
        blueGroup3: Number(calculationState.blueGroup3Val) || 0,
        vesperValue: Number(calculationState.vesperVal) || 0,
        whiteValue: Number(calculationState.whiteVal) || 0,
        damageStack: Number(calculationState.dmgStackVal) || 0
      };
      
      const rawParts = [];
      
      // Add damage components
      const components = [
        { value: extraValues.vesperValue, label: "Vesper SET", select: domCache.vesperSet },
        { value: extraValues.blueGroup3, label: "Blue SET (Ferocity)", select: domCache.blueSet },
        { value: extraValues.whiteValue, label: "White SET (110*3)", select: domCache.whiteSet },
        { value: extraValues.damageStack, label: "Final DMG BNS", format: true }
      ];

      components.forEach(({ value, label, select, format }) => {
        if (value > 0) {
          if (select) {
            subList.appendChild(createEl("li", { text: `${label}: ${select.options[select.selectedIndex].text}` }));
          } else {
            subList.appendChild(createEl("li", { text: `${label}: ${formatValue(value)}` }));
          }
          subList.appendChild(createEl("li", { text: `${formatValue(value)} / 100` }));
          rawParts.push(value / 100);
        }
      });
      
      // Add reaper scythe bonus if active
      if (typeof isTestReaperActive !== "undefined" && isTestReaperActive) {
        const elemMatch = (domCache.weaponElement.value && domCache.targetAttribute.value && 
                          domCache.weaponElement.value === domCache.targetAttribute.value) ||
                         (domCache.weaponElement.value === "Neutral" && !domCache.targetAttribute.value);
        const reaperPercent = elemMatch ? 42 : 14;
        
        subList.appendChild(createEl("li", { text: `Reaper Scythe: ${domCache.weaponElement.value || "?"} vs ${domCache.targetAttribute.value || "Neutral"}` }));
        subList.appendChild(createEl("li", { text: `${formatValue(reaperPercent)} / 100` }));
        subList.appendChild(createEl("li", {
          class: "note",
          text: elemMatch ? 
            "Elements match. Real bonus is 84% (10s duration / 20s CD), displayed here as(sume) 42% for 100% uptime." :
            "Elements differ. Real bonus is 28% (10s duration / 20s CD), displayed here as(sume) 14% for 100% uptime."
        }));
        rawParts.push(reaperPercent / 100);
      }
      
      // Calculate total and display
      const totalBonus = rawParts.reduce((acc, val) => acc + val, 0);
      const bonusStr = rawParts.map(formatValue).join(" + ");
      
      if (authExtra1) {
        try {
          const authSum = Number(authExtra1.sum) || 0;
          const displayStr = (Array.isArray(authExtra1.items) && authExtra1.items.length) ?
            authExtra1.items.map(item => formatValue(item.val || item.value || item)).join(" + ") :
            formatValue(authSum);
          subList.appendChild(createEl("li", {}, [`1 + ${displayStr} → `, createEl("code", { text: `×${formatValue(1 + authSum)}` })]));
        } catch (e) {
          subList.appendChild(createEl("li", {}, [`1 + ${bonusStr} → `, createEl("code", { text: `×${formatValue(1 + totalBonus)}` })]));
        }
      } else if (rawParts.length > 0) {
        subList.appendChild(createEl("li", {}, [`1 + ${bonusStr} → `, createEl("code", { text: `×${formatValue(1 + totalBonus)}` })]));
      } else {
        subList.appendChild(createEl("li", { text: "× 1.00 (no stat)" }));
      }
      
      return createEl("li", { text: "Extra#1: Final DMG Bonus" }, subList);
    },

    extraTwo: (factor) => {
      const subList = createEl("ul");
      const blueGroup8 = Number(calculationState.blueGroup8Val) || 0;
      const rawParts = [];
      
      if (blueGroup8 > 0) {
        subList.appendChild(createEl("li", { text: `Blue SET: ${domCache.blueSet.options[domCache.blueSet.selectedIndex].text}` }));
        subList.appendChild(createEl("li", { text: `${formatValue(blueGroup8)} / 100` }));
        rawParts.push(blueGroup8 / 100);
      }
      
      if (typeof isTestSpearActive !== "undefined" && isTestSpearActive) {
        subList.appendChild(createEl("li", { text: "Divinity#1 Flash: Spear of Eternity" }));
        subList.appendChild(createEl("li", { text: "42 / 100" }));
        subList.appendChild(createEl("li", {
          class: "note",
          text: "This bonus is shown as(sume) 100% uptime (actual bonus is 84%)."
        }));
        rawParts.push(0.42);
      }
      
      const totalBonus = rawParts.reduce((acc, val) => acc + val, 0);
      const bonusStr = rawParts.map(formatValue).join(" + ");
      
      if (authExtra2) {
        try {
          const authSum = Number(authExtra2.sum) || 0;
          const displayStr = (Array.isArray(authExtra2.items) && authExtra2.items.length) ?
            authExtra2.items.map(item => formatValue(item.val || item.value || item)).join(" + ") :
            formatValue(authSum);
          subList.appendChild(createEl("li", {}, [`1 + ${displayStr} → `, createEl("code", { text: `×${formatValue(1 + authSum)}` })]));
        } catch (e) {
          subList.appendChild(createEl("li", {}, [`1 + ${bonusStr} → `, createEl("code", { text: `×${formatValue(1 + totalBonus)}` })]));
        }
      } else if (rawParts.length > 0) {
        subList.appendChild(createEl("li", {}, [`1 + ${bonusStr} → `, createEl("code", { text: `×${formatValue(1 + totalBonus)}` })]));
      } else {
        subList.appendChild(createEl("li", { text: "× 1.00 (no stat)" }));
      }
      
      return createEl("li", { text: "Extra#2: Bonus DMG to MVP/MINI" }, subList);
    }
  };

  // Create factor item using factory
  const createFactorItem = (factor) => {
    if (factor.show === false) {
      return createEl("li", { text: `${factor.label}: ×1.00 (no stat)` });
    }

    const creator = factorCreators[factor.key];
    return creator ? creator(factor) : createEl("li", {}, [
      `${factor.label}: ${formatValue(factor.val)} → `,
      createEl("code", { text: `×${formatValue(factor.mult)}` })
    ]);
  };

  // Create precision toggle button
  const createPrecisionToggle = () => {
    const btn = createEl("button", {
      type: "button",
      class: "toggle-precision",
      text: showFullPrecision ? "Beautify!" : "Want to see?"
    });

    btn.addEventListener("click", (e) => {
      e.preventDefault();
      if (!resultContainer?.dataset) return;
      
      resultContainer.dataset.showFullPrecision = 
        resultContainer.dataset.showFullPrecision === "1" ? "0" : "1";
      processMainCalculation();
      showSnackbar(resultContainer.dataset.showFullPrecision === "1"
        ? "Precise numbers displayed"
        : "Rounded numbers displayed"
      );
    });

    return btn;
  };

  // Create target swap functionality
  const createTargetSwap = () => {
    const swapOptions = [
      { key: "0def", label: "Dummy (0 DEF)" },
      { key: "130boss", label: "Avg. 130 BOSS" },
      { key: "140boss", label: "Avg. 140 BOSS" },
      { key: "150boss", label: "Avg. 150 BOSS" }
    ];

    const presetKeys = new Set(["0def", "130boss", "140boss", "150boss"]);
    
    // Add other defense keys
    Object.keys(DEFENSE_TABLE).forEach(key => {
      if (!presetKeys.has(key)) {
        swapOptions.push({ key, label: key });
      }
    });

    const select = createEl("select", { id: "breakdown-swap", class: "breakdown-swap" });
    
    // Create options efficiently
    const fragment = document.createDocumentFragment();
    swapOptions.forEach(({ key, label }) => {
      const targetData = getTargetDefenseData(key);
      const def = Number(targetData.def || 0);
      const dmgred = Number(targetData.dmgred || 0);
      
      const option = createEl("option", { value: key, text: label });
      
      // Check if stats are insufficient
      const attackType = calculationState.atkType.toLowerCase();
      const pen = Number(domCache.penetration?.value || 0);
      const dmg = Number(DOM_ELEMENTS.dmg?.value || 0);
      const insufficient = attackType === "pen" 
        ? (pen <= def || dmg <= dmgred)
        : (dmg <= dmgred);

      if (insufficient) {
        option.disabled = true;
        option.textContent += " (stats not enough)";
      }
      
      fragment.appendChild(option);
    });

    select.appendChild(fragment);
    select.value = domCache.targetDefense.value || "0def";

    // Add event listener for swap functionality
    select.addEventListener("change", () => handleTargetSwap(select, presetKeys, domCache));

    return { select, presetKeys };
  };

  // Handle target swap logic (extracted for clarity)
  const handleTargetSwap = (swapSelect, presetKeys, domCache) => {
    const prevKey = domCache.targetDefense.value;
    const currKey = swapSelect.value;
    const prevData = DEFENSE_TABLE[prevKey] || {};
    const currData = DEFENSE_TABLE[currKey] || {};
    const isPreset = key => presetKeys.has(key);

    domCache.targetDefense.value = currKey;

    // Check if mob characteristics are the same
    const sameMobFactors = currData.sizeMob === prevData.sizeMob &&
      currData.raceMob === prevData.raceMob &&
      currData.attributeMob === prevData.attributeMob;

    // Simple swap conditions
    const isSimpleSwap = (isPreset(prevKey) && isPreset(currKey)) ||
      (!isPreset(prevKey) && isPreset(currKey)) ||
      (!isPreset(prevKey) && !isPreset(currKey) && 
       (prevKey.replace(/\d+$/, "") === currKey.replace(/\d+$/, "") || sameMobFactors));

    if (isSimpleSwap) {
      // Handle simple swap
      if (!isPreset(prevKey) && isPreset(currKey)) {
        // Clear race and attribute when switching from specific to preset
        [domCache.targetRace, domCache.targetAttribute].forEach((el, idx) => {
          if (el) {
            el.value = "";
            try {
              el.dispatchEvent(new Event("input", { bubbles: true }));
              el.dispatchEvent(new Event("change", { bubbles: true }));
            } catch (e) {}
          }
          const fieldEl = DOM_ELEMENTS[idx === 0 ? "race" : "attr"];
          if (fieldEl) {
            fieldEl.value = "";
            try {
              fieldEl.dispatchEvent(new Event("input", { bubbles: true }));
              fieldEl.dispatchEvent(new Event("change", { bubbles: true }));
            } catch (e) {}
          }
        });
        updateDynamicFieldLabels();
      }

      relockAllInputs();
      resultContainer.dataset.specificMode = "0";
      isTestReaperActive = false;
      isTestSpearActive = false;isFlashActive = false;
      processMainCalculation();
      showSnackbar('Swap to same type mob, auto calc!');
      
      return;
    }

    // Complex swap - handle specific target logic
    domCache.targetSize.value = currData.sizeMob || "";
    domCache.targetRace.value = currData.raceMob || "";
    domCache.targetAttribute.value = currData.attributeMob || "";
    updateDynamicFieldLabels();

    // Determine fields to unlock
    const attackType = calculationState.atkType.toLowerCase();
    const fieldsToUnlock = ["dmg", "dmgStack"];
    
    if (attackType === "pen") fieldsToUnlock.push("pen");
    if (attackType === "crit") fieldsToUnlock.push("crit");
    if (domCache.targetSize.value) fieldsToUnlock.push("sizeEnh");
    if (domCache.targetRace.value) fieldsToUnlock.push("race");
    if (domCache.targetAttribute.value) fieldsToUnlock.push("attr");
    if (domCache.weaponElement.value) fieldsToUnlock.push("elemEnh");

    const unlockedInputs = [];
    
    // Unlock required fields
    fieldsToUnlock.forEach(fieldId => {
      const field = DOM_ELEMENTS[fieldId];
      if (!field) return;
      
      const wrapper = field.closest(".input-wrap");
      if (wrapper) {
        try { 
          unbindInputLockGuard(wrapper); 
        } catch (e) {}
        wrapper.classList.remove("locked");
        wrapper.dataset.tempUnlocked = "1";
      }
      
      field.disabled = false;
      unlockedInputs.push({ fieldId, element: field, wrapper });
    });

    // Enable submit, disable others
    if (DOM_ELEMENTS.submit) DOM_ELEMENTS.submit.disabled = false;
    
    Object.keys(DOM_ELEMENTS).forEach(key => {
      const el = DOM_ELEMENTS[key];
      if (key !== 'submit' && el && typeof el.disabled !== 'undefined') {
        el.disabled = true;
      }
    });
    
    // Disable test buttons
    if (DOM_ELEMENTS.testSpear) DOM_ELEMENTS.testSpear.disabled = true;
    if (DOM_ELEMENTS.testReaper) DOM_ELEMENTS.testReaper.disabled = true;
    
    // Keep unlocked inputs enabled
    unlockedInputs.forEach(({ element }) => {
      element.disabled = false;
    });

    // Validation and relock function
    const validateAndRelock = () => {
      let allValid = true;
      
      unlockedInputs.forEach(({ fieldId, element }) => {
        const shouldSkip = (fieldId === "sizeEnh" && !domCache.targetSize.value) ||
          (fieldId === "race" && !domCache.targetRace.value) ||
          (fieldId === "attr" && !domCache.targetAttribute.value) ||
          (fieldId === "elemEnh" && !domCache.weaponElement.value);
        
        if (shouldSkip) return;

        const val = Number(element.value);
        const min = Number(element.getAttribute("min")) || 0;
        if (!(element.value && !isNaN(val) && val >= min)) {
          allValid = false;
        }
      });

      if (!allValid) return;

      try {
        if (!validateRequiredFields()) return;
      } catch (e) { 
        return; 
      }

      // Relock inputs
      unlockedInputs.forEach(({ element, wrapper }) => {
        if (wrapper) {
          wrapper.removeAttribute("data-temp-unlocked");
          wrapper.classList.add("locked");
          try { 
            bindInputLockGuard(wrapper); 
          } catch (e) {}
        }
        element.disabled = true;
        element.removeEventListener("blur", validateAndRelock);
      });

      // Re-enable all elements
      Object.keys(DOM_ELEMENTS).forEach(key => {
        const el = DOM_ELEMENTS[key];
        if (key !== 'submit' && el && typeof el.disabled !== 'undefined') {
          el.disabled = false;
        }
      });
      
      if (DOM_ELEMENTS.testSpear) DOM_ELEMENTS.testSpear.disabled = false;
      if (DOM_ELEMENTS.testReaper) DOM_ELEMENTS.testReaper.disabled = false;

      resultContainer.dataset.specificMode = "0";
      DOM_ELEMENTS.hasil.textContent = 'Input your stats to see the result...';
      DOM_ELEMENTS.rec.textContent = 'Balancing stat recommendations for a higher output multiplier.';

      showSnackbar('Please click Submit button to calculate with new target!');
    };

    // Handle field changes and focus
    const fieldChanges = [
      { changed: currData.sizeMob !== prevData.sizeMob, fieldId: "sizeEnh" },
      { changed: currData.raceMob !== prevData.raceMob, fieldId: "race" },
      { changed: currData.attributeMob !== prevData.attributeMob, fieldId: "attr" }
    ];

    let focusTarget = null;
    fieldChanges.forEach(({ changed, fieldId }) => {
      if (!changed) return;
      
      const field = DOM_ELEMENTS[fieldId];
      if (field) {
        field.value = "";
        try {
          field.dispatchEvent(new Event("input", { bubbles: true }));
          field.dispatchEvent(new Event("change", { bubbles: true }));
        } catch (e) {}
        if (!focusTarget) focusTarget = field;
      }
    });

    // Find first empty field to focus
    const firstEmpty = unlockedInputs.find(({ element }) => !element.value);
    const targetFocus = focusTarget || firstEmpty?.element || unlockedInputs[0]?.element;
    
    DOM_ELEMENTS.hasil.textContent = 'Input your stats to see the result...';
    DOM_ELEMENTS.rec.textContent = 'Balancing stat recommendations for a higher output multiplier.';

    if (targetFocus) {
      scrollAndFocusElement(targetFocus, "Target Swapped, refill and calc again!");
    }
  };

  // Build main breakdown content
  const buildBreakdown = () => {
    const precisionBtn = createPrecisionToggle();
    const { select: swapSelect } = createTargetSwap();

    // Create factor breakdown list
    const factorList = createEl("ul", { class: "factor-breakdown" });
    const fragment = document.createDocumentFragment();
    
    damageFactorList.forEach(factor => {
      fragment.appendChild(createFactorItem(factor));
    });
    
    factorList.appendChild(fragment);

    // Create multiplier display
    const multiplierParts = damageFactorList.map(factor => 
      factor.show === false ? 
        "× 1.00 (no " + factor.label.toLowerCase() + ")" :
        "× " + formatValue(factor.mult)
    );

    const targetInfo = [
      domCache.targetSize.value,
      domCache.targetRace.value,
      domCache.targetAttribute.value
    ].filter(Boolean).join(" + ");

    const defenseText = domCache.targetDefense.options[domCache.targetDefense.selectedIndex]?.text || "";

    // Build main content
    const content = [
      createEl("blockquote", { class: "noted" }, [
        "By default, every factor starts at ×1.00. Numbers show how it changes with your stats.",
        createEl("br"), createEl("br"),
        "Values shown to two decimal places for readability. The final result is computed with full precision(",
        precisionBtn,
        "), so it may differ slightly if you recompute using the displayed (rounded) numbers."
      ]),
      factorList,
      createEl("hr", { class: "separ" }),
      createEl("div", { id: "swap-wrapper", class: "breakdown-swap-wrapper" }, [
        createEl("label", { for: "breakdown-swap", id: "swap-label", text: "Swap Target:" }),
        swapSelect
      ]),
      createEl("p", {}, [
        "Your multiplier to ",
        createEl("i", {}, [`${targetInfo} (${defenseText})`]),
        ":"
      ]),
      createEl("blockquote", { class: "noted" }, [
        `1.00 ${multiplierParts.join(" ")} = `,
        createEl("code", { text: `×${formatValue(calculationState.mult)}` }),
        createEl("br"), createEl("br"),
        "Only base multipliers! Real output depends on class, skills, buffs (vesper, blue and white stack), and more. More accurate? Just use ",createEl("a",{class:"job-sim", target:"_blank", href: "//discord.com/channels/784407151342256148/909016309218541568/1407521807459811328", text: "job sim!"}),
        createEl("br"), createEl("br"),
        "Avg 130, Necro, Ogre, Ktul defs less accurate than others!",
        createEl("br"), createEl("br"),
        "In the table, an upward arrow means higher than your stat, a square means roughly equal (±3%), and a downward means lower."
      ])
    ];

    const container = createEl("div", { id: "multiplier-breakdown", class: "multiplier-breakdown" });
    const mainFragment = document.createDocumentFragment();
    
    content.forEach(element => mainFragment.appendChild(element));
    container.appendChild(mainFragment);

    return { container, swapSelect };
  };

  // Setup event bindings
  const setupEventBindings = (swapSelect) => {
    // Bind main target select to swap select (prevent duplicate listeners)
    if (!domCache.targetDefense.dataset.swapBound) {
      domCache.targetDefense.addEventListener("change", () => {
        swapSelect.value = domCache.targetDefense.value;
      });
      domCache.targetDefense.dataset.swapBound = "1";
    }

    // Update attack type input states
    const attackType = calculationState.atkType.toLowerCase();
    if (domCache.penetration && domCache.critical) {
      if (attackType === "pen") {
        domCache.penetration.disabled = false;
        domCache.critical.disabled = true;
      } else {
        domCache.penetration.disabled = true;
        domCache.critical.disabled = false;
      }
    }
  };
  const { container, swapSelect } = buildBreakdown();
  setupEventBindings(swapSelect);
  resultContainer.innerHTML = "";
  resultContainer.appendChild(container);
}

// ======== TABLE ========
const RECOMMENDATION_CONFIG = {
  randomMode: 'clamp', 
  maxAttempts: 200,
  centerScale: 0.25, // rand around stats 
  jitter: 0.15, // keep closest 
  jitterStep: 0.08, // scaling jitter
  jitterStepEvery: 40, // every 40 attempt 
  jitterMax: 0.5, // stop scaling now
  clampMaxFraction: 0.6, // more closest to center
  clampMaxAbsolute: 0.3, // and more
  upDownThreshold: 3, // Â±3 assume nochange
  raceAttrCap: 420, // race attr total cap = max ea + any
  raceAttrSoloCap: 330, // 3 slot ea10(270) + any
  raceAttrTol: 8, // tolerance for cap
  smallThreshold: 140, // if user race and/or attr < 2slot ea8 = small
  smallMin: 90, // new base for user (1slot ea10)
  smallExp: 0.6, 
  ratioMin: 0.4, // min ratio share
  ratioMax: 0.7, // max ratio
  ratioNoise: 0.08, // with noise 
  bias: { // weights share
    main: 1,
    dmg: 0.8,
    elem: 0.8,
    size: 0.8,
    race: 0.8,
    attr: 0.8
  },
  cats: [ // normal cats
    { label: '0-8%', min: 1.00, max: 1.08 },
    { label: '10-20%', min: 1.10, max: 1.20 },
    { label: '20-30%', min: 1.20, max: 1.30 },
    { label: '50-100%', min: 1.50, max: 2.00 }
  ],
  forSmallCats: [ // cats for lack race&attr
    { label: '50-100%', min: 1.50, max: 2.00 },
    { label: '100-200%', min: 2.00, max: 3.00 },
    { label: '200-300%', min: 3.00, max: 4.00 },
    { label: '300-400%', min: 4.00, max: 5.00 }
  ]
};
function calculateRecommendationWeights({ includeRace, includeAttr, baseMain, baseDmg, baseElem, baseSize, baseRace, baseAttr }) {
  const biasConfig = RECOMMENDATION_CONFIG.bias;
  const rawStatWeights = [
    safeNumber(baseMain) * biasConfig.main,
    safeNumber(baseDmg) * biasConfig.dmg,
    safeNumber(baseElem) * biasConfig.elem,
    safeNumber(baseSize) * biasConfig.size
  ];

  const maxRawWeight = Math.max(...rawStatWeights, 1);
  const normalizedStatWeights = rawStatWeights.map(weightValue => weightValue / maxRawWeight);
  const coreStatSum = normalizedStatWeights.reduce((accumulator, currentWeight) => accumulator + currentWeight, 0) || 1;
  const coreStatShare = (includeRace || includeAttr) ? 0.8 : 1.0;
  const additionalStatShare = 1 - coreStatShare;

  let finalWeights = {
    main: normalizedStatWeights[0] / coreStatSum * coreStatShare,
    dmg: normalizedStatWeights[1] / coreStatSum * coreStatShare,
    elem: normalizedStatWeights[2] / coreStatSum * coreStatShare,
    size: normalizedStatWeights[3] / coreStatSum * coreStatShare,
    race: 0,
    attr: 0
  };

  const effectiveRaceValue = includeRace ? Math.max(Math.pow(baseRace, RECOMMENDATION_CONFIG.smallExp), RECOMMENDATION_CONFIG.smallMin) : 0;
  const effectiveAttrValue = includeAttr ? Math.max(Math.pow(baseAttr, RECOMMENDATION_CONFIG.smallExp), RECOMMENDATION_CONFIG.smallMin) : 0;

  const raceIsAvailable = includeRace && effectiveRaceValue > 0 && effectiveRaceValue < RECOMMENDATION_CONFIG.raceAttrCap;
  const attrIsAvailable = includeAttr && effectiveAttrValue > 0 && effectiveAttrValue < RECOMMENDATION_CONFIG.raceAttrCap;

  if (raceIsAvailable && attrIsAvailable) {
    const combinedRaceAttrSum = safeNumber(effectiveRaceValue) + safeNumber(effectiveAttrValue);
    if (combinedRaceAttrSum > 0) {
      finalWeights.race = (safeNumber(effectiveRaceValue) / combinedRaceAttrSum) * additionalStatShare;
      finalWeights.attr = (safeNumber(effectiveAttrValue) / combinedRaceAttrSum) * additionalStatShare;
    } else {
      finalWeights.race = additionalStatShare / 2;
      finalWeights.attr = additionalStatShare / 2;
    }
  } else if (raceIsAvailable) {
    finalWeights.race = additionalStatShare;
  } else if (attrIsAvailable) {
    finalWeights.attr = additionalStatShare;
  } else if (includeRace || includeAttr) {
    const coreStatKeys = ["main", "dmg", "elem", "size"];
    normalizedStatWeights.forEach((weightValue, statIndex) => {
      finalWeights[coreStatKeys[statIndex]] += (weightValue / coreStatSum) * additionalStatShare;
    });
  }

  const totalWeightSum = Object.values(finalWeights).reduce((accumulator, currentWeight) => accumulator + currentWeight, 0) || 1;
  Object.keys(finalWeights).forEach(weightKey => { finalWeights[weightKey] /= totalWeightSum; });
  return finalWeights;
}
function applySmallValueAdjustment(inputValue, baseRace, baseAttr) {
  const combinedRaceAttrTotal = baseRace + baseAttr;
  if (combinedRaceAttrTotal > 0 && combinedRaceAttrTotal < RECOMMENDATION_CONFIG.smallThreshold) {
    // Enhance small values for better recommendations
    return Math.max(Math.pow(inputValue, RECOMMENDATION_CONFIG.smallExp), RECOMMENDATION_CONFIG.smallMin);
  }
  return inputValue;
}
function generateRandomValue(baseStatValue, jitterAmount = RECOMMENDATION_CONFIG.jitter) {
  const numericBaseValue = Number(baseStatValue) || 0;
  const randomizationMode = RECOMMENDATION_CONFIG.randomMode;
  
  if (randomizationMode === "clamp") {
    const randomDelta = (Math.random() * 2 - 1) * jitterAmount;
    const maxClampValue = Math.min(RECOMMENDATION_CONFIG.clampMaxFraction * jitterAmount, RECOMMENDATION_CONFIG.clampMaxAbsolute);
    const clampedDelta = Math.max(Math.min(randomDelta, maxClampValue), -maxClampValue);
    return Math.max(0, numericBaseValue * (1 + clampedDelta));
  }
  
  if (randomizationMode === "normal") {
    let uniformRandom1 = 0, uniformRandom2 = 0;
    while (uniformRandom1 === 0) uniformRandom1 = Math.random();
    while (uniformRandom2 === 0) uniformRandom2 = Math.random();
    const normalDistValue = Math.sqrt(-2.0 * Math.log(uniformRandom1)) * Math.cos(2.0 * Math.PI * uniformRandom2);
    return Math.max(0, numericBaseValue * (1 + normalDistValue * jitterAmount * 0.5));
  }
  
  const simpleDelta = (Math.random() * 2 - 1) * jitterAmount;
  return Math.max(0, numericBaseValue * (1 + simpleDelta));
}
function getMaxAllowedValue(userStatValue, capLimit, toleranceValue, isSmallUser) {
  return userStatValue >= capLimit ? (isSmallUser ? capLimit + toleranceValue : userStatValue + toleranceValue) : capLimit;
}
function avoidCapLimit(inputValue, capLimit) {
  // Avoid rendering exactly at cap value
  if (inputValue < capLimit) return inputValue;
  const randomOffset = capLimit * (0.01 + Math.random() * 0.02);
  return capLimit - randomOffset;
}
function createFactorCell(currentValue, originalBaseValue) {
  const roundedCurrent = Math.round(currentValue);
  const roundedBase = Math.round(originalBaseValue);
  let cellClassName = 'neutral';
  
  if (roundedCurrent >= roundedBase + RECOMMENDATION_CONFIG.upDownThreshold) {
    cellClassName = 'up';
  } else if (roundedCurrent <= roundedBase - RECOMMENDATION_CONFIG.upDownThreshold) {
    cellClassName = 'down';
  }
  
  const valueSpan = document.createElement('span');
  valueSpan.className = cellClassName;
  valueSpan.textContent = roundedCurrent;
  
  const tableCell = document.createElement('td');
  tableCell.appendChild(valueSpan);
  return tableCell;
}
function generateRecommendationTable(gameState) {
  const originalMultiplier = gameState.mult;
  const recommendationContainer = DOM_ELEMENTS.rec;
  recommendationContainer.innerHTML = '';
  
  const shouldIncludeRace = !!DOM_ELEMENTS.tRace.value && (Number(gameState.raceVal) || 0) > 0;
  const shouldIncludeAttr = !!DOM_ELEMENTS.tAttr.value && (Number(gameState.attrVal) || 0) > 0;
  const isPenetrationMode = gameState.atkType === 'pen';

  const userMainStat = isPenetrationMode ? gameState.penVal : gameState.critVal;
  const userDmgStat = gameState.dmgVal || 0;
  const userSizeStat = gameState.sizeEnhVal || 0;
  const userElemStat = gameState.elemEnhVal || 0;
  const userAttrStat = shouldIncludeAttr ? (gameState.attrVal || 0) : 0;
  const userRaceStat = shouldIncludeRace ? (gameState.raceVal || 0) : 0;

  
  const statWeights = calculateRecommendationWeights({
    includeRace: shouldIncludeRace, 
    includeAttr: shouldIncludeAttr, 
    baseMain: userMainStat, 
    baseDmg: userDmgStat, 
    baseElem: userElemStat, 
    baseSize: userSizeStat, 
    baseRace: userRaceStat, 
    baseAttr: userAttrStat
  });
  
  const centeringScale = RECOMMENDATION_CONFIG.centerScale;
  const calculateCenteredValue = (baseStatValue, weightValue) => safeNumber(baseStatValue) * (1 + weightValue * centeringScale);

  const centeredMainValue = calculateCenteredValue(userMainStat, statWeights.main);
  const centeredDmgValue = calculateCenteredValue(userDmgStat, statWeights.dmg);
  const centeredElemValue = calculateCenteredValue(userElemStat, statWeights.elem);
  const centeredSizeValue = calculateCenteredValue(userSizeStat, statWeights.size);

  const adjustedAttrValue = shouldIncludeAttr ? applySmallValueAdjustment(userAttrStat, userRaceStat, userAttrStat) : 0;
  const adjustedRaceValue = shouldIncludeRace ? applySmallValueAdjustment(userRaceStat, userRaceStat, userAttrStat) : 0;

  const centeredAttrValue = shouldIncludeAttr ? Math.min(calculateCenteredValue(adjustedAttrValue, statWeights.attr), RECOMMENDATION_CONFIG.raceAttrCap) : 0;
  const centeredRaceValue = shouldIncludeRace ? Math.min(calculateCenteredValue(adjustedRaceValue, statWeights.race), RECOMMENDATION_CONFIG.raceAttrCap) : 0;

  const calculateRaceAttrValues = (currentJitter) => {
    let generatedRaceValue = 0, generatedAttrValue = 0;

    if (shouldIncludeAttr && shouldIncludeRace) {
      const userCombinedTotal = userRaceStat + userAttrStat;
      const boostedCombinedTotal = adjustedRaceValue + adjustedAttrValue;
      const isSmallCombined = userCombinedTotal > 0 && userCombinedTotal < RECOMMENDATION_CONFIG.smallThreshold;
      const maxAllowedTotal = getMaxAllowedValue(userCombinedTotal, RECOMMENDATION_CONFIG.raceAttrCap, RECOMMENDATION_CONFIG.raceAttrTol, isSmallCombined);

      const randomizedTotal = avoidCapLimit(Math.min(generateRandomValue(boostedCombinedTotal, currentJitter), maxAllowedTotal), maxAllowedTotal);
      const distributionRatio = RECOMMENDATION_CONFIG.ratioMin + Math.random() * (RECOMMENDATION_CONFIG.ratioMax - RECOMMENDATION_CONFIG.ratioMin);

      [generatedRaceValue, generatedAttrValue] = [randomizedTotal * distributionRatio, randomizedTotal * (1 - distributionRatio)];
      const actualSum = generatedRaceValue + generatedAttrValue;
      
      if (actualSum > maxAllowedTotal) {
        const scalingFactor = avoidCapLimit(maxAllowedTotal, maxAllowedTotal) / actualSum;
        generatedRaceValue *= scalingFactor;
        generatedAttrValue *= scalingFactor;
      }
    } else if (shouldIncludeRace || shouldIncludeAttr) {
      const userSingleTotal = shouldIncludeRace ? userRaceStat : userAttrStat;
      const boostedSingleTotal = shouldIncludeRace ? adjustedRaceValue : adjustedAttrValue;
      const isSmallSingle = userSingleTotal > 0 && userSingleTotal < RECOMMENDATION_CONFIG.smallThreshold;
      const maxSingleValue = getMaxAllowedValue(userSingleTotal, RECOMMENDATION_CONFIG.raceAttrSoloCap, RECOMMENDATION_CONFIG.raceAttrTol, isSmallSingle);

      if (shouldIncludeRace) {
        generatedRaceValue = avoidCapLimit(Math.min(generateRandomValue(boostedSingleTotal, currentJitter), maxSingleValue), maxSingleValue);
      } else {
        generatedAttrValue = avoidCapLimit(Math.min(generateRandomValue(boostedSingleTotal, currentJitter), maxSingleValue), maxSingleValue);
      }
    }

    return { raceValue: generatedRaceValue, attrValue: generatedAttrValue };
  };

  const generateRecommendationRow = (currentJitter) => {
    let penValue = gameState.penVal, critValue = gameState.critVal;
    
    if (isPenetrationMode) {
      penValue = generateRandomValue(centeredMainValue, currentJitter);
    } else {
      critValue = generateRandomValue(centeredMainValue, currentJitter);
    }

    const dmgValue = generateRandomValue(centeredDmgValue, currentJitter);
    const elemValue = generateRandomValue(centeredElemValue, currentJitter);
    const sizeValue = generateRandomValue(centeredSizeValue, currentJitter);
    const { raceValue: raceValue, attrValue: attrValue } = calculateRaceAttrValues(currentJitter);

    const extraStats = {
      blueGroup3Val: gameState.blueGroup3Val || 0,
      blueGroup8Val: gameState.blueGroup8Val || 0,
      vesperVal: gameState.vesperVal || 0,
      whiteVal: gameState.whiteVal || 0,
      dmgStackVal: gameState.dmgStackVal || 0
    };

    const { mult: calculatedMultiplier } = calculateMultiplier({
      atkType: isPenetrationMode ? 'pen' : 'crit',
      penVal: penValue,
      critVal: critValue,
      dmgVal: dmgValue,
      sizeEnhVal: sizeValue,
      elemEnhVal: elemValue,
      raceVal: raceValue,
      attrVal: attrValue,
      weapon: DOM_ELEMENTS.weapon.value,
      tSize: DOM_ELEMENTS.tSize.value,
      wElem: DOM_ELEMENTS.wElem.value,
      tAttr: DOM_ELEMENTS.tAttr.value,
      tRace: DOM_ELEMENTS.tRace.value,
      tDefKey: DOM_ELEMENTS.tDef.value,
      extras: extraStats
    });

    
    // Avoid round tens for better visual variety
    const avoidRoundTen = (inputValue) => (inputValue % 10 === 0 ? inputValue + 1 : inputValue);

    return {
      mainVal: avoidRoundTen(Math.round(isPenetrationMode ? penValue : critValue)),
      dmgVal: avoidRoundTen(Math.round(dmgValue)),
      elemVal: avoidRoundTen(Math.round(elemValue)),
      sizeVal: avoidRoundTen(Math.round(sizeValue)),
      raceVal: shouldIncludeRace ? avoidRoundTen(Math.round(raceValue)) : null,
      attrVal: shouldIncludeAttr ? avoidRoundTen(Math.round(attrValue)) : null,
      newMultiplier: calculatedMultiplier
    };
  };

  const hasSmallCombinedStats = shouldIncludeRace && shouldIncludeAttr &&
    (userRaceStat + userAttrStat > 0 && userRaceStat + userAttrStat < RECOMMENDATION_CONFIG.smallThreshold);

  const currentCategories = hasSmallCombinedStats ? RECOMMENDATION_CONFIG.forSmallCats : RECOMMENDATION_CONFIG.cats;

  for (const categoryConfig of currentCategories) {
    const tableElement = document.createElement('table');
    tableElement.className = 'recommend-table';
    
    const tableCaption = document.createElement('caption');
    tableCaption.textContent = 'Increase ' + categoryConfig.label;
    tableElement.appendChild(tableCaption);

    const headerRow = document.createElement('tr');
    const columnHeaders = ['STAT', isPenetrationMode ? 'PEN' : 'CRIT', 'P/M BO', 'Element', 'Size'];
    if (shouldIncludeRace) columnHeaders.push('Race');
    if (shouldIncludeAttr) columnHeaders.push('Attribute');
    columnHeaders.push('Multiplier', '\u0394');    
    columnHeaders.forEach(headerText => {
      const headerCell = document.createElement('th');
      headerCell.textContent = headerText;
      headerRow.appendChild(headerCell);
    });
    tableElement.appendChild(headerRow);

    const tableBody = document.createElement('tbody');
    const uniqueKeys = new Set();
    const uniqueDeltas = new Set();
    const uniqueValues = { 
      main: new Set(), 
      dmg: new Set(), 
      elem: new Set(), 
      size: new Set(), 
      attr: new Set(), 
      race: new Set() 
    };
    const acceptedRows = [];
    
    let generationAttempts = 0;
    let dynamicJitter = RECOMMENDATION_CONFIG.jitter;

    while (acceptedRows.length < 5 && generationAttempts < RECOMMENDATION_CONFIG.maxAttempts) {
      generationAttempts++;
      
      const candidateRow = generateRecommendationRow(dynamicJitter);
      
      if (candidateRow.newMultiplier <= originalMultiplier) continue;
      
      const multiplierRatio = candidateRow.newMultiplier / Math.max(originalMultiplier, 1e-9);
      if (multiplierRatio < categoryConfig.min || multiplierRatio > categoryConfig.max) continue;

      const rowUniqueKey = [candidateRow.mainVal, candidateRow.dmgVal, candidateRow.elemVal, candidateRow.sizeVal, candidateRow.raceVal || '-', candidateRow.attrVal || '-'].join('|');
      if (uniqueKeys.has(rowUniqueKey)) continue;
      if (uniqueValues.main.has(candidateRow.mainVal)) continue;
      if (uniqueValues.dmg.has(candidateRow.dmgVal)) continue;
      if (uniqueValues.elem.has(candidateRow.elemVal)) continue;
      if (uniqueValues.size.has(candidateRow.sizeVal)) continue;
      if (shouldIncludeAttr && uniqueValues.attr.has(candidateRow.attrVal)) continue;
      if (shouldIncludeRace && uniqueValues.race.has(candidateRow.raceVal)) continue;
      
      if (
        candidateRow.mainVal > userMainStat &&
        candidateRow.dmgVal > userDmgStat &&
        candidateRow.elemVal > userElemStat &&
        candidateRow.sizeVal > userSizeStat &&
        (!shouldIncludeRace || candidateRow.raceVal > userRaceStat) &&
        (!shouldIncludeAttr || candidateRow.attrVal > userAttrStat)
      ) {
        continue;
      }
      
      const deltaPercentage = ((candidateRow.newMultiplier - originalMultiplier) / originalMultiplier) * 100;
      const roundedDeltaKey = Number(deltaPercentage.toFixed(1));
      if (uniqueDeltas.has(roundedDeltaKey)) continue;

      uniqueKeys.add(rowUniqueKey);
      uniqueDeltas.add(roundedDeltaKey);
      uniqueValues.main.add(candidateRow.mainVal);
      uniqueValues.dmg.add(candidateRow.dmgVal);
      uniqueValues.elem.add(candidateRow.elemVal);
      uniqueValues.size.add(candidateRow.sizeVal);
      if (shouldIncludeAttr) uniqueValues.attr.add(candidateRow.attrVal);
      if (shouldIncludeRace) uniqueValues.race.add(candidateRow.raceVal);

      acceptedRows.push({
        main: candidateRow.mainVal, 
        dmg: candidateRow.dmgVal, 
        elem: candidateRow.elemVal, 
        size: candidateRow.sizeVal,
        attr: candidateRow.attrVal, 
        race: candidateRow.raceVal,
        newMultiplier: candidateRow.newMultiplier, 
        deltaPercent: deltaPercentage
      });

      // Increase jitter if having trouble finding valid rows
      if (acceptedRows.length < 5 && generationAttempts % RECOMMENDATION_CONFIG.jitterStepEvery === 0) {
        dynamicJitter = Math.min(dynamicJitter + RECOMMENDATION_CONFIG.jitterStep, RECOMMENDATION_CONFIG.jitterMax);
      }
    }

    // Sort by delta percentage and multiplier
    acceptedRows.sort((rowA, rowB) => rowB.deltaPercent - rowA.deltaPercent || rowB.newMultiplier - rowA.newMultiplier || rowB.main - rowA.main);

    for (let i = 0; i < acceptedRows.length; i++) {
      const acceptedRow = acceptedRows[i];
      const dataRow = document.createElement('tr');
      
      // Add stat number column
      const statNumberCell = document.createElement('td');
      statNumberCell.className = 'build';
      statNumberCell.textContent = 'BUILD#' + (i + 1).toString();
      dataRow.appendChild(statNumberCell);
      
      dataRow.appendChild(createFactorCell(acceptedRow.main, userMainStat));
      dataRow.appendChild(createFactorCell(acceptedRow.dmg, userDmgStat));
      dataRow.appendChild(createFactorCell(acceptedRow.elem, userElemStat));
      dataRow.appendChild(createFactorCell(acceptedRow.size, userSizeStat));
      if (shouldIncludeRace) dataRow.appendChild(createFactorCell(acceptedRow.race, userRaceStat));
      if (shouldIncludeAttr) dataRow.appendChild(createFactorCell(acceptedRow.attr, userAttrStat));
      
      const multiplierCell = document.createElement('td');
      multiplierCell.className = 'mult';
      multiplierCell.textContent = 'x' + acceptedRow.newMultiplier.toFixed(2);
      dataRow.appendChild(multiplierCell);
      
      const deltaCell = document.createElement('td');
      deltaCell.className = 'delta';
      deltaCell.textContent = '+' + acceptedRow.deltaPercent.toFixed(1) + '%';
      dataRow.appendChild(deltaCell);
      
      tableBody.appendChild(dataRow);
    }

    // Add user's current stats row
    const userCurrentStatsRow = document.createElement('tr');
    userCurrentStatsRow.className = 'your-stats-values';
    
    // Add "Yours" in the stat column
    const yoursCell = document.createElement('td');
    yoursCell.textContent = 'YOURS';
    yoursCell.className = 'yours-label';
    userCurrentStatsRow.appendChild(yoursCell);
    
    userCurrentStatsRow.appendChild(createFactorCell(userMainStat, userMainStat, true));
    userCurrentStatsRow.appendChild(createFactorCell(userDmgStat, userDmgStat, true));
    userCurrentStatsRow.appendChild(createFactorCell(userElemStat, userElemStat, true));
    userCurrentStatsRow.appendChild(createFactorCell(userSizeStat, userSizeStat, true));
    if (shouldIncludeRace) userCurrentStatsRow.appendChild(createFactorCell(userRaceStat, userRaceStat, true));
    if (shouldIncludeAttr) userCurrentStatsRow.appendChild(createFactorCell(userAttrStat, userAttrStat, true));
    
    const userMultiplierCell = document.createElement('td');
    userMultiplierCell.className = 'mult current-mult';
    userMultiplierCell.textContent = 'x' + gameState.mult.toFixed(2);
    userCurrentStatsRow.appendChild(userMultiplierCell);
    
    const userDeltaCell = document.createElement('td');
    userDeltaCell.className = 'delta current-delta';
    userDeltaCell.textContent = '-';
    userCurrentStatsRow.appendChild(userDeltaCell);
    
    tableBody.appendChild(userCurrentStatsRow);

    tableElement.appendChild(tableBody);
    const tableWrapper = document.createElement('div');
    tableWrapper.className = 'table-wrapper';
    tableWrapper.appendChild(tableElement);
    
    if (acceptedRows.length) {
      recommendationContainer.appendChild(tableWrapper);
    }
  }
}
function regenerateRecommendations() {
  if (!isResultShown) return;
  const calculationState = getCurrentCalculationState();
  generateRecommendationTable(calculationState);
}

// ======== FLASH ======
const debounceMap = new Map();
const smoothDebounce = (fn, delay, key) => {
  const existing = debounceMap.get(key);
  if (existing) clearTimeout(existing);
  
  debounceMap.set(key, setTimeout(() => {
    debounceMap.delete(key);
    fn();
  }, delay));
};
const flashState = {
  isTestReaperActive: false,
  isTestSpearActive: false,
  isFlashActive: false
};
for (const key in flashState) {
  Object.defineProperty(window, key, {
    get() {
      return flashState[key];
    },
    set(val) {
      flashState[key] = val;
    }
  });
}
const LIGHTNING_STYLES = {
  flash: `
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    background: radial-gradient(ellipse 140% 200% at center,
      rgba(88, 101, 242, 0.45) 0%, rgba(135, 150, 255, 0.3) 25%,
      rgba(88, 101, 242, 0.2) 45%, rgba(79, 84, 92, 0.12) 70%, 
      rgba(54, 57, 63, 0.06) 85%, transparent 100%);
    opacity: 0; transform: scale3d(0.8, 0.8, 1); pointer-events: none; z-index: 999;
    mix-blend-mode: overlay; display: flex; align-items: center; justify-content: center;
    will-change: opacity, transform; backface-visibility: hidden;
    animation: pulseFlashAnim 1.4s cubic-bezier(0.23, 1, 0.32, 1) forwards, 
               lightningFlicker 1.4s cubic-bezier(0.23, 1, 0.32, 1) forwards;
  `,
  
  lightning: `
    font-size: 3.5rem; color: #f0f0ff; opacity: 0; 
    transform: scale3d(0.7, 0.7, 1) rotate(0deg);
    text-shadow: 
      0 0 8px rgba(255, 255, 255, 1),
      0 0 16px rgba(135, 150, 255, 0.9),
      0 0 24px rgba(88, 101, 242, 0.7),
      0 0 32px rgba(88, 101, 242, 0.5),
      0 0 40px rgba(88, 101, 242, 0.3);
    filter: drop-shadow(0 0 6px rgba(200, 200, 255, 0.8)) 
            drop-shadow(0 0 12px rgba(88, 101, 242, 0.6));
    will-change: opacity, transform; backface-visibility: hidden;
    animation: lightningAnim 1.4s cubic-bezier(0.23, 1, 0.32, 1) forwards;
    -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
  `
};
const injectLightningKeyframes = (() => {
  let injected = false;
  return () => {
    if (injected) return;
    injected = true;
    
    const style = document.createElement('style');
    style.textContent = `
      @keyframes pulseFlashAnim {
        0% { opacity: 0; transform: scale3d(0.8, 0.8, 1); }
        8% { opacity: 0.2; transform: scale3d(0.95, 0.95, 1); }
        12% { opacity: 0.8; transform: scale3d(1.08, 1.08, 1); }
        18% { opacity: 0.3; transform: scale3d(1.05, 1.05, 1); }
        22% { opacity: 0.9; transform: scale3d(1.12, 1.12, 1); }
        35% { opacity: 0.6; transform: scale3d(1.08, 1.08, 1); }
        42% { opacity: 0.85; transform: scale3d(1.1, 1.1, 1); }
        58% { opacity: 0.4; transform: scale3d(1.03, 1.03, 1); }
        75% { opacity: 0.2; transform: scale3d(1.01, 1.01, 1); }
        100% { opacity: 0; transform: scale3d(0.95, 0.95, 1); }
      }
      
      @keyframes lightningFlicker {
        0%, 6%, 14%, 20%, 28%, 34%, 40%, 56%, 74%, 90% {
          opacity: 0; transform: scale3d(0.7, 0.7, 1) rotate(-2deg);
        }
        8%, 16%, 22%, 30%, 36%, 42%, 58%, 76% {
          opacity: 1; transform: scale3d(1.2, 1.2, 1) rotate(1deg);
        }
        10%, 18%, 24%, 32%, 38%, 44%, 60%, 78% {
          opacity: 0.7; transform: scale3d(1.1, 1.1, 1) rotate(-1deg);
        }
        12%, 26%, 46%, 62%, 80% {
          opacity: 0.9; transform: scale3d(1.15, 1.15, 1) rotate(0.5deg);
        }
        50% {
          opacity: 1; transform: scale3d(1.25, 1.25, 1) rotate(-0.5deg);
        }
        100% { opacity: 0; transform: scale3d(0.8, 0.8, 1) rotate(0deg); }
      }
      
      @keyframes lightningAnim {
        0% { 
          opacity: 0; 
          transform: scale3d(0.7, 0.7, 1) rotate(0deg);
        }
        15% { 
          opacity: 0.9; 
          transform: scale3d(1.1, 1.1, 1) rotate(-1deg);
        }
        25% { 
          opacity: 0.6; 
          transform: scale3d(1.05, 1.05, 1) rotate(1deg);
        }
        35% { 
          opacity: 1; 
          transform: scale3d(1.2, 1.2, 1) rotate(-0.5deg);
        }
        50% { 
          opacity: 0.8; 
          transform: scale3d(1.15, 1.15, 1) rotate(0.5deg);
        }
        65% { 
          opacity: 0.4; 
          transform: scale3d(1.08, 1.08, 1) rotate(-0.3deg);
        }
        80% { 
          opacity: 0.2; 
          transform: scale3d(1.02, 1.02, 1) rotate(0.2deg);
        }
        100% { 
          opacity: 0; 
          transform: scale3d(0.9, 0.9, 1) rotate(0deg);
        }
      }
    `;
    document.head.appendChild(style);
  };
})();
function simulateFlash(event) {
  const btn = event?.currentTarget;
  if (!btn || btn.disabled) return;
  btn.disabled = true;
  setTimeout(() => btn.disabled = false, 200);
  const isReaper = btn === DOM_ELEMENTS.testReaper;
  const stateKey = isReaper ? 'isTestReaperActive' : 'isTestSpearActive';
  const prefix = isReaper ? 'reaper' : 'spear';
  flashState[stateKey] = !flashState[stateKey];
  btn.classList.toggle('activated', flashState[stateKey]);
  
  if (flashState[stateKey]) {
    smoothDebounce(() => {
      if (typeof triggerPulseFlash === 'function') {
        triggerPulseFlash();
      }
    }, 100, `${prefix}-flash`);
  }
  
  smoothDebounce(() => {
    if (typeof processMainCalculation === 'function') {
      processMainCalculation();
    }
  }, 150, `${prefix}-calc`);
  
  if (typeof showSnackbar === 'function') {
    showSnackbar(flashState[stateKey] ?
      `${isReaper ? 'Reaper' : 'Spear'} Flash Active` :
      `${isReaper ? 'Reaper' : 'Spear'} Off`);
  }
}
function triggerPulseFlash() {
  if (window.innerWidth >= 480 || flashState.isFlashActive) {
    if (window.innerWidth >= 480) {
      console.log('Flash effect hanya untuk mobile (<480px)');
    }
    return;
  }
  
  flashState.isFlashActive = true;
  injectLightningKeyframes();
  
  requestAnimationFrame(() => {
    const flash = document.createElement('div');
    const lightning = document.createElement('div');
    
    // Apply optimized styles
    flash.style.cssText = LIGHTNING_STYLES.flash;
    lightning.style.cssText = LIGHTNING_STYLES.lightning;
    lightning.innerHTML = '&#x26A1;';
    
    flash.appendChild(lightning);
    
    try {
      document.body.appendChild(flash);
    } catch (e) {
      console.warn('Flash DOM insertion failed', e);
      flashState.isFlashActive = false;
      return;
    }
    
    // Unified cleanup function
    const cleanup = () => {
      if (flash.parentNode) {
        try {
          flash.remove();
        } catch (e) {
          flash.parentNode?.removeChild(flash);
        }
      }
      flashState.isFlashActive = false;
    };
    
    // Multiple cleanup strategies for cross-browser compatibility
    const cleanupTimer = setTimeout(cleanup, 1500);
    
    const handleAnimationEnd = (e) => {
      if (e.target === flash) {
        clearTimeout(cleanupTimer);
        cleanup();
        flash.removeEventListener('animationend', handleAnimationEnd);
        flash.removeEventListener('webkitAnimationEnd', handleAnimationEnd);
      }
    };
    
    flash.addEventListener('animationend', handleAnimationEnd, { passive: true, once: true });
    flash.addEventListener('webkitAnimationEnd', handleAnimationEnd, { passive: true, once: true });
    
    // Emergency cleanup
    setTimeout(() => {
      if (flashState.isFlashActive) cleanup();
    }, 2000);
  });
}

// ========== DROPDOWN ==========
function setOptions(select, options, placeholder, customLabels = {}) {
  const optionElements = placeholder ? [`<option value="">${placeholder}</option>`] : [];
  
  options.forEach(opt => {
    const value = typeof opt === "string" ? opt : opt.value;
    const label = customLabels[value] || (typeof opt === "string" ? opt : opt.label);
    const disabled = opt.disabled ? ' disabled' : '';
    
    optionElements.push(`<option value="${value}"${disabled}>${label}</option>`);
  });
  
  select.innerHTML = optionElements.join("");
}
function populateDropdownOptions() {
  // Populate attack type dropdown
  setOptions(DOM_ELEMENTS.atkType, [
    { value: "pen", label: "P/M PEN" },
    { value: "crit", label: "Critical" }
  ], "Select Attack Type");
  
  // Populate weapon dropdown from lookup table
  setOptions(DOM_ELEMENTS.weapon, Object.keys(WEAPON_SIZE_MODIFIER_TABLE), "Select Weapon");
  
  // Populate weapon element dropdown
  setOptions(DOM_ELEMENTS.wElem, Object.keys(ELEMENT_COUNTER_TABLE), "Select Attribute");
  
  populateTargetDropdowns();
  populateSetDropdowns();
  bindTargetDefenseListener();
  bindThreeSetListeners();
}
function populateTargetDropdowns() {
  const targetConfigs = [
    { element: DOM_ELEMENTS.tSize, options: ["Small", "Medium", "Large"], placeholder: "Select Target Size" },
    { element: DOM_ELEMENTS.tRace, options: RACE_TYPES, placeholder: "skip race" },
    { element: DOM_ELEMENTS.tAttr, options: Object.keys(ELEMENT_COUNTER_TABLE), placeholder: "skip attribute" }
  ];
  
  // Populate and enable target dropdowns
  targetConfigs.forEach(({ element, options, placeholder }) => {
    setOptions(element, options, placeholder);
    element.disabled = false;
  });
  
  // Populate defense dropdown with custom labels
  setOptions(DOM_ELEMENTS.tDef, Object.keys(DEFENSE_TABLE), "Select target monster", {
    "0def": "Dummy (0 DEF)",
    "130boss": "Average 130 BOSS",
    "140boss": "Average 140 BOSS",
    "150boss": "Average 150 BOSS"
  });
}
function populateSetDropdowns() {
  // Build dropdown options efficiently
  const vesperOptions = [
    { value: "", label: "skip vesper set" },
    ...Object.entries(VESPER_SET).map(([tier, val]) => ({ value: val, label: `Tier ${tier}` }))
  ];
  
  const whiteOptions = [
    { value: "", label: "skip white set" },
    ...Object.entries(WHITE_SET).map(([tier, val]) => ({ value: val, label: tier }))
  ];
  
  const blueOptions = [
    { value: "", label: "skip blue set" },
    ...Object.entries(BLUE_SET).flatMap(([multiplier, levels]) =>
      Object.entries(levels).map(([lvl, val]) => ({ value: val, label: `Level ${lvl}*${multiplier}` }))
    )
  ];
  
  setOptions(DOM_ELEMENTS.vesperSet, vesperOptions);
  setOptions(DOM_ELEMENTS.whiteSet, whiteOptions);
  setOptions(DOM_ELEMENTS.blueSet, blueOptions);
}
function bindTargetDefenseListener() {
  if (DOM_ELEMENTS.tDef.dataset.boundDefense) return;
  
  DOM_ELEMENTS.tDef.addEventListener('change', function() {
    const selectedKey = this.value;
    const defenseData = DEFENSE_TABLE[selectedKey];
    const targetElements = [DOM_ELEMENTS.tSize, DOM_ELEMENTS.tRace, DOM_ELEMENTS.tAttr];
    
    if (defenseData?.sizeMob && selectedKey.includes("Lv.")) {
      // Auto-populate and disable fields if defense data contains mob info
      updateTargetField(DOM_ELEMENTS.tSize, defenseData.sizeMob);
      updateTargetField(DOM_ELEMENTS.tRace, defenseData.raceMob);
      updateTargetField(DOM_ELEMENTS.tAttr, defenseData.attributeMob);
    } else {
      // Reset and enable all target fields
      targetElements.forEach(element => {
        element.value = "";
        element.disabled = false;
      });
    }
    
    updateDynamicFieldLabels();
  });
  
  DOM_ELEMENTS.tDef.dataset.boundDefense = "1";
}
// ======== EQ SET ========
function updateTargetField(element, value) {
  if (value) {
    element.value = value;
    element.disabled = true;
  }
}
let selectionOrder = [];
function recordSelection(selectEl) {
  const wasCycleComplete = isCycleComplete();
  
  if (!selectEl?.value) {
    removeFromSelectionOrder(selectEl);
    return;
  }
  
  if (wasCycleComplete) {
    selectionOrder = [selectEl];
  } else if (!selectionOrder.includes(selectEl)) {
    selectionOrder.push(selectEl);
  }
}
function removeFromSelectionOrder(selectEl) {
  const index = selectionOrder.indexOf(selectEl);
  if (index !== -1) {
    selectionOrder.splice(index, 1);
  }
}
function isCycleComplete() {
  const blueText = DOM_ELEMENTS.blueSet?.selectedOptions[0]?.textContent ?? "";
  return selectionOrder.length >= 3 || (DOM_ELEMENTS.blueSet?.value && blueText.includes("*8"));
}
function resetSelectionOrder() {
  selectionOrder = [DOM_ELEMENTS.blueSet, DOM_ELEMENTS.vesperSet, DOM_ELEMENTS.whiteSet]
    .filter(el => el?.value);
}
function setOnlySkip(selectEl) {
  if (!selectEl) return;
  
  Array.from(selectEl.options).forEach(opt => {
    opt.disabled = !!opt.value;
  });
  selectEl.value = "";
}
function enableAllOptions(selectEl) {
  if (!selectEl) return;
  
  Array.from(selectEl.options).forEach(opt => {
    opt.disabled = false;
  });
}
function syncThreeSets() {
  const setElements = {
    blue: DOM_ELEMENTS.blueSet,
    vesper: DOM_ELEMENTS.vesperSet,
    white: DOM_ELEMENTS.whiteSet
  };
  
  if (!setElements.blue || !setElements.vesper) return;
  
  // Enable all options initially
  Object.values(setElements).filter(Boolean).forEach(enableAllOptions);
  
  const blueText = setElements.blue.selectedOptions[0]?.textContent ?? "";
  const blueIs8x = blueText.includes("*8");
  
  // Blue *8 multiplier rule: disable other sets
  if (setElements.blue.value && blueIs8x) {
    setOnlySkip(setElements.vesper);
    if (setElements.white) setOnlySkip(setElements.white);
    return;
  }
  
  // If any set is selected, disable *8 multiplier options
  if (selectionOrder.length > 0) {
    disableBlue8xOptions(setElements.blue);
  }
  
  // Apply two-set limit rule
  applyTwoSetLimit(setElements);
}
function disableBlue8xOptions(blueElement) {
  Array.from(blueElement.options).forEach(opt => {
    if (opt.value && opt.textContent.includes("*8")) {
      opt.disabled = true;
    }
  });
  
  // Reset blue selection if it's now disabled
  if (blueElement.value && blueElement.selectedOptions[0]?.disabled) {
    blueElement.value = "";
    removeFromSelectionOrder(blueElement);
  }
}
function applyTwoSetLimit(setElements) {
  const allSets = Object.values(setElements).filter(Boolean);
  const unselectedSets = allSets.filter(el => !selectionOrder.includes(el));
  
  if (selectionOrder.length >= 2 && unselectedSets.length > 0) {
    unselectedSets.forEach(setOnlySkip);
  }
}
function bindThreeSetListeners() {
  const setElements = [DOM_ELEMENTS.blueSet, DOM_ELEMENTS.vesperSet, DOM_ELEMENTS.whiteSet]
    .filter(Boolean);

  setElements.forEach(element => {
    if (element.dataset.boundThree) return;
    
    element.addEventListener("change", () => {
      recordSelection(element);
      syncThreeSets();
    });
    
    element.dataset.boundThree = "1";
  });
  
  resetSelectionOrder();
  syncThreeSets();
}

// ======== Dynamic UI ========
function handleDropdownChange(event) {
  if (isResultShown) return;
  
  const elementId = event?.target?.id;
  if (!elementId) return;
  
  if (elementId === 'penCritSelect') {
    clearNumericInput(DOM_ELEMENTS.pen);
    clearNumericInput(DOM_ELEMENTS.crit);
    updateAttackTypeUI();
  }
  if (elementId === 'targetRaceSelect') clearNumericInput(DOM_ELEMENTS.race);
  if (elementId === 'targetElementSelect') clearNumericInput(DOM_ELEMENTS.attr);
  
  updateDynamicFieldLabels();
}
function updateAttackTypeUI() {
  const atkType = DOM_ELEMENTS.atkType.value;
  const penGroup = document.querySelector('.form-group.pen-group');
  const critGroup = document.querySelector('.form-group.crit-group');
  
  if (penGroup && critGroup) {
    penGroup.classList.add('hidden');
    critGroup.classList.add('hidden');
  }
  
  if (atkType === 'pen') {
    penGroup?.classList.remove('hidden');
    DOM_ELEMENTS.pen.disabled = false;
    DOM_ELEMENTS.crit.disabled = true;
    DOM_ELEMENTS.crit.value = '';
  } else if (atkType === 'crit') {
    critGroup?.classList.remove('hidden');
    DOM_ELEMENTS.crit.disabled = false;
    DOM_ELEMENTS.pen.disabled = true;
    DOM_ELEMENTS.pen.value = '';
  } else {
    DOM_ELEMENTS.pen.disabled = true;
    DOM_ELEMENTS.crit.disabled = true;
    DOM_ELEMENTS.pen.value = '';
    DOM_ELEMENTS.crit.value = '';
  }
}
function updateDynamicFieldLabels() {
  // Pre-defined label mappings for efficiency
  const vesperLabels = {
    "48": "BRO?!",
    "56": "REALY?!",
    "64": "Wake UP!",
    "72": "STOP Dreaming!",
    "80": "F2P DETECTED!"
  };
  
  const whiteLabels = {
    "36": "Why?",
    "42": "Still dreming yaa",
    "48": "PFTTT!!",
    "54": "Have a Nice Day!"
  };
  
  // Cache DOM values
  const vesperValue = DOM_ELEMENTS.vesperSet.value;
  const whiteValue = DOM_ELEMENTS.whiteSet.value;
  const raceValue = DOM_ELEMENTS.tRace.value;
  const attrValue = DOM_ELEMENTS.tAttr.value;
  const atkTypeValue = DOM_ELEMENTS.atkType.value;
  const wElemValue = DOM_ELEMENTS.wElem.value;
  const tSizeValue = DOM_ELEMENTS.tSize.value;
  
  // Update Vesper SET label
  DOM_ELEMENTS.vesperSetLabel.textContent = vesperLabels[vesperValue] || 'Vesper SET';
  
  // Update White SET label
  DOM_ELEMENTS.whiteSetLabel.textContent = whiteLabels[whiteValue] || 'White SET (110*3)';
  
  // Update Race field
  if (raceValue) {
    DOM_ELEMENTS.race.disabled = false;
    DOM_ELEMENTS.raceLabel.textContent = raceValue;
    DOM_ELEMENTS.race.placeholder = `dmg to ${raceValue.toLowerCase()} % (izlude weapon)`;
  } else {
    DOM_ELEMENTS.race.disabled = true;
    DOM_ELEMENTS.raceLabel.textContent = 'Race';
    DOM_ELEMENTS.race.placeholder = 'select target race first';
    DOM_ELEMENTS.race.value = '';
  }

  // Update Attribute field
  if (attrValue) {
    DOM_ELEMENTS.attr.disabled = false;
    DOM_ELEMENTS.attrLabel.textContent = attrValue;
    DOM_ELEMENTS.attr.placeholder = `dmg to ${attrValue.toLowerCase()} attr % (weapon alberta)`;
  } else {
    DOM_ELEMENTS.attr.disabled = true;
    DOM_ELEMENTS.attrLabel.textContent = '';
    DOM_ELEMENTS.attr.placeholder = 'select target attribute first';
    DOM_ELEMENTS.attr.value = '';
  }

  // Update PMBO fields
  if (atkTypeValue) {
    DOM_ELEMENTS.dmg.disabled = false;
    DOM_ELEMENTS.dmgStack.disabled = false;
    DOM_ELEMENTS.dmg.placeholder = 'final p/m damage bonus %';
    DOM_ELEMENTS.dmgStack.placeholder = 'final damage bonus/stack %';
  } else {
    DOM_ELEMENTS.dmg.disabled = true;
    DOM_ELEMENTS.dmgStack.disabled = true;  
    DOM_ELEMENTS.dmg.placeholder = 'select attack type first';
    DOM_ELEMENTS.dmgStack.placeholder = 'select attack type first';
  }

  // Update Element field
  if (wElemValue) {
    DOM_ELEMENTS.elemEnh.disabled = false;
    DOM_ELEMENTS.elemEnhLabel.textContent = `${wElemValue} Enhance %`;
    DOM_ELEMENTS.elemEnh.placeholder = `${wElemValue.toLowerCase()} enhance %`;
  } else {
    DOM_ELEMENTS.elemEnh.disabled = true;
    DOM_ELEMENTS.elemEnhLabel.textContent = 'Element Enhance %';
    DOM_ELEMENTS.elemEnh.placeholder = 'select weapon attribute first';
    DOM_ELEMENTS.elemEnh.value = '';
  }

  // Update Size enhance field
  if (tSizeValue) {
    DOM_ELEMENTS.sizeEnh.disabled = false;
    DOM_ELEMENTS.sizeLabel.textContent = `DMG to ${tSizeValue} %`;
    DOM_ELEMENTS.sizeEnh.placeholder = `dmg to ${tSizeValue.toLowerCase()} %`;
  } else {
    DOM_ELEMENTS.sizeEnh.disabled = true;
    DOM_ELEMENTS.sizeLabel.textContent = 'DMG to Size %';
    DOM_ELEMENTS.sizeEnh.placeholder = 'select target size first';
    DOM_ELEMENTS.sizeEnh.value = '';
  }
}

// ======== VALIDATION =========
const ValidationSSoT = {
  // Constants
  INVALID_CLASS: 'invalid-value',

  // Optimized Listener Registry with WeakMap for better GC
  listenerRegistry: new Map(),
  elementRefs: new WeakMap(), // Cross-reference for cleanup

  // Cache for performance
  _cache: {
    thresholds: null,
    thresholdTimestamp: 0,
    CACHE_DURATION: 100 // 100ms cache for rapid calls
  },

  // Helper to identify pen & dmg fields - Optimized
  isPenOrDmgField(element) {
    return element && (element.id === 'pen' || element.id === 'dmg');
  },

  // Ultra-safe listener management with better performance
  attachListener(element, eventType, handler, listenerKey) {
    if (!element || !eventType || !handler || !listenerKey) return;

    const elementKey = this.getElementKey(element);
    const fullKey = `${elementKey}_${eventType}_${listenerKey}`;

    // Skip if already exists
    if (this.listenerRegistry.has(fullKey)) return;

    // Use passive listeners where possible for better performance
    const options = (eventType === 'scroll' || eventType === 'touchstart' || eventType === 'touchmove') 
      ? { passive: true } : false;

    // Attach with options
    element.addEventListener(eventType, handler, options);

    // Register with cross-reference for cleanup
    const listenerInfo = { element, eventType, handler, listenerKey, options };
    this.listenerRegistry.set(fullKey, listenerInfo);
    
    // WeakMap cross-reference for element-based cleanup
    if (!this.elementRefs.has(element)) {
      this.elementRefs.set(element, new Set());
    }
    this.elementRefs.get(element).add(fullKey);
  },

  // Optimized listener removal
  removeListener(element, eventType, listenerKey) {
    if (!element || !eventType || !listenerKey) return;

    const elementKey = this.getElementKey(element);
    const fullKey = `${elementKey}_${eventType}_${listenerKey}`;

    const listenerInfo = this.listenerRegistry.get(fullKey);
    if (listenerInfo) {
      element.removeEventListener(eventType, listenerInfo.handler, listenerInfo.options);
      this.listenerRegistry.delete(fullKey);
      
      // Clean cross-reference
      const elementKeys = this.elementRefs.get(element);
      if (elementKeys) {
        elementKeys.delete(fullKey);
        if (elementKeys.size === 0) {
          this.elementRefs.delete(element);
        }
      }
    }
  },

  // Ultra-fast element cleanup using WeakMap
  cleanupElementListeners(element) {
    if (!element) return;

    const elementKeys = this.elementRefs.get(element);
    if (!elementKeys) return;

    // Batch cleanup
    for (const fullKey of elementKeys) {
      const listenerInfo = this.listenerRegistry.get(fullKey);
      if (listenerInfo) {
        element.removeEventListener(listenerInfo.eventType, listenerInfo.handler, listenerInfo.options);
        this.listenerRegistry.delete(fullKey);
      }
    }
    
    this.elementRefs.delete(element);
  },

  // Optimized element key generation
  getElementKey(element) {
    return element.id || (element.className + '_' + (element.dataset.key || Array.prototype.indexOf.call(element.parentNode?.children || [], element)));
  },

  // ===== OPTIMIZED HELPER METHODS =====
  helpers: {
    // Cached validation context for performance
    getValidationContext() {
      const now = performance.now();
      
      // Use cache if fresh
      if (ValidationSSoT._cache.thresholds && 
          (now - ValidationSSoT._cache.thresholdTimestamp) < ValidationSSoT._cache.CACHE_DURATION) {
        return ValidationSSoT._cache.thresholds;
      }

      // Fresh fetch
      const thresholds = ValidationSSoT.getCurrentThresholds();
      const selectedOption = DOM_ELEMENTS.tDef.options[DOM_ELEMENTS.tDef.selectedIndex];
      const targetLabel = selectedOption ? selectedOption.textContent : 'target';
      
      // Cache result
      const result = { thresholds, targetLabel };
      ValidationSSoT._cache.thresholds = result;
      ValidationSSoT._cache.thresholdTimestamp = now;
      
      return result;
    },

    // Micro-optimized number validation with comprehensive cache
    isInvalidNumber: (() => {
      const isValidCache = new Map();
      const CACHE_LIMIT = 100;
      
      return function(value) {
        // Fast path for common cases
        if (value === '' || value === null || value === undefined) return true;
        if (typeof value === 'number') return isNaN(value) || !isFinite(value);
        
        // Cache check
        if (isValidCache.has(value)) return isValidCache.get(value);
        
        const numValue = +value;
        const result = isNaN(numValue) || !isFinite(numValue);
        
        // Manage cache size
        if (isValidCache.size >= CACHE_LIMIT) {
          const firstKey = isValidCache.keys().next().value;
          isValidCache.delete(firstKey);
        }
        
        isValidCache.set(value, result);
        return result;
      };
    })(),

    // Check if value exceeds max attribute
    exceedsMaxValue(element, value) {
      if (!element) return false;
      
      const maxAttr = element.getAttribute("max");
      if (maxAttr === null || maxAttr === '') return false;
      
      const maxVal = +maxAttr;
      const numValue = +(value) || 0;
      
      return numValue > maxVal;
    },

    // Optimized message generation with template caching
    generateRequirementMessage: (() => {
      const templateCache = new Map();
      
      return function(fieldId, threshold, targetLabel) {
        const minRequired = (threshold + 8).toFixed(2);
        
        if (fieldId === 'pen') {
          const penValue = +(DOM_ELEMENTS.pen.value) || 0;
          const penMaxVal = +(DOM_ELEMENTS.pen.getAttribute('max'));
          
          return penValue > penMaxVal ? 
            'what are you doing?' : 
            `Need at least ${minRequired} Final PEN vs ${targetLabel}`;
        } 
        
        if (fieldId === 'dmg') {
          const dmgValue = +(DOM_ELEMENTS.dmg.value) || 0;
          const dmgMaxVal = +(DOM_ELEMENTS.dmg.getAttribute('max'));
          
          return dmgValue > dmgMaxVal ? 
            'what are you doing?' : 
            `Need at least ${minRequired} Final P/M Bonus vs ${targetLabel}`;
        }
      };
    })(),

    // Optimized initialization with debouncing
    performInitialization: (() => {
      let initTimeout;
      
      return function() {
        // Debounce rapid calls
        clearTimeout(initTimeout);
        initTimeout = setTimeout(() => {
          if (!ValidationSSoT.statsValidationState.isReady) {
            ValidationSSoT.initializeStatsValidation();
          }

          if (DOM_ELEMENTS.tDef) {
            const thresholdChangeHandler = () => {
              ValidationSSoT._cache.thresholds = null; // Clear cache
              ValidationSSoT.updateStatsThresholds();
            };

            ValidationSSoT.cleanupElementListeners(DOM_ELEMENTS.tDef);
            ValidationSSoT.attachListener(DOM_ELEMENTS.tDef, 'change', thresholdChangeHandler, 'thresholdUpdate');
          }
        }, 16); // ~1 frame
      };
    })()
  },

  // Cached field configuration
  _fieldRules: null,
  getFieldValidationRules() {
    if (!this._fieldRules) {
      this._fieldRules = [
        { el: DOM_ELEMENTS.atkType, label: 'Attack Type' },
        { el: DOM_ELEMENTS.weapon, label: 'Weapon Type' },
        { el: DOM_ELEMENTS.wElem, label: 'Weapon Attribute' },
        { el: DOM_ELEMENTS.tDef, label: 'Target Boss' },
        { el: DOM_ELEMENTS.tSize, label: 'Target Size' },
        { el: DOM_ELEMENTS.tRace, label: 'Target Race', condition: () => !DOM_ELEMENTS.race.disabled },
        { el: DOM_ELEMENTS.tAttr, label: 'Target Attribute', condition: () => !DOM_ELEMENTS.attr.disabled },
        { el: DOM_ELEMENTS.pen, label: 'Final P M PEN %', condition: () => DOM_ELEMENTS.atkType.value === 'pen' },
        { el: DOM_ELEMENTS.crit, label: 'Critical DMG Bonus %', condition: () => DOM_ELEMENTS.atkType.value === 'crit' },
        { el: DOM_ELEMENTS.dmg, label: 'Final P M DMG Bonus %' },
        { el: DOM_ELEMENTS.elemEnh, label: 'Element Enhance %' },
        { el: DOM_ELEMENTS.sizeEnh, label: 'DMG to Size %' },
        { el: DOM_ELEMENTS.race, label: 'DMG to Race %', condition: () => !DOM_ELEMENTS.race.disabled },
        { el: DOM_ELEMENTS.attr, label: 'DMG to Attribute %', condition: () => !DOM_ELEMENTS.attr.disabled },
        { el: DOM_ELEMENTS.dmgStack, label: 'Final DMG Bonus %' }
      ];
    }
    return this._fieldRules;
  },

  // Optimized threshold fetching with error handling
  getCurrentThresholds() {
    try {
      const defData = getTargetDefenseData(DOM_ELEMENTS.tDef.value || '0def');
      return {
        defVal: +(defData.def) || 0,
        dmgredVal: +(defData.dmgred) || 0
      };
    } catch {
      return { defVal: 0, dmgredVal: 0 };
    }
  },

  // Ultra-optimized class management - REALTIME with smart batching
  applyClassState: (() => {
    const pendingUpdates = new Map(); // Use Map for deduplication
    let updateFrame;
    
    const batchUpdate = () => {
      for (const [element, { isValid, context }] of pendingUpdates) {
        // Skip if element no longer exists in DOM
        if (!element.parentNode) continue;
        
        if (isValid) {
          element.classList.remove(ValidationSSoT.INVALID_CLASS);
        } else {
          element.classList.add(ValidationSSoT.INVALID_CLASS);
          
          // Setup realtime removal for invalid elements
          const removeOnValid = () => {
            if (element.value && element.value !== '') {
              element.classList.remove(ValidationSSoT.INVALID_CLASS);
            }
          };

          ValidationSSoT.attachListener(element, "input", removeOnValid, "fieldValidation");
          ValidationSSoT.attachListener(element, "change", removeOnValid, "fieldValidation");
        }
      }
      pendingUpdates.clear();
    };
    
    return function(element, isValid, context = 'default') {
      if (!element) return;

      // Immediate update for critical operations
      if (context === 'immediate') {
        if (isValid) {
          element.classList.remove(this.INVALID_CLASS);
        } else {
          element.classList.add(this.INVALID_CLASS);
          
          // Setup realtime removal for invalid elements
          const removeOnValid = () => {
            if (element.value && element.value !== '') {
              element.classList.remove(this.INVALID_CLASS);
            }
          };

          this.attachListener(element, "input", removeOnValid, "fieldValidation");
          this.attachListener(element, "change", removeOnValid, "fieldValidation");
        }
        return;
      }

      // Batch non-critical updates with deduplication
      pendingUpdates.set(element, { isValid, context });
      
      if (!updateFrame) {
        updateFrame = requestAnimationFrame(() => {
          batchUpdate();
          updateFrame = null;
        });
      }
    };
  })(),

  // State tracking with optimizations
  statsValidationState: {
    isReady: false,
    isStandby: false,
    touchedFields: new Set()
  },

  // Ultra-optimized stats validation setup
  setupStatsValidation(element) {
    if (!element) return;

    this.cleanupElementListeners(element);

    // ===== REALTIME CLASS MANAGEMENT - HYPER-OPTIMIZED =====
    const realtimeClassValidation = (() => {
      let validationFrame;
      let lastValue = element.value;
      
      return () => {
        // Skip if value hasn't changed
        if (element.value === lastValue && validationFrame) return;
        lastValue = element.value;
        
        // Cancel pending validation
        if (validationFrame) {
          cancelAnimationFrame(validationFrame);
        }
        
        validationFrame = requestAnimationFrame(() => {
          validationFrame = null;
          
          if (!ValidationSSoT.statsValidationState.touchedFields.has(element.id) ||
              ValidationSSoT.statsValidationState.isStandby) return;

          const currentValue = +(element.value) || 0;
          
          // CHECK MAX FIRST - highest priority
          if (ValidationSSoT.helpers.exceedsMaxValue(element, currentValue)) {
            ValidationSSoT.applyClassState(element, false, 'immediate');
            return;
          }
          
          const { thresholds } = ValidationSSoT.helpers.getValidationContext();
          
          let isCurrentlyValid = false;

          if (element.id === 'dmg') {
            const minRequired = thresholds.dmgredVal;
            isCurrentlyValid = currentValue > 0 && (currentValue - minRequired) > 0;
          } else if (element.id === 'pen') {
            const minRequired = thresholds.defVal;
            isCurrentlyValid = currentValue > 0 && (currentValue - minRequired) > 0;
          }

          // REALTIME CLASS MANAGEMENT
          ValidationSSoT.applyClassState(element, isCurrentlyValid, 'immediate');
        });
      };
    })();

    // ===== OPTIMIZED TOUCH DETECTION =====
    const onTouch = () => {
      ValidationSSoT.statsValidationState.touchedFields.add(element.id);
      ValidationSSoT.statsValidationState.isStandby = false;
      realtimeClassValidation();
    };

    // ===== OPTIMIZED BLUR HANDLERS - INDEPENDENT =====
    let onBlur;

    if (element.id === 'pen') {
      onBlur = () => {
        if (!ValidationSSoT.statsValidationState.touchedFields.has('pen') ||
            ValidationSSoT.statsValidationState.isStandby ||
            DOM_ELEMENTS.atkType.value.toLowerCase() !== 'pen') return;

        const penValue = +(DOM_ELEMENTS.pen.value) || 0;
        if (ValidationSSoT.helpers.isInvalidNumber(DOM_ELEMENTS.pen.value) || penValue <= 0) return;

        const { thresholds, targetLabel } = ValidationSSoT.helpers.getValidationContext();
        const defVal = thresholds.defVal;
        const penMaxVal = +(DOM_ELEMENTS.pen.getAttribute('max'));
        const isPenValid = penValue > 0 && (penValue - defVal) > 0 && penValue <= penMaxVal;
        
        if (!isPenValid) {
          const message = ValidationSSoT.helpers.generateRequirementMessage('pen', defVal, targetLabel);
          showSnackbar(message);
        }
      };
    } else if (element.id === 'dmg') {
      onBlur = () => {
        if (!ValidationSSoT.statsValidationState.touchedFields.has('dmg') ||
            ValidationSSoT.statsValidationState.isStandby) return;

        const dmgValue = +(DOM_ELEMENTS.dmg.value) || 0;
        if (ValidationSSoT.helpers.isInvalidNumber(DOM_ELEMENTS.dmg.value) || dmgValue <= 0) return;

        const { thresholds, targetLabel } = ValidationSSoT.helpers.getValidationContext();
        const dmgredVal = thresholds.dmgredVal;
        const dmgMaxVal = +(DOM_ELEMENTS.dmg.getAttribute('max'));
        const isDmgValid = dmgValue > 0 && (dmgValue - dmgredVal) > 0 && dmgValue <= dmgMaxVal;
        
        if (!isDmgValid) {
          const message = ValidationSSoT.helpers.generateRequirementMessage('dmg', dmgredVal, targetLabel);
          showSnackbar(message);
        }
      };
    }

    // ===== ATTACH LISTENERS - BULLETPROOF =====
    this.attachListener(element, "focus", onTouch, "statsTouch");
    this.attachListener(element, "input", realtimeClassValidation, "statsInput");
    this.attachListener(element, "change", realtimeClassValidation, "statsChange");
    if (onBlur) {
      this.attachListener(element, "blur", onBlur, "statsBlur");
    }

    this.statsValidationState.isReady = true;
  },

  // Optimized stats class state
  applyStatsClassState(element, isValid) {
    if (!element) return;
    this.applyClassState(element, isValid, 'immediate');
  },

  // Batch initialization
  initializeStatsValidation() {
    const elements = [DOM_ELEMENTS.pen, DOM_ELEMENTS.dmg].filter(Boolean);
    elements.forEach(el => this.setupStatsValidation(el));
  },

  // Optimized threshold update
  updateStatsThresholds() {
    this.statsValidationState.isStandby = true;
    this.statsValidationState.touchedFields.clear();
    this._cache.thresholds = null; // Clear cache

    // Batch class removal
    [DOM_ELEMENTS.pen, DOM_ELEMENTS.dmg].forEach(el => {
      if (el) el.classList.remove(this.INVALID_CLASS);
    });
  },

  // Optimized threshold change check
  checkStatsAfterThresholdChange() {
    const atkType = DOM_ELEMENTS.atkType.value;
    const { thresholds, targetLabel } = this.helpers.getValidationContext();

    // Batch validation
    const checks = [];

    // PEN check
    if (atkType.toLowerCase() === 'pen' && DOM_ELEMENTS.pen && !this.isEmpty(DOM_ELEMENTS.pen.value)) {
      const penValue = +(DOM_ELEMENTS.pen.value) || 0;
      const defVal = thresholds.defVal;
      const penMaxVal = +(DOM_ELEMENTS.pen.getAttribute('max'));
      const isPenValid = penValue > 0 && (penValue - defVal) > 0 && penValue <= penMaxVal;

      if (!isPenValid) {
        checks.push(() => {
          const message = this.helpers.generateRequirementMessage('pen', defVal, targetLabel);
          showSnackbar(message);
        });
      }
    }

    // DMG check
    if (DOM_ELEMENTS.dmg && !this.isEmpty(DOM_ELEMENTS.dmg.value)) {
      const dmgValue = +(DOM_ELEMENTS.dmg.value) || 0;
      const dmgredVal = thresholds.dmgredVal;
      const dmgMaxVal = +(DOM_ELEMENTS.dmg.getAttribute('max'));
      const isDmgValid = dmgValue > 0 && (dmgValue - dmgredVal) > 0 && dmgValue <= dmgMaxVal;

      if (!isDmgValid) {
        checks.push(() => {
          const message = this.helpers.generateRequirementMessage('dmg', dmgredVal, targetLabel);
          showSnackbar(message);
        });
      }
    }

    // Execute checks
    checks.forEach(check => check());
  },

  // Micro-optimized isEmpty with null safety
  isEmpty: (() => {
    const emptyCache = new Map();
    const CACHE_LIMIT = 50;
    
    return function(value) {
      // Fast path for obvious cases
      if (value === null || value === undefined || value === '') return true;
      if (typeof value !== 'string') return !value;
      
      // Cache check
      if (emptyCache.has(value)) return emptyCache.get(value);
      
      const result = value.trim() === '';
      
      // Manage cache size  
      if (emptyCache.size >= CACHE_LIMIT) {
        const firstKey = emptyCache.keys().next().value;
        emptyCache.delete(firstKey);
      }
      
      emptyCache.set(value, result);
      return result;
    };
  })(),

  // Ultra-optimized numeric normalization
  normalizeNumeric: (() => {
    const normalizeCache = new Map();
    const validPattern = /^\d*\.?\d*$/;
    
    return function(originalValue) {
      if (normalizeCache.has(originalValue)) {
        return normalizeCache.get(originalValue);
      }

      let v = originalValue.trim();
      let hasChanges = false;

      // Batch replacements for better performance
      const beforeClean = v;
      v = v.replace(/[^\d.,]/g, '').replace(/,/g, '.');
      hasChanges = v !== beforeClean;

      // Handle multiple dots
      const dotIndex = v.indexOf('.');
      if (dotIndex !== -1 && v.indexOf('.', dotIndex + 1) !== -1) {
        v = v.slice(0, dotIndex + 1) + v.slice(dotIndex + 1).replace(/\./g, '');
        hasChanges = true;
      }

      // Clean leading zeros and trailing dots
      const beforeZeros = v;
      v = v.replace(/^0+(?=\d)/, '').replace(/\.$/, '');
      if (v !== beforeZeros) hasChanges = true;

      // Fix leading dot
      if (v.startsWith('.')) {
        v = '0' + v;
        hasChanges = true;
      }

      // Validate pattern
      if (!validPattern.test(v) && v !== '') {
        v = '';
        hasChanges = true;
      }

      const result = { value: v, hasChanges };
      
      // Cache with size limit
      if (normalizeCache.size < 100) {
        normalizeCache.set(originalValue, result);
      }
      
      return result;
    };
  })(),

  // Optimized numeric validation
  validateNumericInput(value, element) {
    if (value === '' || isNaN(+value) || !isFinite(+value)) {
      this.applyClassState(element, false, 'immediate');
      return { isValid: false };
    }

    const minVal = +(element.getAttribute("min")) || 0;
    if (+value < minVal) {
      this.applyClassState(element, false, 'immediate');
      return { isValid: false };
    }

    const maxAttr = element.getAttribute("max");
    if (maxAttr !== null && maxAttr !== '') {
      const maxVal = +maxAttr;
      if (+value > maxVal) {
        this.applyClassState(element, false, 'immediate');
        showSnackbar("Bro, you'll broke my engine!");
        return { isValid: false };
      }
    }

    this.applyClassState(element, true, 'immediate');
    return { isValid: true };
  },

  // Enhanced validation with DOM sync control
  validateAndNormalizeInput(element) {
    const originalValue = element.value;
    if (!originalValue) {
      if (!this.isPenOrDmgField(element)) {
        this.applyClassState(element, false, 'immediate');
      }
      return { isValid: false };
    }

    const normalized = this.normalizeNumeric(originalValue);
    
    // Only update DOM if normalization made actual changes
    // Keep original requirement but optimize DOM writes
    if (normalized.hasChanges) {
      // Use original value as per requirement, but we could optimize this
      element.value = element.value;
    }

    const validationResult = this.validateNumericInput(normalized.value, element);

    // Apply class state only for non-PEN/DMG fields
    if (!this.isPenOrDmgField(element)) {
      this.applyClassState(element, validationResult.isValid, 'immediate');
    }

    return validationResult;
  },

  // FIXED: validateRequiredFieldsWithClasses - PEN/DMG now required
  validateRequiredFieldsWithClasses() {
    const fields = this.getFieldValidationRules();

    for (const field of fields) {
      if (!field.el || (field.condition && !field.condition())) continue;

      const fieldValue = field.el.value;
      const isEmpty = this.isEmpty(fieldValue);
      const isPenOrDmg = this.isPenOrDmgField(field.el);

      // Check if field is empty - PEN/DMG now also required
      if (isEmpty) {
        if (!isPenOrDmg) {
          this.applyClassState(field.el, false, 'immediate');
        }
        // PEN/DMG now also fail validation if empty (but no class applied)
        return { isValid: false, field, skipClass: isPenOrDmg };
      }

      // Field has value - validate it for numeric fields
      if (!isPenOrDmg && field.el.type === 'number' || field.el.classList.contains('numeric-input')) {
        const validationResult = this.validateNumericInput(fieldValue, field.el);
        if (!validationResult.isValid) {
          return { isValid: false, field, skipClass: false };
        }
      }
    }

    return { isValid: true, field: null, skipClass: false };
  },

  // Ultra-optimized stats validation with independent paths + max check
  validateStatsWithClasses(state, focusedElement = null) {
    try {
      const { thresholds } = this.helpers.getValidationContext();
      const { defVal, dmgredVal } = thresholds;
      
      let penResult = { isValid: true, element: null };
      let dmgResult = { isValid: true, element: null };

      // ===== INDEPENDENT PEN VALIDATION =====
      if (state.atkType.toLowerCase() === 'pen' && DOM_ELEMENTS.pen) {
        const penVal = +(DOM_ELEMENTS.pen.value) || 0;

        if (this.helpers.isInvalidNumber(DOM_ELEMENTS.pen.value)) {
          this.applyStatsClassState(DOM_ELEMENTS.pen, false);
          penResult = { isValid: false, element: DOM_ELEMENTS.pen };
        } 
        // Check max value first - highest priority
        else if (this.helpers.exceedsMaxValue(DOM_ELEMENTS.pen, penVal)) {
          this.applyStatsClassState(DOM_ELEMENTS.pen, false);
          penResult = { isValid: false, element: DOM_ELEMENTS.pen };
        }
        else {
          const isPenValid = penVal > 0 && (penVal - defVal) > 0;
          this.applyStatsClassState(DOM_ELEMENTS.pen, isPenValid);
          if (!isPenValid) {
            penResult = { isValid: false, element: DOM_ELEMENTS.pen };
          }
        }
      }

      // ===== INDEPENDENT DMG VALIDATION =====
      if (DOM_ELEMENTS.dmg) {
        const dmgVal = +(DOM_ELEMENTS.dmg.value) || 0;

        if (this.helpers.isInvalidNumber(DOM_ELEMENTS.dmg.value)) {
          this.applyStatsClassState(DOM_ELEMENTS.dmg, false);
          dmgResult = { isValid: false, element: DOM_ELEMENTS.dmg };
        }
        // Check max value first - highest priority  
        else if (this.helpers.exceedsMaxValue(DOM_ELEMENTS.dmg, dmgVal)) {
          this.applyStatsClassState(DOM_ELEMENTS.dmg, false);
          dmgResult = { isValid: false, element: DOM_ELEMENTS.dmg };
        }
        else {
          const isDmgValid = dmgVal > 0 && (dmgVal - dmgredVal) > 0;
          this.applyStatsClassState(DOM_ELEMENTS.dmg, isDmgValid);
          if (!isDmgValid) {
            dmgResult = { isValid: false, element: DOM_ELEMENTS.dmg };
          }
        }
      }

      // ===== CONTEXT-BASED RETURN - INDEPENDENT PATHS =====
      if (focusedElement === DOM_ELEMENTS.pen && !penResult.isValid) {
        return penResult;
      }

      if (focusedElement === DOM_ELEMENTS.dmg && !dmgResult.isValid) {
        return dmgResult;
      }

      // Priority: PEN > DMG
      return !penResult.isValid ? penResult : 
             !dmgResult.isValid ? dmgResult : 
             { isValid: true, element: null };

    } catch {
      return { isValid: false, element: null };
    }
  }
};
function normalizeNumericInput(el, pastedValue) {
  if (!el) return;

  const value = (pastedValue ?? el.value).trim();
  const norm = ValidationSSoT.normalizeNumeric(value);

  // PEN/DMG fields: Direct normalization only
  if (ValidationSSoT.isPenOrDmgField(el)) {
    el.value = norm.value;
    return;
  }

  // Other fields: Validate normalized value and update element
  const validationResult = ValidationSSoT.validateNumericInput(norm.value, el);
  el.value = norm.value;
}
function validateRequiredFields() {
  const result = ValidationSSoT.validateRequiredFieldsWithClasses();

  if (!result.isValid && result.field && result.field.el) {
    scrollAndFocusElement(result.field.el);
    return false;
  }

  return true;
}

function validateStatsVsTarget(state, focusedElement = null) {
  // Execute validation and get the actual result
  const result = ValidationSSoT.validateStatsWithClasses(state, focusedElement);
  
  // Additional realtime threshold check on stats change
  if (!ValidationSSoT.statsValidationState.isStandby) {
    ValidationSSoT.checkStatsAfterThresholdChange();
  }
  
  // FIXED: Return the actual validation result, not always true
  // If validation failed, scroll and focus the invalid element
  if (!result.isValid && result.element) {
    scrollAndFocusElement(result.element);
    return false;
  }
  
  return result.isValid;
}
// ========== SAFE STATS SYSTEM ==========
const PASSIVE_SUPPORT = (() => {
  let supported = false;
  try {
    const opts = Object.defineProperty({}, 'passive', {
      get() { supported = true; return false; }
    });
    window.addEventListener('test-passive', () => {}, opts);
    window.removeEventListener('test-passive', () => {}, opts);
  } catch (_) {}
  return supported;
})();
const POINTER_SUPPORT = 'PointerEvent' in window;
function showLockedInputMessage(event) {
  const target = event?.currentTarget;
  if (!target) return;
  
  const now = Date.now();
  
  // Debounce spam clicks
  if (target._lastLockTimestamp && (now - target._lastLockTimestamp) < 500) return;
  target._lastLockTimestamp = now;
  
  // Only prevent if wrapper is locked
  if (!target.classList?.contains('locked')) return;
  
  if (event?.cancelable) {
    event.preventDefault();
    event.stopPropagation();
  }
  
  // Global snackbar debounce
  if (!window._lastSnackbarTime || (now - window._lastSnackbarTime) > 3000) {
    window._lastSnackbarTime = now;
    if (typeof showSnackbar === 'function') {
      showSnackbar("Your Stats Locked!");
    }
  }
}
function bindInputLockGuard(wrapElement) {
  if (!wrapElement?.nodeType || wrapElement.hasAttribute?.('data-lock-bound')) return;
  
  const listeners = [];
  const opts = PASSIVE_SUPPORT ? { passive: false } : false;
  
  if (POINTER_SUPPORT) {
    wrapElement.addEventListener('pointerdown', showLockedInputMessage, opts);
    listeners.push(['pointerdown', showLockedInputMessage, opts]);
  } else {
    wrapElement.addEventListener('touchstart', showLockedInputMessage, opts);
    wrapElement.addEventListener('click', showLockedInputMessage, false);
    listeners.push(['touchstart', showLockedInputMessage, opts], ['click', showLockedInputMessage, false]);
  }
  
  wrapElement._lockListeners = listeners;
  wrapElement.setAttribute('data-lock-bound', '1');
}
function unbindInputLockGuard(wrapElement) {
  if (!wrapElement?.nodeType || !wrapElement.hasAttribute?.('data-lock-bound')) return;
  
  const listeners = wrapElement._lockListeners;
  if (Array.isArray(listeners)) {
    listeners.forEach(([type, handler, opts]) => {
      try {
        wrapElement.removeEventListener(type, handler, opts);
      } catch (_) {}
    });
  }
  
  delete wrapElement._lockListeners;
  delete wrapElement._lastLockTimestamp;
  wrapElement.removeAttribute('data-lock-bound');
}
function lockAllInputs() {
  const wrappers = document.querySelectorAll('.input-wrap');
  if (!wrappers.length) return;
  
  wrappers.forEach(wrapper => {
    if (!wrapper?.nodeType) return;
    
    const elements = wrapper.querySelectorAll('input, select, textarea');
    if (!elements.length) return;
    
    // Lock elements and add visual state
    elements.forEach(el => {
      if (el?.nodeType) el.disabled = true;
    });
    
    wrapper.classList.add('locked');
    bindInputLockGuard(wrapper);
  });
}
function unlockAllInputs() {
  const wrappers = document.querySelectorAll('.input-wrap');
  if (!wrappers.length) return;
  
  wrappers.forEach(wrapper => {
    if (!wrapper?.nodeType) return;
    
    const elements = wrapper.querySelectorAll('input, select, textarea');
    if (!elements.length) return;
    
    // Unlock elements and remove visual state
    elements.forEach(el => {
      if (el?.nodeType) el.disabled = false;
    });
    
    wrapper.classList.remove('locked');
    unbindInputLockGuard(wrapper);
  });
}

// ========== NOTIFICATION SYSTEM ==========
let snackbarTimer = null;
function showSnackbar(text) {
  const sb = DOM_ELEMENTS.snackbar;
  if (!sb) return;
  
  sb.textContent = text;
  clearTimeout(snackbarTimer);
  sb.classList.remove('show');
  sb.offsetHeight; // Force reflow
  sb.classList.add('show');
  
  snackbarTimer = setTimeout(() => sb.classList.remove('show'), 3000);
}
if (window.innerWidth <= 480) {
  const snackbar = document.querySelector('.snackbar');
  const input = document.querySelector('input[type=number]');
  
  if (snackbar) {
    
    const updatePosition = () => {
      const keyboardHeight = window.innerHeight - (window.visualViewport?.height || window.innerHeight);
      snackbar.style.bottom = `${80 + keyboardHeight}px`;
    };
    
    if (window.visualViewport) {
      ['resize', 'scroll'].forEach(event =>
        window.visualViewport.addEventListener(event, updatePosition)
      );
    } else if (input) {
      input.addEventListener('focusin', () => snackbar.style.bottom = '300px');
      input.addEventListener('focusout', () => snackbar.style.bottom = '16px');
    }
  }
}  
function scrollAndFocusElement(el, msg) {
    msg && showSnackbar(msg);
    
    const top = el.getBoundingClientRect().top + window.pageYOffset - 80;
    window.scrollTo({ top, behavior: 'smooth' });
    
    !el.disabled && el.focus({ preventScroll: true });
    return false;
  }
const TOOLTIP_CONFIG = {
  // Hardcode selector
  "#dmgStackTips" : "<strong>Final DMG Bonus</strong> and <strong>F. P/M DMG BONUS</strong> are two <strong>different</strong> things! Look for it in your <strong>detailed stats</strong> where it shows as <strong>Final Damage Stack</strong> or <strong>Final Damage Bonus</strong>. Make sure you don't have any buffs active. Can't find it? Just set 0.",
  "#targetRaceTips" : "Specific MVP/MINi will <strong>auto sync and lock</strong> this option. Select <strong>Avg Lvl Boss</strong> if you want to target spesific race!",
  "#targetAttrTips" : "also same with race.",
  "#dmgRaceTips" : "Unlocked when target race selected, minimum valid value is 0.",
  "#dmgAttrTips" : "same condition with dmg to race"
};
function createTooltip(triggerElement, content) {
  if (!triggerElement || !content) return;
  
  const tooltipElement = document.createElement("div");
  tooltipElement.className = "tooltip-wrap";
  tooltipElement.innerHTML = content;
  document.body.appendChild(tooltipElement);
  
  // Set modern styling for smooth animations
  Object.assign(tooltipElement.style, {
    opacity: '0',
    transform: 'translate(-50%, -100%) scale(0.95)',
    transition: 'opacity 0.2s cubic-bezier(0.16, 1, 0.3, 1), transform 0.2s cubic-bezier(0.16, 1, 0.3, 1)',
    transformOrigin: 'center bottom',
    pointerEvents: 'none',
    position: 'absolute',
    zIndex: '9999'
  });
  
  let isTooltipVisible = false;
  let showTimer = null;
  let hideTimer = null;
  
  const showTooltip = () => {
    clearTimeout(hideTimer);
    if (isTooltipVisible) return;
    
    positionTooltip();
    isTooltipVisible = true;
    
    requestAnimationFrame(() => {
      tooltipElement.style.opacity = '1';
      tooltipElement.style.transform = tooltipElement.style.transform.replace('scale(0.95)', 'scale(1)');
      tooltipElement.style.pointerEvents = 'auto';
    });
  };
  
  const hideTooltip = () => {
    clearTimeout(showTimer);
    if (!isTooltipVisible) return;
    
    tooltipElement.style.opacity = '0';
    tooltipElement.style.transform = tooltipElement.style.transform.replace('scale(1)', 'scale(0.95)');
    tooltipElement.style.pointerEvents = 'none';
    isTooltipVisible = false;
  };
  
  const toggleTooltip = (event) => {
    event?.stopPropagation();
    event?.preventDefault();
    isTooltipVisible ? hideTooltip() : showTooltip();
  };
  
  const positionTooltip = () => {
    const triggerRect = triggerElement.getBoundingClientRect();
    const scrollX = window.pageXOffset;
    const scrollY = window.pageYOffset;
    
    // Measure tooltip dimensions efficiently
    tooltipElement.style.visibility = 'hidden';
    tooltipElement.style.display = 'block';
    const { offsetWidth: tooltipWidth, offsetHeight: tooltipHeight } = tooltipElement;
    tooltipElement.style.visibility = '';
    tooltipElement.style.display = '';
    
    // Smart positioning with viewport awareness
    const centerX = triggerRect.left + scrollX + (triggerRect.width / 2);
    let topPosition = triggerRect.top + scrollY - tooltipHeight - 12;
    
    const padding = 16;
    const maxLeft = window.innerWidth - tooltipWidth - padding;
    let leftPosition = Math.max(padding, Math.min(centerX - (tooltipWidth / 2), maxLeft));
    
    // Flip tooltip if no space above
    let transformOrigin = 'center bottom';
    if (topPosition < padding + scrollY) {
      topPosition = triggerRect.bottom + scrollY + 12;
      transformOrigin = 'center top';
    }
    
    // Apply smooth transform-based positioning
    tooltipElement.style.left = '0px';
    tooltipElement.style.top = '0px';
    tooltipElement.style.transformOrigin = transformOrigin;
    
    const currentScale = isTooltipVisible ? 'scale(1)' : 'scale(0.95)';
    tooltipElement.style.transform = `translate(${leftPosition}px, ${topPosition}px) ${currentScale}`;
  };
  
  // Optimized event handling
  const handleOutsideInteraction = (event) => {
    if (isTooltipVisible &&
      !triggerElement.contains(event.target) &&
      !tooltipElement.contains(event.target)) {
      hideTooltip();
    }
  };
  
  const handleKeydown = (event) => {
    if (event.key === "Escape" && isTooltipVisible) {
      hideTooltip();
    } else if ((event.key === "Enter" || event.key === " ") &&
      event.target === triggerElement) {
      event.preventDefault();
      toggleTooltip(event);
    }
  };
  
  // Modern touch-friendly event listeners
  triggerElement.addEventListener("click", toggleTooltip);
  triggerElement.addEventListener("touchend", (event) => {
    event.preventDefault();
    toggleTooltip(event);
  }, { passive: false });
  
  // Global listeners with passive optimization
  document.addEventListener("click", handleOutsideInteraction);
  document.addEventListener("touchend", handleOutsideInteraction, { passive: true });
  document.addEventListener("keydown", handleKeydown);
  
  // Throttled repositioning for better performance
  let repositionTimer = null;
  const throttledReposition = () => {
    if (!isTooltipVisible) return;
    clearTimeout(repositionTimer);
    repositionTimer = setTimeout(positionTooltip, 16); // ~60fps
  };
  
  window.addEventListener('resize', throttledReposition, { passive: true });
  window.addEventListener('scroll', throttledReposition, { passive: true });
}
function setupTooltips(config) {
  Object.entries(config).forEach(([key, content]) => {
    let elements = [];
    
    try {
      if (typeof key === 'string') {
        elements = document.querySelectorAll(key);
      } else if (key instanceof Element) {
        elements = [key];
      }
      
      elements.forEach(element => {
        element instanceof Element && createTooltip(element, content);
      });
    } catch (error) {
      console.warn('Tooltip setup error for:', key, error);
    }
  });
}

// ========== EVENT BINDING  ==========
function bindAllEventListeners() {
  if (bindAllEventListeners.bound) return;
  bindAllEventListeners.bound = true;
  
  populateDropdownOptions();
  
  // Main action buttons with null safety
  const buttonBindings = [
    [DOM_ELEMENTS.submit, processMainCalculation],
    [DOM_ELEMENTS.resetRek, () => {
      regenerateRecommendations();
      typeof showSnackbar === 'function' && showSnackbar("Table Refreshed!");
    }],
    [DOM_ELEMENTS.resetAll, resetAllData]
  ];
  
  buttonBindings.forEach(([element, handler]) => {
    element?.addEventListener('click', handler);
  });
  
  // Test simulation buttons (with double-binding protection)
  const testButtons = [
    ['testReaper', simulateFlash],
    ['testSpear', simulateFlash]
  ];
  
  testButtons.forEach(([key, handler]) => {
    const element = DOM_ELEMENTS[key];
    if (element && !element.dataset.simBound) {
      element.addEventListener('click', handler);
      element.dataset.simBound = '1';
    }
  });
  
  // Dropdown change listeners (optimized selector)
  const dropdownIds = [
    'penCritSelect', 'weaponSelect', 'weaponElementSelect',
    'targetSizeSelect', 'targetRaceSelect', 'targetElementSelect',
    'vesperSet', 'whiteSet'
  ];
  
  dropdownIds.forEach(id => {
    const element = document.getElementById(id);
    element?.addEventListener('change', handleDropdownChange);
  });
  
  // Numeric input validation with event delegation optimization
  const numericFields = [
    'pen', 'crit', 'dmg', 'elemEnh', 'sizeEnh',
    'race', 'attr', 'dmgStack'
  ];
  
  numericFields.forEach(fieldKey => {
    const element = DOM_ELEMENTS[fieldKey];
    if (!element) return;
    
    // Blur validation
    element.addEventListener('blur', () => normalizeNumericInput(element));
    
    // Paste handling with modern clipboard API fallback
    element.addEventListener('paste', event => {
      event.preventDefault();
      
      const clipboardData = event.clipboardData || window.clipboardData;
      const pastedText = clipboardData?.getData('text') || '';
      
      if (pastedText) {
        normalizeNumericInput(element, pastedText);
      }
    });
  });
}

// ======== ACCORDION =========
document.querySelectorAll('details').forEach(details => {
  const summary = details.querySelector('summary');
  const content = details.querySelector('.body');
  
  if (!summary || !content) return;
  
  // Set initial state
  content.style.transition = 'max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
  content.style.overflow = 'hidden';
  
  summary.addEventListener('click', e => {
    e.preventDefault();
    
    const isOpen = details.hasAttribute('open');
    
    if (isOpen) {
      // Closing
      content.style.maxHeight = content.scrollHeight + 'px';
      requestAnimationFrame(() => {
        content.style.maxHeight = '0px';
      });
      
      const handleClose = () => {
        details.removeAttribute('open');
        content.removeEventListener('transitionend', handleClose);
      };
      
      content.addEventListener('transitionend', handleClose, { once: true });
    } else {
      // Opening
      details.setAttribute('open', '');
      content.style.maxHeight = '0px';
      
      requestAnimationFrame(() => {
        content.style.maxHeight = content.scrollHeight + 'px';
      });
      
      const handleOpen = () => {
        content.style.maxHeight = 'none';
        content.removeEventListener('transitionend', handleOpen);
      };
      
      content.addEventListener('transitionend', handleOpen, { once: true });
    }
  });
});

// ======== OPTIMIZED STICKY HANDLER ========
class StickyHandler {
  constructor() {
    this.elements = new Map();
    this.isActive = false;
    this.isCollapsed = false;
    this.observers = new Set();
    this.rafId = null;
    this.lastScrollY = 0;
    this.isMobile = false;
    
    // Pre-calculate constants
    this.MOBILE_BREAKPOINT = 480;
    this.BUTTON_HEIGHT = 56;
    this.BASE_OFFSET = 20;
    
    // Cached DOM queries
    this.cache = new Map();
    
    this.init();
  }

  // Optimized element getter with caching
  getElement(id) {
    if (this.cache.has(id)) {
      return this.cache.get(id);
    }
    
    const element = document.getElementById(id);
    if (element) {
      this.cache.set(id, element);
    }
    return element;
  }

  // Clear cache when DOM changes
  clearCache() {
    this.cache.clear();
  }

  // Calculate safe bottom position
  calculateSafeBottomPosition(index = 0) {
    return `calc(${this.BASE_OFFSET + index * this.BUTTON_HEIGHT}px + env(safe-area-inset-bottom))`;
  }

  // Initialize all sticky elements - MINIMAL APPROACH
  initElements() {
    const elementIds = {
      resetRek: "resetRekomenBtn",
      resetAll: "resetAllBtn", 
      swapBoss: "breakdown-swap",
      swapLabel: "swap-label",
      stickyStart: DOM_ELEMENTS?.hasil,
      testSpear: DOM_ELEMENTS?.testSpear,
      testReaper: DOM_ELEMENTS?.testReaper
    };

    // JUST GET REFERENCES, DON'T INTERFERE WITH EXISTING ELEMENTS
    Object.entries(elementIds).forEach(([key, id]) => {
      const element = typeof id === 'string' ? this.getElement(id) : id;
      if (element) {
        this.elements.set(key, element);
        // Only preserve text for non-critical buttons
        if (!['swapBoss', 'swapLabel'].includes(key)) {
          this.preserveOriginalText(element);
        }
      }
    });

    // Create our own buttons only
    this.initToggleButton();
    this.initBackButton();
  }

  // Initialize toggle button with safe creation
  initToggleButton() {
    let toggleBtn = this.getElement("toggleStickyBtn");
    
    if (!toggleBtn) {
      toggleBtn = document.createElement("button");
      toggleBtn.id = "toggleStickyBtn";
      toggleBtn.className = "sticky-toggle";
      toggleBtn.setAttribute("data-collapse", "false");
      document.body.appendChild(toggleBtn);
      this.cache.set("toggleStickyBtn", toggleBtn);
    }
    
    this.elements.set('toggleBtn', toggleBtn);
    
    // Only bind if not already bound
    if (!toggleBtn.hasAttribute('data-sticky-bound')) {
      toggleBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        this.isCollapsed = !this.isCollapsed;
        toggleBtn.setAttribute("data-collapse", this.isCollapsed.toString());
        toggleBtn.classList.toggle("active", !this.isCollapsed);
        
        this.updateStickyState(true);
      }, { passive: false });
      
      toggleBtn.setAttribute('data-sticky-bound', 'true');
    }
  }

  // Initialize back button with safe creation
  initBackButton() {
    let backBtn = this.getElement("backToHasilBtn");
    
    if (!backBtn) {
      backBtn = document.createElement("button");
      backBtn.id = "backToHasilBtn";
      backBtn.className = "sticky-back";
      document.body.appendChild(backBtn);
      this.cache.set("backToHasilBtn", backBtn);
    }
    
    this.elements.set('backBtn', backBtn);
    
    if (!backBtn.hasAttribute('data-sticky-bound')) {
      backBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        const stickyStart = this.elements.get('stickyStart');
        if (stickyStart) {
          stickyStart.scrollIntoView({ 
            behavior: "smooth",
            block: "start",
            inline: "nearest"
          });
        }
      }, { passive: false });
      
      backBtn.setAttribute('data-sticky-bound', 'true');
    }
  }

  // Preserve original text for buttons
  preserveOriginalText(element) {
    if (element && !element.hasAttribute("data-original-text")) {
      element.setAttribute("data-original-text", element.textContent || "");
    }
  }

  // Check if mobile view
  checkMobileView() {
    const newIsMobile = window.innerWidth <= this.MOBILE_BREAKPOINT;
    if (newIsMobile !== this.isMobile) {
      this.isMobile = newIsMobile;
      return true;
    }
    return false;
  }

  // Get all sticky buttons in order
  getStickyButtons() {
    const buttonOrder = [
      'toggleBtn',
      'swapBoss', 
      'testSpear',
      'testReaper',
      'resetRek',
      'resetAll',
      'backBtn'
    ];
    
    return buttonOrder
      .map(key => this.elements.get(key))
      .filter(Boolean);
  }

  // Reset all sticky styles - MINIMAL INTERFERENCE
  resetStickyStyles() {
    const allButtons = this.getStickyButtons();
    
    allButtons.forEach(button => {
      // Only remove classes we added
      button.classList.remove("sticky", "collapsed");
      // Only reset styles we set
      button.style.transform = "";
      
      const originalText = button.getAttribute("data-original-text");
      if (originalText !== null) {
        button.textContent = originalText;
      }
    });
    
    const swapLabel = this.elements.get('swapLabel');
    if (swapLabel) {
      swapLabel.classList.remove("hidden");
    }
  }

  // Update sticky state efficiently
  updateStickyState(force = false) {
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
    }
    
    this.rafId = requestAnimationFrame(() => {
      this.performStickyUpdate(force);
      this.rafId = null;
    });
  }

  // Main sticky update logic
  performStickyUpdate(force = false) {
    const viewChanged = this.checkMobileView();
    
    // Desktop mode - disable sticky
    if (!this.isMobile) {
      if (viewChanged || force) {
        this.isActive = false;
        this.resetStickyStyles();
      }
      return;
    }

    // Mobile mode - check if sticky should be active
    const stickyStart = this.elements.get('stickyStart');
    if (!stickyStart) return;
    
    const rect = stickyStart.getBoundingClientRect();
    const shouldBeActive = rect.top <= 0;
    
    if (!force && shouldBeActive === this.isActive && !viewChanged) {
      return;
    }
    
    this.isActive = shouldBeActive;
    
    const swapLabel = this.elements.get('swapLabel');
    if (swapLabel) {
      swapLabel.classList.toggle("hidden", this.isActive);
    }

    if (!this.isActive) {
      this.resetStickyStyles();
      return;
    }

    this.applyStickyStyles();
  }

  // Apply sticky styles to buttons - MINIMAL CSS CHANGES
  applyStickyStyles() {
    const buttons = this.getStickyButtons();
    
    buttons.forEach((button, index) => {
      button.classList.add("sticky");
      button.classList.toggle("collapsed", this.isCollapsed);
      
      const transform = this.isCollapsed ? 
        "translateY(0)" : 
        `translateY(-${index * this.BUTTON_HEIGHT}px)`;
      button.style.transform = transform;
    });
    
    this.updateButtonText();
  }

  // Update button text based on sticky state
  updateButtonText() {
    const textButtons = ['resetRek', 'resetAll', 'testSpear', 'testReaper'];
    
    textButtons.forEach(key => {
      const button = this.elements.get(key);
      if (!button) return;
      
      const originalText = button.getAttribute("data-original-text") || "";
      button.textContent = this.isActive ? "" : originalText;
    });
  }

  // Throttled scroll handler
  createScrollHandler() {
    let ticking = false;
    
    return () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          const newScrollY = window.pageYOffset || document.documentElement.scrollTop;
          if (Math.abs(newScrollY - this.lastScrollY) > 5) {
            this.updateStickyState();
            this.lastScrollY = newScrollY;
          }
          ticking = false;
        });
        ticking = true;
      }
    };
  }

  // Initialize with proper error handling
  init() {
    try {
      this.initElements();
      
      const scrollHandler = this.createScrollHandler();
      const resizeHandler = () => this.updateStickyState(true);
      
      const eventOptions = { passive: true, capture: false };
      
      window.addEventListener('scroll', scrollHandler, eventOptions);
      window.addEventListener('resize', resizeHandler, eventOptions);
      
      if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
        window.addEventListener('orientationchange', () => {
          setTimeout(() => this.updateStickyState(true), 200);
        }, eventOptions);
      }
      
      this.updateStickyState(true);
      
    } catch (error) {
      console.error('StickyHandler initialization failed:', error);
    }
  }

  // Mutation observer for dynamic content
  initMutationObserver() {
    if (typeof MutationObserver === 'undefined') return;
    
    const observer = new MutationObserver((mutations) => {
      let needsUpdate = false;
      
      mutations.forEach(mutation => {
        if (mutation.type === 'childList') {
          const hasImportantElement = Array.from(mutation.addedNodes).some(node => 
            node.nodeType === 1 && (
              node.id === 'breakdown-swap' || 
              ['resetRekomenBtn', 'resetAllBtn', 'swap-label'].includes(node.id) ||
              node.querySelector?.('#breakdown-swap, #resetRekomenBtn, #resetAllBtn, #swap-label')
            )
          );
          
          if (hasImportantElement) {
            needsUpdate = true;
          }
        }
      });
      
      if (needsUpdate) {
        // Clear specific cache entries
        ['breakdown-swap', 'resetRekomenBtn', 'resetAllBtn', 'swap-label'].forEach(id => {
          this.cache.delete(id);
        });
        
        setTimeout(() => {
          this.initElements();
          this.updateStickyState(true);
        }, 50);
      }
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    
    this.observers.add(observer);
  }

  // Cleanup method
  destroy() {
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
    }
    
    this.observers.forEach(observer => observer.disconnect());
    this.observers.clear();
    
    this.cache.clear();
    this.elements.clear();
  }
}
function calculateSafeBottomPosition(index = 0) {
  if (window.stickyHandler) {
    return window.stickyHandler.calculateSafeBottomPosition(index);
  }
  // Fallback
  return `calc(${20 + index * 56}px + env(safe-area-inset-bottom))`;
}
function manageStickyElements() {
  if (window.stickyHandler) {
    window.stickyHandler.updateStickyState(true);
  }
}

// ======== INTEGRATION WITH GLOBAL INIT ========
class AppInitializer {
  constructor() {
    this.isInitialized = false;
    this.observers = new Set();
    this.eventHandlers = new Map();
    this.stickyHandler = null;
    
    // Single optimized throttle instance
    this.viewportChangeHandler = this.createThrottledHandler();
    
    this.init();
  }

  // Unified RAF throttle with better memory management
  createThrottledHandler() {
    let rafId = null;
    
    const handler = () => {
      this.stickyHandler?.updateStickyState();
      rafId = null;
    };
    
    const throttled = () => {
      rafId ??= requestAnimationFrame(handler);
    };
    
    throttled.cancel = () => {
      if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
    };
    
    return throttled;
  }

  // Legacy throttle (unchanged for compatibility)
  throttle(func, delay) {
    let timeoutId, lastExecTime = 0;
    
    return (...args) => {
      const now = Date.now();
      const remaining = delay - (now - lastExecTime);
      
      if (remaining <= 0) {
        func.apply(this, args);
        lastExecTime = now;
      } else {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          func.apply(this, args);
          lastExecTime = Date.now();
        }, remaining);
      }
    };
  }

  // Optimized element getter with caching
  getElement(selector) {
    if (!selector) return null;
    if (typeof selector !== 'string') return selector;
    
    // Simple caching for frequently accessed elements
    if (!this._elementCache) this._elementCache = new Map();
    
    if (!this._elementCache.has(selector)) {
      try {
        this._elementCache.set(selector, document.getElementById(selector));
      } catch {
        this._elementCache.set(selector, null);
      }
    }
    
    return this._elementCache.get(selector);
  }

  // Streamlined event listener management
  addEventListenerSafe(element, event, handler, options = {}) {
    if (!element) return false;
    
    const key = `${element.id || Math.random()}-${event}`;
    if (this.eventHandlers.has(key)) return false;
    
    const opts = { passive: true, ...options };
    element.addEventListener(event, handler, opts);
    this.eventHandlers.set(key, { element, event, handler, options: opts });
    
    return true;
  }

  // Lazy sticky handler initialization
  initStickyHandler() {
    if (this.stickyHandler) return;
    
    this.stickyHandler = new StickyHandler();
    this.stickyHandler.initMutationObserver();
    window.stickyHandler = this.stickyHandler;
  }

  // Optimized mutation observer with single callback
  initMutationObserver() {
    if (typeof MutationObserver === 'undefined') return;
    
    const observer = new MutationObserver((mutations) => {
      // Use some() for early exit
      if (mutations.some(m => 
        Array.from(m.addedNodes).some(n => 
          n.nodeType === 1 && (n.id === 'breakdown-swap' || n.querySelector?.('#breakdown-swap'))
        )
      )) {
        requestAnimationFrame(() => this.initStickyHandler());
      }
    });
    
    observer.observe(document.body, { childList: true, subtree: true });
    this.observers.add(observer);
  }

  // Streamlined modal with cached elements and optimized animations
  initModal() {
    const { log, openLog, closeLog } = DOM_ELEMENTS || {};
    if (!log) return;
    
    // Cache modal content element
    const modalContent = log.querySelector('.modal-content, .log-content, .modal-body') || log.firstElementChild;
    
    // Pre-calculate styles object to avoid repeated object creation
    const hiddenStyles = {
      display: 'none', opacity: '0', transform: 'scale(0.95)',
      transition: 'opacity 0.3s cubic-bezier(0.16, 1, 0.3, 1), transform 0.3s cubic-bezier(0.16, 1, 0.3, 1)',
      transformOrigin: 'center', backdropFilter: 'blur(0px)', backgroundColor: 'rgba(0, 0, 0, 0)'
    };
    
    const visibleStyles = {
      opacity: '1', transform: 'scale(1)',
      backdropFilter: 'blur(8px)', backgroundColor: 'rgba(0, 0, 0, 0.4)'
    };
    
    // Initialize styles
    Object.assign(log.style, hiddenStyles);
    
    if (modalContent) {
      Object.assign(modalContent.style, {
        transform: 'translateY(20px) scale(0.95)',
        transition: 'transform 0.3s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.3s ease-out',
        opacity: '0.8'
      });
    }
    
    // Single outside click handler with improved logic
    const handleOutsideClick = (e) => {
      if (log.style.display === 'flex' && 
          modalContent && 
          !modalContent.contains(e.target) && 
          e.target !== openLog) {
        hideModal();
      }
    };
    
    const showModal = () => {
      log.style.display = 'flex';
      
      requestAnimationFrame(() => {
        Object.assign(log.style, visibleStyles);
        
        if (modalContent) {
          Object.assign(modalContent.style, {
            transform: 'translateY(0px) scale(1)', opacity: '1'
          });
        }
      });
      
      // Delayed outside click listener
      setTimeout(() => document.addEventListener('click', handleOutsideClick), 50);
    };
    
    const hideModal = () => {
      Object.assign(log.style, {
        opacity: '0', transform: 'scale(0.95)',
        backdropFilter: 'blur(0px)', backgroundColor: 'rgba(0, 0, 0, 0)'
      });
      
      if (modalContent) {
        Object.assign(modalContent.style, {
          transform: 'translateY(-10px) scale(0.98)', opacity: '0.7'
        });
      }
      
      setTimeout(() => log.style.display = 'none', 300);
      document.removeEventListener('click', handleOutsideClick);
    };
    
    // Event listeners
    if (openLog) {
      this.addEventListenerSafe(openLog, 'click', (e) => {
        e.stopPropagation();
        showModal();
      });
    }
    
    if (closeLog) {
      this.addEventListenerSafe(closeLog, 'click', hideModal);
    }
    
    this.addEventListenerSafe(document, 'keydown', (e) => {
      if (e.key === 'Escape' && log.style.display === 'flex') {
        hideModal();
      }
    });
  }

  // Batch core initialization with error containment
  initCore() {
    const coreInits = ['bindAllEventListeners', 'updateAttackTypeUI', 'updateDynamicFieldLabels'];
    
    coreInits.forEach(name => {
      const fn = window[name];
      if (typeof fn === 'function') {
        try { fn(); } catch (e) { console.warn(`${name} failed:`, e); }
      }
    });
  }

  // Optimized viewport handlers with iOS detection caching
  initViewportHandlers() {
    const options = { passive: true };
    this.addEventListenerSafe(window, 'scroll', this.viewportChangeHandler, options);
    this.addEventListenerSafe(window, 'resize', this.viewportChangeHandler, options);
    
    // Cache iOS detection
    if (!this._isIOS) {
      this._isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);
    }
    
    if (this._isIOS) {
      this.addEventListenerSafe(window, 'orientationchange', () => {
        setTimeout(this.viewportChangeHandler, 200);
      });
    }
  }

  // Simplified validation init
  initValidation() {
    try {
      ValidationSSoT?.helpers?.performInitialization?.();
    } catch (e) {
      console.warn('Validation init failed:', e);
    }
  }

  // Legacy compatibility
  manageStickyElements() {
    this.stickyHandler?.updateStickyState(true);
  }

  // Simplified tooltip init
  initTooltip() {
    try {
      if (typeof setupTooltips === 'function' && typeof TOOLTIP_CONFIG !== 'undefined') {
        setupTooltips(TOOLTIP_CONFIG);
      }
    } catch (e) {
      console.warn('Tooltip init failed:', e);
    }
  }

  // Streamlined main initialization
  initializeApp() {
    if (!DOM_ELEMENTS?.log) {
      console.warn('DOM_ELEMENTS.log not found');
      return;
    }
    
    // Batch all initializations
    const inits = [
      'initMutationObserver', 'initModal', 'initCore', 
      'initStickyHandler', 'initViewportHandlers', 
      'initTooltip', 'initValidation'
    ];
    
    inits.forEach(method => this[method]());
  }

  // Safe initialization with improved duplicate check
  safeInit() {
    if (this.isInitialized) return;
    
    this.isInitialized = true;
    
    try {
      this.initializeApp();
    } catch (e) {
      console.error('App init failed:', e);
      this.isInitialized = false;
    }
  }

  // Main entry point
  init() {
    const initFn = () => requestAnimationFrame(() => this.safeInit());
    
    if (document.readyState === 'loading') {
      this.addEventListenerSafe(document, 'DOMContentLoaded', initFn, { once: true, passive: false });
    } else {
      initFn();
    }
  }

  // Enhanced cleanup
  destroy() {
    this.viewportChangeHandler?.cancel();
    
    if (this.stickyHandler) {
      this.stickyHandler.destroy();
      this.stickyHandler = null;
      window.stickyHandler = null;
    }
    
    this.eventHandlers.forEach(({ element, event, handler, options }) => {
      element.removeEventListener(event, handler, options);
    });
    this.eventHandlers.clear();
    
    this.observers.forEach(obs => obs.disconnect());
    this.observers.clear();
    
    // Clear cache
    this._elementCache?.clear();
    
    this.isInitialized = false;
  }
}

// Initialization and exports (unchanged)
const appInitializer = new AppInitializer();

if (typeof module !== 'undefined' && module.exports) {
  module.exports = { AppInitializer, StickyHandler };
} else if (typeof window !== 'undefined') {
  window.AppInitializer = AppInitializer;
  window.StickyHandler = StickyHandler;
  window.calculateSafeBottomPosition = calculateSafeBottomPosition;
  window.manageStickyElements = manageStickyElements;
}

// ======== RESET ========
function resetAllData() {
  if (!confirm('Reset all data')) return;
  
  document.querySelectorAll('input').forEach(input =>
    input.value = ''
  );
  document.querySelectorAll('select').forEach(select => select.value = '');
  
  isResultShown = false;
  processMainCalculationTimeout = null;
  flashState.isTestReaperActive = false;
  flashState.isTestSpearActive = false;
  flashState.isFlashActive = false;
  
  selectionOrder = [];
  bindThreeSetListeners();
  
  DOM_ELEMENTS.hasil.textContent = 'Input your stats to see the result...';
  DOM_ELEMENTS.rec.textContent = 'Balancing stat recommendations for a higher output multiplier.';
  DOM_ELEMENTS.submit.disabled = false;
  DOM_ELEMENTS.resetRek.disabled = true;
  DOM_ELEMENTS.resetAll.disabled = true;
  DOM_ELEMENTS.testSpear.disabled = true;
  DOM_ELEMENTS.testReaper.disabled = true;
  
  DOM_ELEMENTS.testSpear.classList.remove('activated');
  DOM_ELEMENTS.testReaper.classList.remove('activated');
  // reset test flags and their UI 
  updateAttackTypeUI();
  updateDynamicFieldLabels();
  scrollAndFocusElement(DOM_ELEMENTS.topOfPage, 'Cleared!');
  unlockAllInputs();
  unbindInputLockGuard();
  
}
</script>
 </body>
</html>
