<!DOCTYPE html>
<!-- 96% chatgpt, 3% claude sonnet, 1% me just asking ai to write this line -->
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1" name="viewport"/>
  <title>Alt-Sim</title>
  <meta name="description" content="Calc base multiplier and randomize around your stats for better results."/>
    <meta name="theme-color" content="#36393f">
<meta name="msapplication-TileColor" content="#36393f">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!--<script async src="https://www.googletagmanager.com/gtag/js?id=G-5XWWWBSH8P"></script>-->
<!--<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-5XWWWBSH8P');
</script>-->
<style>*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}

:root{
  --bg:#36393f;--text:#b9bbbe;--label:#dcddde;--primary:#5865f2;--secondary:#4f545c;--danger:#ed4245;--border:#202225;
  --card-bg:#2f3136;--input-bg:#40444b;--hover-bg:#34373c;--input-disabled:#2f3136;--text-muted:#8e9297;--text-subtle:#72767d;
  --radius:8px;--shadow:0 2px 8px rgba(0,0,0,.15);--transition:.28s ease-in-out;
  --font-size-xs:.75rem;--font-size-sm:.875rem;--font-size-base:1rem;--font-size-lg:1.125rem;--font-size-xl:1.25rem;--font-size-2xl:1.5rem;--font-size-3xl:1.875rem;
  --line-height-tight:1.25;--line-height-normal:1.5;--line-height-relaxed:1.625;
  --font-weight-normal:400;--font-weight-medium:500;--font-weight-semibold:600;--font-weight-bold:700;
  --letter-spacing-tight:-.025em;--letter-spacing-normal:0;--letter-spacing-wide:.025em
}

html{font-size:100%;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}

body{
  font-family:'Inter','Roboto','Helvetica Neue',Arial,sans-serif;
  font-size:var(--font-size-base);font-weight:var(--font-weight-normal);
  line-height:var(--line-height-normal);letter-spacing:var(--letter-spacing-normal);
  background:var(--bg);color:var(--text);padding-bottom:env(safe-area-inset-bottom);
  -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;
  scroll-behavior:smooth;-webkit-overflow-scrolling:touch;overscroll-behavior-y:none;
  -ms-scroll-chaining:none;-ms-touch-action:pan-y;touch-action:pan-y;
  -webkit-tap-highlight-color:transparent
}

h1,h2,h3,h4,h5,h6{
  font-weight:var(--font-weight-semibold);line-height:var(--line-height-tight);
  letter-spacing:var(--letter-spacing-tight);color:var(--label);margin-bottom:.75rem
}

h1{font-size:var(--font-size-3xl);margin-bottom:1rem}
h2{font-size:var(--font-size-2xl);margin-bottom:.875rem}
h3{font-size:var(--font-size-xl);margin-bottom:.75rem}
h4{font-size:var(--font-size-lg);margin-bottom:.625rem}
h5,h6{font-size:var(--font-size-base);margin-bottom:.5rem}

p{font-size:var(--font-size-base);line-height:var(--line-height-normal);margin-bottom:1rem;color:var(--text)}
small{font-size:var(--font-size-sm);line-height:var(--line-height-normal);color:var(--text-muted)}

a{color:var(--primary);text-decoration:none;transition:color .2s ease}
a:hover{color:#7289da}
a:focus{outline:2px solid var(--primary);outline-offset:2px}

.container{max-width:800px;margin:0 auto;padding:24px}

.form-row{display:grid;grid-template-columns:repeat(2,1fr);gap:20px;margin-bottom:24px}
.form-group{display:flex;flex-direction:column;margin-bottom:8px}
.form-group label{
  font-size:var(--font-size-sm);font-weight:var(--font-weight-medium);
  line-height:var(--line-height-tight);color:var(--label);
  margin-bottom:8px;letter-spacing:var(--letter-spacing-wide)
}

.input-wrap input,.input-wrap select{
  height:44px;width:100%;padding:12px 16px;border:1px solid var(--border);
  border-radius:var(--radius);background:var(--input-bg);box-shadow:var(--shadow);
  color:var(--text);font-size:var(--font-size-base);line-height:1;
  transition:var(--transition);background-clip:padding-box;display:flex;align-items:center
}

.input-wrap select{padding-right:40px;appearance:none;cursor:pointer}

.input-wrap input:focus,.input-wrap select:focus{
  border-color:var(--primary);outline:none;
  box-shadow:0 0 0 2px rgba(88,101,242,.3);background:var(--hover-bg)
}

.input-wrap input:disabled,.input-wrap select:disabled{
  background:var(--input-disabled);color:var(--text-subtle);opacity:.7;
  cursor:not-allowed;box-shadow:none;border-color:#1e2124
}

.select-wrap{position:relative}
.select-wrap::after{
  content:"";position:absolute;right:10px;top:50%;width:16px;height:16px;
  transform:translateY(-50%);
  background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%23b9bbbe'><path d='M4 6l4 4 4-4z'/></svg>");
  background-repeat:no-repeat;background-size:contain;pointer-events:none;
  transition:transform .3s ease
}
.select-wrap:focus-within::after{transform:translateY(-50%) rotate(180deg)}

select.invalid-value,select.invalid-value:focus,input.invalid-value,input.invalid-value:focus{
  box-shadow:none;border-color:#c13537;transition:border-color .5s ease
}

.btn-row{display:flex;gap:16px;margin-top:32px}

.btn-row button{
  height:44px;padding:0 20px;border:none;border-radius:var(--radius);
  cursor:pointer;color:#fff;font-size:var(--font-size-base);
  font-weight:var(--font-weight-medium);line-height:var(--line-height-normal);
  letter-spacing:var(--letter-spacing-wide);transition:var(--transition)
}

#submitBtn{background:#4752c4} #submitBtn:hover{background:#3c45a5} #submitBtn:active,#submitBtn:focus{background:#343a8f}

#resetRekomenBtn{background:#5a6069}
#resetRekomenBtn:hover{background:#646b75}
#resetRekomenBtn:active,#resetRekomenBtn:focus{background:#6e7681}

#resetAllBtn{background:#c13537}
#resetAllBtn:hover{background:#a82d2f}
#resetAllBtn:active,#resetAllBtn:focus{background:#8f2527}

#testSpear{background:#cc8400}
#testSpear:hover{background:#b37400}
#testSpear:active,#testSpear:focus{background:#996300}

#testReaper{background:#7e3ff2}
#testReaper:hover{background:#6931d9}
#testReaper:active,#testReaper:focus{background:#5625b0}

button:disabled{opacity:.5;cursor:not-allowed;pointer-events:none}

#hasil,#recommendations{
  background:var(--hover-bg);padding:24px;margin-top:24px;
  border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow)
}

#hasil>p{font-size:var(--font-size-base);line-height:var(--line-height-normal);margin-bottom:1rem;color:var(--text)}

#hasil>p#breakdown-summary{
  font-size:var(--font-size-lg);font-weight:var(--font-weight-medium);
  line-height:var(--line-height-tight);color:var(--label);margin-bottom:1.25rem;
  padding:16px 20px;background:var(--card-bg);border:1px solid var(--border);
  border-radius:var(--radius)
}

#recommendations{display:grid;grid-template-columns:repeat(2,1fr);gap:24px}

.table-wrapper{
  width:100%;overflow-x:auto;border-radius:var(--radius);
  background:var(--card-bg);box-shadow:var(--shadow);margin:8px 0;
  border:1px solid var(--border)
}

#recommendations table{
  width:100%;border-collapse:collapse;background:transparent;
  border:none;table-layout:auto;font-variant-numeric:tabular-nums
}

#recommendations caption{
  text-align:left;padding:18px 20px 16px;background:var(--card-bg);
  border-bottom:1px solid var(--border);border-radius:var(--radius) var(--radius) 0 0;
  color:var(--label);font-size:var(--font-size-lg);font-weight:var(--font-weight-semibold);
  line-height:var(--line-height-tight);letter-spacing:var(--letter-spacing-tight)
}

#recommendations th{
  padding:12px 8px;text-align:center;background:var(--card-bg);color:var(--label);
  border-right:1px solid var(--border);border-bottom:1px solid var(--border);
  font-size:var(--font-size-sm);font-weight:var(--font-weight-semibold);
  line-height:var(--line-height-tight);letter-spacing:var(--letter-spacing-wide);
  text-transform:uppercase;font-variant:small-caps;word-wrap:break-word;
  hyphens:auto;max-width:60px;vertical-align:bottom
}

#recommendations td{
  padding:14px 10px;text-align:center;color:var(--text);
  border-right:1px solid var(--border);border-bottom:1px solid var(--border);
  font-size:var(--font-size-base);font-weight:var(--font-weight-medium);
  line-height:var(--line-height-normal);letter-spacing:var(--letter-spacing-normal);
  vertical-align:middle;background:var(--card-bg);transition:background-color .2s ease;
  white-space:nowrap;min-width:65px
}

#recommendations tbody tr:hover td{background:var(--hover-bg)}

#recommendations th:last-child,#recommendations td:last-child{border-right:none}
#recommendations tbody tr:last-child td{border-bottom:none}

#recommendations td span{
  display:inline-flex;align-items:center;justify-content:center;
  gap:4px;font-variant-numeric:tabular-nums
}

#recommendations td span::before{font-size:calc(var(--font-size-xs)*.4)}

span.up::before{content:"\25B2";color:#57f287;margin-right:1px;position:relative;top:.5px}
span.down::before{content:"\25BC";color:#3498db;margin-right:1px;position:relative;top:.5px}
span.neutral::before{content:"\25A0";color:var(--text-subtle);margin-right:1px;position:relative;top:.5px}

td.mult{
  font-weight:var(--font-weight-bold);color:var(--label);
  font-size:var(--font-size-lg);letter-spacing:var(--letter-spacing-tight)
}

td.delta{
  color:#57f287;font-weight:var(--font-weight-bold);
  font-size:var(--font-size-lg);letter-spacing:var(--letter-spacing-tight)
}

.sticky{
  position:fixed;bottom:calc(24px + env(safe-area-inset-bottom));right:24px;
  width:48px;height:48px;display:flex;align-items:center;justify-content:center;
  border-radius:var(--radius);box-shadow:var(--shadow);cursor:pointer;z-index:1000;
  border:none;background-repeat:no-repeat;background-position:center;background-size:26px;
  transition:transform .3s cubic-bezier(.4,0,.2,1),opacity .3s cubic-bezier(.4,0,.2,1)
}

.sticky.collapsed{opacity:0;pointer-events:none;z-index:999}
.sticky:not(.collapsed){opacity:1;pointer-events:auto}

#toggleStickyBtn.sticky{z-index:1001}
#toggleStickyBtn.sticky.collapsed{opacity:1!important;pointer-events:auto!important;z-index:1001!important}

#testSpear.sticky,#testReaper.sticky{background:center/26px no-repeat}

#testSpear.sticky{
  background-color:#cc8400;
  background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 24 24'%3E%3Cpath fill='%23fff' d='M17 10h-3.61l2.28 2.28zm0-8H7v1.61l6.13 6.13zm-13.59.86L2 4.27l5 5V13h3v9l3.58-6.15L17.73 20l1.41-1.41z'/%3E%3C/svg%3E")
}

#testReaper.sticky{
  background-color:#7e3ff2;
  background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 24 24'%3E%3Cpath fill='%23fff' d='M17 10h-3.61l2.28 2.28zm0-8H7v1.61l6.13 6.13zm-13.59.86L2 4.27l5 5V13h3v9l3.58-6.15L17.73 20l1.41-1.41z'/%3E%3C/svg%3E")
}

#testSpear.sticky.activated,#testReaper.sticky.activated{overflow:hidden;background:center/26px no-repeat}
#testSpear.sticky.activated{background-color:#cc8400}
#testReaper.sticky.activated{background-color:#7e3ff2}

#testSpear.sticky.activated::before,#testReaper.sticky.activated::before{
  content:'';position:absolute;top:-20px;left:-20px;width:88px;height:88px;
  background:conic-gradient(hsla(0,0%,100%,0) 0deg,hsla(42,100%,72%,.35) 40deg,hsla(42,100%,68%,.75) 80deg,hsla(255,100%,78%,.8) 120deg,hsla(255,100%,72%,.6) 160deg,hsla(220,100%,78%,.55) 200deg,hsla(220,100%,85%,.4) 240deg,hsla(0,0%,100%,.3) 280deg,hsla(0,0%,100%,.15) 320deg,hsla(0,0%,100%,0) 360deg);
  border-radius:50%;filter:blur(4px);opacity:.7;
  animation:rotate-shine 3s linear infinite;z-index:1
}

#testSpear.sticky.activated::after,#testReaper.sticky.activated::after{
  content:'';position:absolute;top:50%;left:50%;width:26px;height:26px;
  transform:translate(-50%,-50%);background:center/26px no-repeat;
  background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' height='48' viewBox='0 -960 960 960' width='48'%3E%3Cpath fill='%23fff' d='m460-272 186-268H520l81-280H340v360h120v188ZM400-80v-320H280v-480h400l-80 280h160L400-80Zm60-380H340h120Z'/%3E%3C/svg%3E");
  z-index:2
}

@keyframes rotate-shine{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}

#resetRekomenBtn.sticky{
  background:#5a6069 url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 24 24'%3E%3Cpath d='M17.65 6.35A7.95 7.95 0 0 0 12 4a8 8 0 1 0 7.9 9h-2.02a6 6 0 1 1-5.88-7c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z'/%3E%3C/svg%3E") center/26px no-repeat
}

#resetAllBtn.sticky{
  background:#c13537 url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 -960 960 960'%3E%3Cpath fill='%23fff' d='M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm400-600H280v520h400v-520ZM360-280h80v-360h-80v360Zm160 0h80v-360h-80v360ZM280-720v520-520Z'/%3E%3C/svg%3E") center/26px no-repeat
}

#breakdown-swap.sticky{
  background:#c13537 url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='white' viewBox='0 -960 960 960'%3E%3Cpath d='M769-88 645-212l-88 88-43-43q-17-17-17-42t17-42l199-199q17-17 42-17t42 17l43 43-88 88 123 124q9 9 9 21t-9 21l-64 65q-9 9-21 9t-21-9Zm111-636L427-271l19 20q17 17 17 42t-17 42l-43 43-88-88L191-88q-9 9-21 9t-21-9l-65-65q-9-9-9-21t9-21l124-124-88-88 43-43q-17-17 42-17t42 17l20 19 453-453h160v160ZM320-568l38-38 38-38-38 38-38 38Zm-42 42L80-724v-160h160l198 198-42 42-181-180h-75v75l180 181-42 42Zm105 212 437-435v-75h-75L308-389l75 75Zm0 0-37-38-38-37 38 37 37 38Z'/%3E%3C/svg%3E") center/26px no-repeat;
  color:transparent;text-shadow:none;appearance:none;width:48px;max-width:48px;
  min-width:48px;padding:0;text-indent:-9999px
}

#backToHasilBtn.sticky{
  background:#4a9b5e url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 24 24'%3E%3Cpath d='M4 12l1.41 1.41L11 7.83V20h2V7.83l5.59 5.58L20 12l-8-8-8 8z'/%3E%3C/svg%3E") center/26px no-repeat
}

#toggleStickyBtn.sticky.active{
  background:var(--primary) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%23fff' d='M18.3 5.71L12 12l-6.3-6.29-1.41 1.41L10.59 13.4l-6.3 6.3 1.41 1.41L12 14.83l6.29 6.29 1.42-1.41-6.3-6.3 6.3-6.29z'/%3E%3C/svg%3E") center/26px no-repeat
}

#toggleStickyBtn.sticky{
  background:var(--primary) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%23fff' d='M3 6h18v2H3V6zm0 5h18v2H3v-2zm0 5h18v2H3v-2z'/%3E%3C/svg%3E") center/26px no-repeat
}

.breakdown-swap-wrapper{display:flex;align-items:center;gap:12px;margin:20px 0}

.breakdown-swap-wrapper label{
  color:var(--label);white-space:nowrap;font-size:var(--font-size-sm);
  font-weight:var(--font-weight-medium);line-height:var(--line-height-normal)
}

.breakdown-swap{
  appearance:none;
  background:var(--input-bg) url("data:image/svg+xml;utf8,<svg fill='%23b9bbbe' height='20' viewBox='0 0 24 24' width='20' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/></svg>") no-repeat right 12px center/16px;
  border:1px solid var(--border);border-radius:var(--radius);padding:10px 36px 10px 16px;
  cursor:pointer;outline:none;transition:border-color .28s ease-in-out,box-shadow .28s ease-in-out,background-color .28s ease-in-out;
  width:180px;max-width:50%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;
  color:var(--text);font-size:var(--font-size-sm);line-height:var(--line-height-normal)
}

.breakdown-swap:hover{border-color:var(--text-subtle);background-color:var(--hover-bg)}
.breakdown-swap:focus{border-color:var(--primary);box-shadow:0 0 0 2px rgba(88,101,242,.3);background:var(--hover-bg)}

#multiplier-breakdown{
  background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);
  padding:0 20px 20px;color:var(--text);margin:8px 0
}

#multiplier-breakdown>p:first-of-type{
  color:var(--label);margin-bottom:16px;font-size:var(--font-size-lg);
  font-weight:var(--font-weight-semibold);line-height:var(--line-height-tight);padding-top:16px
}

#multiplier-breakdown>p:nth-of-type(2){
  margin-bottom:20px;background:var(--input-bg);padding:14px 18px;
  border-radius:var(--radius);border:1px solid var(--border);
  font-variant-numeric:tabular-nums;color:var(--label);
  font-size:var(--font-size-lg);line-height:var(--line-height-normal);
  font-weight:var(--font-weight-semibold)
}

#multiplier-breakdown blockquote.noted{
  margin:16px 0;padding:14px 18px;border:1px solid var(--border);
  background:var(--input-bg);color:var(--text);border-radius:var(--radius);
  font-size:var(--font-size-sm);line-height:var(--line-height-relaxed)
}

.factor-breakdown{margin:0;padding:0;list-style:none;color:var(--text)}

.factor-breakdown>li{
  margin:14px 0;font-size:var(--font-size-base);line-height:var(--line-height-relaxed);
  color:var(--label);font-weight:var(--font-weight-medium)
}

.factor-breakdown li ul{
  margin:12px 0 0 16px;padding-left:16px;list-style:none;
  color:var(--text);border-left:2px solid var(--border)
}

.factor-breakdown li ul li{
  margin:10px 0;font-size:var(--font-size-sm);line-height:var(--line-height-relaxed);
  font-weight:var(--font-weight-normal)
}

.factor-breakdown li ul li.note{
  color:var(--text-muted);font-style:italic;padding-left:0;margin-left:0;
  font-size:var(--font-size-xs)
}

.factor-breakdown>li span.neutral-flag{
  color:var(--text-subtle);margin-left:8px;
  font-family:ui-monospace,'Fira Code',monospace;font-size:var(--font-size-xs)
}

#howto{
  margin:0 auto 24px;width:100%;border:1px solid var(--border);
  border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden
}

#howto summary{
  display:flex;align-items:center;justify-content:space-between;
  padding:16px 16px 16px 20px;cursor:pointer;color:var(--label);
  background:var(--card-bg);border:none;
  box-shadow:inset 0 1px 3px rgba(0,0,0,.1);border-radius:var(--radius) var(--radius) 0 0;
  font-size:var(--font-size-base);font-weight:var(--font-weight-medium);
  line-height:var(--line-height-normal);transition:background-color .2s ease
}

#howto summary:hover{background:var(--hover-bg)}
#howto summary::-webkit-details-marker{display:none}
#howto summary span{color:var(--label)}

#howto summary::after{
  content:"";flex-shrink:0;width:16px;height:16px;margin-left:12px;
  background:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%23dcddde'><path d='M4 6l4 4 4-4z'/></svg>") center/16px no-repeat;
  transition:transform .3s ease
}

#howto[open] summary{border-radius:var(--radius) var(--radius) 0 0}
#howto[open] summary::after{transform:rotate(180deg)}

#howto .body{
  padding:16px 20px 20px;background:var(--card-bg);border:none;
  border-top:1px solid var(--border);box-shadow:inset 0 1px 3px rgba(0,0,0,.1);
  border-radius:0 0 var(--radius) var(--radius);overflow:hidden;max-height:0;transition:max-height .4s ease
}

#howto .content{overflow:hidden;transition:max-height .4s ease;max-height:0}

#howto ol{counter-reset:step;margin:0;padding:0;list-style:none}

#howto ol>li{
  position:relative;margin:18px 0;padding-left:36px;color:var(--label);
  font-size:var(--font-size-base);font-weight:var(--font-weight-medium);
  line-height:var(--line-height-relaxed)
}

#howto ol>li::before{
  counter-increment:step;content:counter(step)".";position:absolute;left:0;top:0;
  color:var(--primary);font-weight:var(--font-weight-bold);
  font-size:var(--font-size-lg);line-height:var(--line-height-tight)
}

#howto ol>li strong{color:var(--label);font-weight:var(--font-weight-semibold)}

#howto ul{margin:12px 0 0;padding:0;list-style:none}

#howto ul li{
  position:relative;margin:10px 0;padding-left:24px;color:var(--text);
  font-size:var(--font-size-sm);font-weight:var(--font-weight-normal);
  line-height:var(--line-height-normal)
}

#howto ul li::before{
  content:"\2022";position:absolute;left:0;top:0;color:var(--primary);
  font-weight:var(--font-weight-medium)
}

#howto li ul{margin:8px 0 0;padding-left:16px;border-left:2px solid var(--border)}

#howto li ul li{
  margin:6px 0;font-size:var(--font-size-xs);color:var(--text-muted);padding-left:20px
}

#howto li ul li::before{content:"\25E6";color:var(--text-subtle);font-size:var(--font-size-sm)}

#howto li.muted{color:var(--text-muted);font-style:italic;font-size:var(--font-size-sm)}
#howto em{color:var(--text-muted);font-style:italic}

code{
  font-family:'Fira Code',ui-monospace,monospace;background:var(--input-bg);
  color:var(--label);padding:3px 6px;border-radius:4px;
  font-size:var(--font-size-sm);border:1px solid var(--border)
}

blockquote code{background:var(--card-bg)}

#version{
  margin-bottom:32px;display:flex;justify-content:space-between;
  align-items:flex-start;gap:16px
}

#version p{
  margin-bottom:0;font-size:var(--font-size-xs);
  line-height:var(--line-height-normal);color:var(--text-muted)
}

#version p:first-child{display:flex;align-items:center;gap:6px}

#version p:last-child{
  font-style:italic;color:var(--text-subtle);text-align:right;white-space:nowrap
}

#version button,#version a,.toggle-precision,a.job-sim{
  font-family:'Fira Code',ui-monospace,monospace;text-decoration:none;
  outline:none;border:0;background:none;color:#5865f2;
  font-size:var(--font-size-xs);line-height:var(--line-height-normal);
  font-weight:var(--font-weight-medium);cursor:pointer;transition:color .2s ease
}
a.job-sim { 
  color: #ff8c42;
  display: inline-block;
  outline: none;
  background: transparent;
  border: none;
  text-decoration: underline dotted;
}
a.job-sim:hover { color: #ff6b1a; }
a.job-sim:visited { color: #ffa726; }

#version a{font-weight:var(--font-weight-medium)}

#version button:hover,#version a:hover,.toggle-precision:hover{color:#6366f1}
#version p i {
  color: var(--label);
}
.toggle-precision{
  padding:0 4px;text-decoration:underline dotted;font-size:var(--font-size-base);
  font-family:inherit;font-weight:inherit
}

.footer{
  margin-top:32px;color:var(--text-muted);font-size:var(--font-size-xs);
  line-height:var(--line-height-relaxed);text-align:left
}

svg{display:inline-block;margin:0 2px -2px 0}

hr.separ{
  margin:20px auto 16px;border:none;height:2px;background-color:var(--border);
  border-radius:var(--radius)
}

.snackbar{
  position:fixed;left:50%;transform:translateX(-50%) translateY(30px);
  bottom:16px;background:rgba(0,0,0,.8);color:#fff;padding:10px 14px;
  border-radius:var(--radius);opacity:0;pointer-events:none;text-align:center;
  box-shadow:var(--shadow);font-size:var(--font-size-sm);
  line-height:var(--line-height-normal);transition:opacity .3s ease,transform .3s ease
}

.snackbar.show{
  opacity:1;pointer-events:auto;transform:translateX(-50%) translateY(0);
  animation:snackbarBounce .4s ease
}

@keyframes snackbarBounce{
  0%{transform:translateX(-50%) translateY(30px)}
  60%{transform:translateX(-50%) translateY(-6px)}
  80%{transform:translateX(-50%) translateY(3px)}
  100%{transform:translateX(-50%) translateY(0)}
}

.changelog{position:relative;max-width:70%;margin:auto;color:var(--text)}

.changelog .header-log{position:relative;margin-bottom:1.5rem}

.changelog h2{
  margin-bottom:1.2rem;color:var(--primary);border-bottom:2px solid var(--border);
  padding-bottom:.6rem;font-size:var(--font-size-2xl);font-weight:var(--font-weight-semibold);
  line-height:var(--line-height-tight);letter-spacing:var(--letter-spacing-tight)
}

.changelog .version{margin-bottom:2rem}

.changelog .version h3{
  color:var(--label);margin:0 0 1rem;font-size:var(--font-size-xl);
  font-weight:var(--font-weight-medium);line-height:var(--line-height-tight)
}

.changelog .version ul{list-style:none;padding-left:.25rem;margin:0}

.changelog .version ul li{
  position:relative;margin:.75rem 0;padding-left:1.25rem;
  font-size:var(--font-size-base);line-height:var(--line-height-relaxed);color:var(--text)
}

.changelog .version ul li::before{content:"\2022";color:var(--primary);position:absolute;left:0}

.changelog .version ul ul{margin-top:.5rem;padding-left:1rem;border-left:1px solid var(--border)}

.changelog .version ul ul li{font-size:var(--font-size-sm);margin:.5rem 0}

.changelog .sub-cats{
  display:inline-block;font-weight:var(--font-weight-semibold);
  color:var(--label);font-size:var(--font-size-base)
}

#log{
  position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.6);
  z-index:1000;align-items:center;justify-content:center;padding:24px;display:none
}

#log.show,#log[style*="flex"]{display:flex!important}

#log .changelog{
  background:var(--card-bg);width:100%;max-width:70%;max-height:500px;
  padding:24px;border-radius:var(--radius);box-shadow:0 4px 20px rgba(0,0,0,.4);
  animation:fadeInUp .3s ease;position:relative;overflow-y:auto;
  border:1px solid var(--border)
}

#log .close{
  position:absolute;top:16px;right:16px;color:var(--text-subtle);cursor:pointer;
  transition:var(--transition);font-size:var(--font-size-lg);font-weight:var(--font-weight-bold);
  width:24px;height:24px;display:flex;align-items:center;justify-content:center;
  border-radius:4px
}

#log .close:hover{color:var(--label);background:var(--hover-bg)}

.hidden{display:none!important}

.tooltip-wrap, .dmgstack-tips {
  position: absolute;
  z-index: 9999;
  background: rgba(0, 0, 0, 0.85);
  color: #b9bbbe;
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
  font-size: 12px;
  line-height: 1.5;
  padding: 12px 16px;
  max-width: 480px;
  
  /* Smooth transition setup */
  opacity: 0;
  transform: translateY(-12px) scale(0.95);
  transition: all 0.2s cubic-bezier(0.2, 0, 0.2, 1);
  pointer-events: none;
  
  /* Performance optimizations */
  will-change: transform, opacity;
  backface-visibility: hidden;
}

.tooltip-wrap.visible, .dmgstack-tips.visible {
  opacity: 1;
  transform: translateY(0) scale(1);
  pointer-events: auto;
}

.tooltip-wrap strong, .dmgstack-tips strong {
  color: #dcddde;
  font-weight: 600;
}

.tooltip-button, .dmgstack-tooltip {
  border: none;
  background: transparent;
  padding-top: 0;
  margin: 0;
  display: inline-flex;
  align-items: end;
  justify-content: center;
  cursor: pointer;
  position: absolute;
}

.tooltip-button:focus,
.dmgstack-tooltip:focus,
.tooltip-button:active,
.dmgstack-tooltip:active {
  outline: none;
  border: none;
  box-shadow: none;
  background: transparent;
}
/*
.tooltip-button:focus-visible,
.dmgstack-tooltip:focus-visible {
  outline: 2px solid #5865f2;
  outline-offset: 2px;
  border-radius: 3px;
}
*/
.tooltip-button svg, .dmgstack-tooltip svg {

  margin-left: 3px;
  width: 16px;
  height: 16px;
  pointer-events: none;
  fill: #b9bbbe;
  transition: fill 0.15s ease, transform 0.15s ease;
}

.tooltip-button:hover svg, .dmgstack-tooltip:hover svg {
  fill: #5865f2;
  transform: scale(1.1);
}

.tooltip-button:active svg, .dmgstack-tooltip:active svg {
  transform: scale(0.95);
}
@keyframes fadeInUp{
  from{opacity:0;transform:translateY(20px)}
  to{opacity:1;transform:translateY(0)}
}

@keyframes pulseFlashAnim{
  0%{opacity:0;transform:scale(.8)}
  25%{opacity:.6;transform:scale(1.2)}
  50%{opacity:.8;transform:scale(1.4)}
  75%{opacity:.4;transform:scale(1.6)}
  100%{opacity:0;transform:scale(1.8)}
}

@keyframes lightningFlicker{
  0%{filter:brightness(1)}
  15%{filter:brightness(1.8) contrast(1.3)}
  18%{filter:brightness(.9) contrast(1)}
  22%{filter:brightness(2.2) contrast(1.5)}
  25%{filter:brightness(1.1) contrast(1)}
  35%{filter:brightness(1.6) contrast(1.2)}
  40%{filter:brightness(1) contrast(1)}
  50%{filter:brightness(1.9) contrast(1.4)}
  55%{filter:brightness(1.2) contrast(1)}
  65%{filter:brightness(1.5) contrast(1.1)}
  75%{filter:brightness(1) contrast(1)}
  85%{filter:brightness(1.3) contrast(1.1)}
  100%{filter:brightness(1) contrast(1)}
}

@keyframes lightningAnim{
  0%{opacity:0;transform:scale(.8)}
  30%{opacity:1;transform:scale(1.3)}
  70%{opacity:.8;transform:scale(1.5)}
  100%{opacity:0;transform:scale(1.8)}
}

@media (max-width:800px){
  .container{padding:20px}
  .form-row{grid-template-columns:1fr;gap:16px;margin-bottom:20px}
  .form-group{margin-bottom:0}
  .btn-row{flex-direction:column;gap:12px;margin-top:24px}
  #recommendations{grid-template-columns:1fr;gap:20px}
  #hasil,#recommendations{padding:20px;margin-top:20px}
  #howto summary{padding:12px 12px 12px 16px;font-size:var(--font-size-sm)}
  #howto .body{padding:12px 16px 16px}
  #howto ol>li{margin:16px 0;font-size:var(--font-size-sm);padding-left:32px}
  #howto ol>li::before{font-size:var(--font-size-base)}
  #howto ul li{font-size:var(--font-size-xs)}
  #recommendations caption{font-size:var(--font-size-base);padding:14px 16px 12px}
  #recommendations th{padding:12px 10px;font-size:var(--font-size-sm)}
  #recommendations td{padding:10px 8px;font-size:var(--font-size-sm)}
  td.mult,td.delta{font-size:var(--font-size-base)}
}

@media (max-width:768px){
  .tooltip-wrap,.dmgstack-tips{max-width:280px;font-size:11px;padding:8px 12px}
}

@media (max-width:480px){
  .container{padding:16px}
  #multiplier-breakdown{background:var(--card-bg);box-shadow:var(--shadow)}
  #hasil,#recommendations{background:transparent;padding:0;border:none;box-shadow:none;margin-top:16px}
  #hasil>p#breakdown-summary,#multiplier-breakdown .noted{
    background:var(--bg);box-shadow:inset 0 0 5px 2px rgba(0,0,0,.3);
    padding:16px 18px;margin-bottom:16px;border-radius:var(--radius);border:1px solid var(--border)
  }
  #log{padding:16px}
  #log .changelog{max-width:80%;max-height:500px;padding:20px}
  .changelog h2{font-size:var(--font-size-xl);margin-bottom:1rem;padding-bottom:.5rem}
  .changelog .version h3{font-size:var(--font-size-base);margin-bottom:.5rem}
  .changelog .version ul li{font-size:var(--font-size-sm);margin:.375rem 0}
  .breakdown-swap-wrapper{justify-content:space-between;gap:8px}
  .breakdown-swap-wrapper label{max-width:35%;font-size:var(--font-size-xs)}
  .breakdown-swap{max-width:60%;font-size:var(--font-size-xs)}
  .sticky{bottom:calc(20px + env(safe-area-inset-bottom));right:20px}
  #recommendations caption{font-size:var(--font-size-base);padding:12px 14px}
  #recommendations th{
    padding:8px;font-size:var(--font-size-xs);white-space:nowrap;
    overflow:hidden;text-overflow:ellipsis
  }
  #recommendations td{padding:8px;font-size:var(--font-size-xs)}


.table-wrapper::-webkit-scrollbar {
  display: none; /* untuk Chrome, Safari, Edge */
}

.table-wrapper {
  -ms-overflow-style: none;  /* untuk IE dan Edge lama */
  scrollbar-width: none;     /* untuk Firefox */
}
  td.mult,td.delta{font-size:var(--font-size-sm)}
  .factor-breakdown>li{font-size:var(--font-size-sm)}
  .factor-breakdown li ul li{font-size:var(--font-size-xs)}
  #howto summary{padding:10px 10px 10px 14px;font-size:var(--font-size-sm)}
  #howto .body{padding:10px 14px 14px;overflow:hidden;max-height:0;transition:max-height .4s ease}
  #howto ol>li{margin:14px 0;font-size:var(--font-size-sm);padding-left:28px}
  #howto ol>li::before{font-size:var(--font-size-base)}
  #howto ul li{font-size:var(--font-size-xs);padding-left:20px}
  #howto li ul li{font-size:var(--font-size-xs);padding-left:18px}
  .tooltip-wrap,.dmgstack-tips{max-width:280px;font-size:11px;padding:8px 12px}
  td.build {
  white-space:nowrap;
    overflow:hidden;text-overflow:ellipsis;padding:0 12px!important;font-size: 25px;
}
}</style>
<script>// head start
(function() {
  'use strict';
  
  // Safe property getter with dot notation
  if (typeof window.safeGet !== 'function') {
    window.safeGet = function(obj, path) {
      if (!path || typeof path !== 'string') return undefined;
      try {
        return path.split('.').reduce(function(acc, key) {
          return (acc && acc[key] !== undefined) ? acc[key] : undefined;
        }, obj);
      } catch (e) {
        return undefined;
      }
    };
  }
  
  // Touch handler initialization
  const initTouchHandler = function() {
    const container = document.getElementById("altsim");
    if (!container) return;
    
    let lastTouchTime = 0;
    
    // Better performance on iOS with passive listeners
    container.addEventListener("touchstart", function() {
      lastTouchTime = Date.now();
    }, { passive: true, capture: true });
    
    container.addEventListener("click", function(e) {
      if (Date.now() - lastTouchTime < 300) {
        const target = e.target;
        
        // Only block clicks on locked input wrappers - fully automatic
        if (isInsideLockedInputWrap(target)) {
          e.stopImmediatePropagation();
          e.preventDefault();
        }
      }
    }, { capture: true });
  };
  
  // Check if element is inside a locked input wrapper
  const isInsideLockedInputWrap = function(element) {
    let current = element;
    while (current && current !== document.body) {
      if (current.classList &&
        current.classList.contains('input-wrap') &&
        current.classList.contains('locked')) {
        return true;
      }
      current = current.parentNode;
    }
    return false;
  };
  
  // Snackbar position manager for responsive design
  const initSnackbarManager = function() {
    const reposition = function() {
      const sb = document.querySelector('.snackbar.show');
      if (sb) {
        if (!sb.hasAttribute('data-compat-bottom')) {
          const cur = sb.style.bottom;
          if (cur) sb.setAttribute('data-compat-bottom', cur);
        }
        sb.style.bottom = sb.getAttribute('data-compat-bottom') || '20px';
      }
    };
    window.addEventListener('resize', reposition, { passive: true });
  };
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener("DOMContentLoaded", function() {
      initTouchHandler();
      initSnackbarManager();
    });
  } else {
    initTouchHandler();
    initSnackbarManager();
  }
})();
// head end
</script>

<!-- end compat-shim -->

</head>
 <body>
   <div id="top"></div>
<div class="container" id="altsim">
<div id="version">
  <p><a href="https://discord.gg/9j2WnTAnMu" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="evenodd" clip-rule="evenodd" viewBox="0 0 512 512"><path fill="#5865F2" d="M105 0h302c57.928.155 104.845 47.072 105 104.996V407c-.155 57.926-47.072 104.844-104.996 104.998L105 512C47.074 511.844.156 464.926.002 407.003L0 105C.156 47.072 47.074.155 104.997 0H105z"/><g data-name=""><g data-name="Discord Logos"><path fill="#fff" fill-rule="nonzero" d="M368.896 153.381a269.506 269.506 0 00-67.118-20.637 186.88 186.88 0 00-8.57 17.475 250.337 250.337 0 00-37.247-2.8c-12.447 0-24.955.946-37.25 2.776-2.511-5.927-5.427-11.804-8.592-17.454a271.73 271.73 0 00-67.133 20.681c-42.479 62.841-53.991 124.112-48.235 184.513a270.622 270.622 0 0082.308 41.312c6.637-8.959 12.582-18.497 17.63-28.423a173.808 173.808 0 01-27.772-13.253c2.328-1.688 4.605-3.427 6.805-5.117 25.726 12.083 53.836 18.385 82.277 18.385 28.442 0 56.551-6.302 82.279-18.387 2.226 1.817 4.503 3.557 6.805 5.117a175.002 175.002 0 01-27.823 13.289 197.847 197.847 0 0017.631 28.4 269.513 269.513 0 0082.363-41.305l-.007.007c6.754-70.045-11.538-130.753-48.351-184.579zM201.968 300.789c-16.04 0-29.292-14.557-29.292-32.465s12.791-32.592 29.241-32.592 29.599 14.684 29.318 32.592c-.282 17.908-12.919 32.465-29.267 32.465zm108.062 0c-16.066 0-29.267-14.557-29.267-32.465s12.791-32.592 29.267-32.592c16.475 0 29.522 14.684 29.241 32.592-.281 17.908-12.894 32.465-29.241 32.465z" data-name="Discord Logo - Large - White"/></g></g></svg>Ragnarok X University</a></p>
  <p><i>v1.1.1</i> [<button id="openLog" type="button">Changelog</button>]</p>

</div>
<details id="howto">
  <summary>
    <span>How to Use</span>
  </summary>
  <div class="body">
<ol>
  <li>
    <strong>Dropdowns</strong>
    <ul>
      <li>Set <strong>Attack Type</strong>, <strong>Weapon</strong>, and <strong>Weapon Attribute</strong>.</li>
      <li>
        For <strong>MVP/MINI</strong>:
        <ul>
          <li>
            Selecting a specific MVP/Mini will auto <strong>sync and lock</strong> its <strong>size, race, and attribute</strong>.
            <em>(Example: <strong>Phreeoni = Large / Brute / Neutral</strong>. The fields stay fixed and you’ll need to fill the related numbers.)</em>
            <ul>
              <li>
                If you only have a <strong>Race enchant (or only Attribute)</strong>, just set the other field to <code>0</code>.
                <ul>
                  <li>Example: <strong>Brute 0 / Neutral 20</strong></li>
                  <li>Example: <strong>Brute 30 / Neutral 0</strong></li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Selecting an <strong>Average Lv.</strong> can skip or set target race/attribute manually.</li>
          <li><em>If you don’t have race and/or attribute enchants, better go with <strong>Average Lv. Boss</strong> and skip those.</em></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    Equipment
    <ul>
      <li>Choose the set you’re using <strong>(Vesper / Blue / White)</strong>.</li>
    </ul>
  </li>
  <li>
    <strong>Stat Inputs</strong>
    <ul>
      <li>Enter your stats exactly as shown in game.</li>
      <li>
        Extra: <strong>Final DMG Bonus %</strong>
        <ul>
          <li>
            <strong><s>F. P/M DMG BONUS</s></strong>
            <ul>
              <li>Shown in <strong>detailed stats</strong> as <strong>Final Damage Stack / Final Damage Bonus</strong>. Make sure <strong>no buffs</strong> are on. If you don’t see it, set <strong>0</strong>.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Only <strong>numbers</strong>, don’t type <strong><s>“%”</s></strong>.</li>
      <li><strong>Decimals</strong> are fine. <em>(Example: <strong>888.88</strong>)</em></li>
    </ul>
  </li>
  <li>
    <strong>Calculate</strong>
    <ul>
      <li>Once everything is filled, hit <strong>Calculate</strong>.</li>
    </ul>
  </li>
  <li>
    <strong>Results</strong>
    <ul>
      <li>You’ll see <strong>base multiplier</strong> and a breakdown of your stats.</li>
    </ul>
  </li>
  <li>
    Simulate Flash
    <ul>
      <li>
        <strong>Spear of Eternity</strong> and <strong>Reaper Scythe</strong>.
        <ul>
          <li><em>Each has 10s duration / 20s cooldown with <strong>+84% or +28%</strong> bonus. This tool normalize <strong>to 42</strong> and <strong>14</strong> for <strong>100% uptime</strong>(?)</em></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <strong>Swap Target</strong>
    <ul>
      <li>Lets you <strong>switch bosses</strong> without starting over.</li>
      <li>If the new boss has <strong>different size/race/element</strong>, the inputs unlock and you’ll need to <strong>re-input stats</strong>.</li>
      <li>
        If it’s the
        <strong>
          same type</strong>, the calc <strong>updates instantly</strong>.
      </li>
      <li>
        <em>Examples:</em>
        <ul>
          <li><strong>Phreeoni 140 → Deviling 150</strong> → re-enter <strong>Medium / Demon / Shadow</strong>.</li>
          <li><strong>Phreeoni 140 → Phreeoni 150</strong> → auto updates, no changes.</li>
          <li><strong>Phreeoni 150 → Avg. 140</strong> → race/element are <strong>cleared</strong>, treated as average <strong>Large Boss Lv.140</strong>.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <strong>Recommendations</strong>
    <ul>
      <li>At the bottom you’ll see a table with recommended <strong><s>ratios</s></strong> stat allocations.</li>
      <li>Hit <strong>Refresh</strong> to roll new sets until you see one you can actually use.</li>
    </ul>
  </li>
</ol>
  </div>
</details>
  <div class="form-row">
    <div class="form-group">
      <label for="penCritSelect" id="atkTypeLabel">Attack Type</label>
      <div class="input-wrap select-wrap">
        <select id="penCritSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="weaponSelect" id="weaponLabel">Weapon Type</label>
      <div class="input-wrap select-wrap">
        <select id="weaponSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="weaponElementSelect" id="wElemLabel">Weapon Attribute</label>
      <div class="input-wrap select-wrap">
        <select id="weaponElementSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="targetDefSelect" id="tDefLabel">MVP/MINI</label>
      <div class="input-wrap select-wrap">
        <select id="targetDefSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="targetSizeSelect" id="tSizeLabel">Target Size</label>
      <div class="input-wrap select-wrap">
        <select id="targetSizeSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="targetRaceSelect" id="tRaceLabel">Target Race<button type="button" id="targetRaceTips" class="tooltip-button"><svg xmlns="http://www.w3.org/2000/svg" height="70" fill="#dcddde" viewBox="0 -960 960 960" width="70"><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg></button></label>
      <div class="input-wrap select-wrap">
        <select id="targetRaceSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="targetElementSelect" id="tAttrLabel">Target Attribute<button type="button" id="targetAttrTips" class="tooltip-button"><svg xmlns="http://www.w3.org/2000/svg" height="70" fill="#dcddde" viewBox="0 -960 960 960" width="70"><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg></button></label>
      <div class="input-wrap select-wrap">
        <select id="targetElementSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="vesperSet" id="vesperSetLabel">Vesper Set</label>
      <div class="input-wrap select-wrap">
        <select id="vesperSet"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="blueSet" id="blueSetLabel">Blue Set</label>
      <div class="input-wrap select-wrap">
        <select id="blueSet"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="whiteSet" id="whiteSetLabel">White Set (110*3)</label>
      <div class="input-wrap select-wrap">
        <select id="whiteSet"></select>
      </div>
    </div>
  </div>

  <div class="form-row">
    <div class="form-group pen-group">
      <label for="pen" id="penLabel">Final P M PEN %</label>
      <div class="input-wrap">
        <input id="pen" type="number" min="1" max="3333" disabled placeholder="total converted raw pen + fpen %" />
      </div>
    </div>
    <div class="form-group crit-group">
      <label for="crit" id="critLabel">Critical DMG Bonus %</label>
      <div class="input-wrap">
        <input id="crit" type="number" min="1" max="3333" disabled placeholder="crit damage bonus %" />
      </div>
    </div>
    <div class="form-group">
      <label for="dmg" id="dmgLabel">Final P M DMG Bonus %</label>
      <div class="input-wrap">
        <input id="dmg" type="number" min="1" max="2222" placeholder="input f. p/m dmg bns..." />
      </div>
    </div>
    <div class="form-group">
      <label for="elemEnhance" id="elemEnhLabel">Element Enhance %</label>
      <div class="input-wrap">
        <input id="elemEnhance" type="number" min="1" max="2222"/>
      </div>
    </div>
    <div class="form-group">
      <label for="sizeEnhance" id="sizeLabel">DMG to Size %</label>
      <div class="input-wrap">
        <input id="sizeEnhance" type="number" min="1" max="2222"/>
      </div>
    </div>
    <div class="form-group">
      <label for="race">DMG to <span id="raceLabel">Race</span><button type="button" id="dmgRaceTips" class="tooltip-button"><svg xmlns="http://www.w3.org/2000/svg" height="70" fill="#dcddde" viewBox="0 -960 960 960" width="70"><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg></button></label>
      <div class="input-wrap">
        <input id="race" type="number" min="0" max="888" disabled />
      </div>
    </div>
    <div class="form-group">
      <label for="attr">DMG to <span id="attrLabel"></span> Attribute<button type="button" id="dmgAttrTips" class="tooltip-button"><svg xmlns="http://www.w3.org/2000/svg" height="70" fill="#dcddde" viewBox="0 -960 960 960" width="70"><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg></button></label>
      <div class="input-wrap">
        <input id="attr" type="number" min="0" max="888" disabled />
      </div>
    </div>
    <div class="form-group">
      <label for="dmgStack" id="dmgStackLabel">Extra: Final DMG Bonus<button type="button" id="dmgStackTips" class="dmgstack-tooltip"><svg xmlns="http://www.w3.org/2000/svg" height="70" fill="#dcddde" viewBox="0 -960 960 960" width="70"><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg></button></label>
      <div class="input-wrap">
        <input id="dmgStack" type="number" min="0" max="888" placeholder="input final dmg bonus%..." />
        
      </div>
    </div>

  </div>

  <div class="btn-row">
    <button id="submitBtn" type="button">Calculate</button>
    <button id="testSpear" type="button" disabled>Simulate Spear</button>
    <button id="testReaper" type="button" disabled>Simulate Reaper</button>
    <button class="reset-recommendations reset-rek-btn" id="resetRekomenBtn" type="button" disabled>Refresh Recommendations</button>
    <button id="resetAllBtn" type="button" disabled>Reset All</button>
  </div>

  <div id="hasil">
    Input stats to see the result...</div>

  <div id="recommendations">
    Recommended stat allocations will show up here. This tool randomizes your stats to find the best combination for higher output.
  </div>
  <div class="footer"><i>Have an issue?</i><br/>
  Silja [Odin-Nastia] <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="evenodd" clip-rule="evenodd" viewBox="0 0 512 512"><path fill="#5865F2" d="M105 0h302c57.928.155 104.845 47.072 105 104.996V407c-.155 57.926-47.072 104.844-104.996 104.998L105 512C47.074 511.844.156 464.926.002 407.003L0 105C.156 47.072 47.074.155 104.997 0H105z"/><g data-name=""><g data-name="Discord Logos"><path fill="#fff" fill-rule="nonzero" d="M368.896 153.381a269.506 269.506 0 00-67.118-20.637 186.88 186.88 0 00-8.57 17.475 250.337 250.337 0 00-37.247-2.8c-12.447 0-24.955.946-37.25 2.776-2.511-5.927-5.427-11.804-8.592-17.454a271.73 271.73 0 00-67.133 20.681c-42.479 62.841-53.991 124.112-48.235 184.513a270.622 270.622 0 0082.308 41.312c6.637-8.959 12.582-18.497 17.63-28.423a173.808 173.808 0 01-27.772-13.253c2.328-1.688 4.605-3.427 6.805-5.117 25.726 12.083 53.836 18.385 82.277 18.385 28.442 0 56.551-6.302 82.279-18.387 2.226 1.817 4.503 3.557 6.805 5.117a175.002 175.002 0 01-27.823 13.289 197.847 197.847 0 0017.631 28.4 269.513 269.513 0 0082.363-41.305l-.007.007c6.754-70.045-11.538-130.753-48.351-184.579zM201.968 300.789c-16.04 0-29.292-14.557-29.292-32.465s12.791-32.592 29.241-32.592 29.599 14.684 29.318 32.592c-.282 17.908-12.919 32.465-29.267 32.465zm108.062 0c-16.066 0-29.267-14.557-29.267-32.465s12.791-32.592 29.267-32.592c16.475 0 29.522 14.684 29.241 32.592-.281 17.908-12.894 32.465-29.241 32.465z" data-name="Discord Logo - Large - White"/></g></g></svg>sanditama#7047</div>
</div>

<div class="log" id="log">
  <div class="changelog">
    <div class="header-log"><span class="close" id="closeLog">&times;</span>
    <h2>Changelog</h2>
    </div>
    <div class="version">
  <h3>[Unreleased]</h3>
  <ul>
    <li>MINIGAME!</li>
  </ul>
</div>
<div class="version">
  <h3>[v1.1.1] - Sept 21, 2025</h3>
  <ul>
    <li><span class="sub-cats">Added</span>
      <ul>
        <li>Tooltips (help) for inputing data</li>
      </ul>
    </li>
    <!--li><span class="sub-cats">Updated</span>
      <ul>
      </ul>
    </li-->
    <li><span class="sub-cats">Improved</span>
      <ul>
        <li>Input validation</li>
        <li>optimize flow n logic 3 eq set selection</li>
        <li>Button feedback</li>
        <li>push your stats to table</li>
        <li>ui/ux (mobile prior)</li>
        <li>cross-browser compatibility</li>
      </ul>
    </li>
  </ul>
</div>

<div class="version">
  <h3>[v1.1.0] - Sept 18, 2025</h3>
  <ul>
    <li><span class="sub-cats">Added</span>
      <ul>
        <li>Welcome dark theme</li>
        <li>Equipment SET
          <ul>
            <li>Vesper</li>
            <li>Blue</li>
            <li>White 110</li>
          </ul>
        </li>
        <li>Final DMG Bonus field</li>
        <li>Simulate "Interactive" Divinity Flash
          <ul>
            <li>Spear of Eternity</li>
            <li>Reaper Scythe</li>
          </ul>
        </li>
      </ul>
    </li>
    <li><span class="sub-cats">Updated</span>
      <ul>
        <li>Calculation Formula</li>
      </ul>
    </li>
    <li><span class="sub-cats">Improved</span>
      <ul>
        <li>UI/UX
          <ul>
            <li>Input validation tips</li>
            <li>each button has its own feedback</li>

          </ul>
        </li>
        <li>Balancing recommendations
          <ul>
            <li></li>
            <li></li>
          </ul>
        </li>
        <li></li>
        <li>Swap Boss
          <ul>
            <li>stats editable after swap</li>
            <li>can skip race / attr field (set to 0)</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div class="version">
  <h3>[v1.0.9] - Sept 11, 2025</h3>
  <ul>
    <li><span class="sub-cats">Added</span>
      <ul>
        <li>All MVP/MINI Lv. 140 & Lv. 150 includes
          <ul>
            <li>DEF stats</li>
            <li>Size</li>
            <li>Race</li>
            <li>and Attribute</li>
          </ul>
        </li>
      </ul>
    </li>
    <li><span class="sub-cats">Updated</span>
      <ul>
        <li>"How to Use" section</li>
      </ul>
    </li>
    <li><span class="sub-cats">Improved</span>
      <ul>
        <li>Results
          <ul>
            <li>more precise stats calc</li>
            <li>show/hide precise nums</li>
          </ul>
        </li>
        <li>Balancing recommendations
          <ul>
            <li>better logic for race and/or attr</li>
            <li>extra cats when race & attr too low</li>
          </ul>
        </li>
        <li>Sticky "smooth" button</li>
        <li>Swap Boss
          <ul>
            <li>stats editable after swap</li>
            <li>can skip race / attr field (set to 0)</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>
<div class="version">
  <h3>[v1.0.8] - Aug 31, 2025</h3>
  <ul>
    <li><span class="sub-cats">Added</span>
      <ul>
        <li>Changelog</li>
        <li>"How to Use" section at top of page</li>
        <li>Target DEF dropdown (used in calc)
          <ul>
            <li>Dummy (0 DEF)</li>
            <li>Avg. MVP/MINI Lv. 130</li>
            <li>Avg. MVP/MINI Lv. 140</li>
            <li>Avg. MVP/MINI Lv. 150</li>
          </ul>
        </li>
        <li>Swap target DEF</li>
        <li>Double tap/click guard</li>
        <li>Sticky collapsible button on scroll (mobile)</li>
      </ul>
    </li>
    
    <li><span class="sub-cats">Updated</span>
      <ul>
        <li>Calc formula
          <ul>
            <li>added counter DEF</li>
          </ul>
        </li>
      </ul>
    </li>
    
    <li><span class="sub-cats">Improved</span>
      <ul>
        <li>cross-browser support</li>
        <li>main flow + logic</li>
        <li>input validation</li>
        <li>results breakdown by factor</li>
        <li>recommendation table logic</li>
      </ul>
    </li>
  </ul>
</div>
<div class="version">
  <h3>[v1.0.0] - Aug 28, 2025</h3>
  <ul>
    <li>Initial release
      <ul>
        <li>6 dropdowns + 6 numeric inputs</li>
        <li>3 buttons</li>
        <li>Result card</li>
        <li>randomize stats in rec table</li>
      </ul>
    </li>
  </ul>
</div>
  </div>
</div>
<div aria-live="polite" class="snackbar" id="snackbar" role="status">
  </div>
<script>
// ========== ROX DATA CONSTANTS ==========
const ELEMENT_COUNTER_TABLE = {
  Neutral:{Neutral:1,Fire:1,Water:1,Earth:1,Wind:1,Poison:1,Holy:1,Shadow:1,Ghost:0.70,Undead:1},
  Fire:{Neutral:1,Fire:0.25,Water:1,Earth:1.25,Wind:1,Poison:1,Holy:0.75,Shadow:1,Ghost:1,Undead:1.125},
  Water:{Neutral:1,Fire:1.25,Water:0.25,Earth:1,Wind:0.90,Poison:1,Holy:0.75,Shadow:1,Ghost:1,Undead:1},
  Earth:{Neutral:1,Fire:0.90,Water:1,Earth:0.25,Wind:1.25,Poison:1,Holy:0.75,Shadow:1,Ghost:1,Undead:1},
  Wind:{Neutral:1,Fire:1,Water:1.375,Earth:0.90,Wind:0.25,Poison:1,Holy:0.70,Shadow:1,Ghost:1,Undead:1},
  Poison:{Neutral:1,Fire:1.125,Water:1,Earth:1.125,Wind:1.125,Poison:0,Holy:0.75,Shadow:0.50,Ghost:1,Undead:-0.25},
  Holy:{Neutral:1,Fire:1,Water:1,Earth:1,Wind:1,Poison:1,Holy:0,Shadow:1.375,Ghost:1,Undead:1.375},
  Shadow:{Neutral:1.125,Fire:1,Water:1,Earth:1,Wind:1,Poison:0.50,Holy:1.375,Shadow:0,Ghost:1,Undead:-0.25},
  Ghost:{Neutral:0.90,Fire:1,Water:1,Earth:1,Wind:1,Poison:1,Holy:0.75,Shadow:0.75,Ghost:1.375,Undead:1},
  Undead:{Neutral:1,Fire:1,Water:1,Earth:1,Wind:1,Poison:0.50,Holy:1.375,Shadow:0,Ghost:1.25,Undead:0}
};
const WEAPON_SIZE_MODIFIER_TABLE = {
  "Empty Handed":{Large:0.5,Medium:0.5,Small:0.5},
  "One-Handed Sword":{Large:0.75,Medium:1,Small:0.75},
  "Two-Handed Sword":{Large:1,Medium:0.75,Small:0.75},
  "Two-Handed Spear":{Large:1,Medium:0.75,Small:0.75},
  "Dagger":{Large:0.75,Medium:0.75,Small:1},
  "Katar":{Large:0.75,Medium:1,Small:0.75},
  "Light Knuckle":{Large:0.75,Medium:0.75,Small:1},
  "Heavy Knuckle":{Large:1,Medium:0.75,Small:0.75},
  "GS":{Large:1,Medium:1,Small:1},
  "Ninja Sword":{Large:1,Medium:0.75,Small:0.75},
  "Huuma Shuriken":{Large:1,Medium:1,Small:1},
  "Tome":{Large:0.75,Medium:1,Small:1},
  "Book":{Large:1,Medium:1,Small:1},
  "Two-Handed Rod":{Large:1,Medium:1,Small:1},
  "One-Handed Rod":{Large:1,Medium:1,Small:1},
  "Mace":{Large:1,Medium:0.75,Small:0.75},
  "One-Handed Axe":{Large:0.75,Medium:0.75,Small:0.75},
  "Two-Handed Axe":{Large:0.5,Medium:0.75,Small:0.75},
  "Bow":{Large:0.75,Medium:1,Small:1},
  "Instrument":{Large:0.75,Medium:1,Small:0.75},
  "Whip":{Large:0.75,Medium:1,Small:0.75}
};
// def stats from Nila 
const DEFENSE_TABLE = {
  "0def": { def: 0, dmgred: 0 },
  "130boss": { def: 194.36, dmgred:156.81 },
  "140boss": { def: 158.37, dmgred: 212.41 },
  "150boss": { def: 194.77, dmgred: 304.07},
  "Phreeoni Lv.140": { def: 106.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Brute", attributeMob: "Neutral" },
  "Mistress Lv.140": { def: 130.18, dmgred: 272.80, sizeMob: "Small", raceMob: "Insect", attributeMob: "Wind" },
  "Eddga Lv.140": { def: 106.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Brute", attributeMob: "Fire" },
  "Kraken Lv.140": { def: 130.18, dmgred: 272.80, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Maya Lv.140": { def: 98.97, dmgred: 136.40, sizeMob: "Large", raceMob: "Insect", attributeMob: "Earth" },
  "Orc Hero Lv.140": { def: 82.47, dmgred: 136.40, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Pharaoh Lv.140": { def: 98.97, dmgred: 136.40, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Shadow" },
  "Orc Lord Lv.140": { def: 82.47, dmgred: 136.40, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Doppelganger Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Amon Ra Lv.140": { def: 106.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Morroc Lv.140": { def: 131.97, dmgred: 136.40, sizeMob: "Large", raceMob: "Demon", attributeMob: "Shadow" },
  "Time Holder Lv.140": { def: 164.97, dmgred: 136.40, sizeMob: "Large", raceMob: "Demon", attributeMob: "Neutral" },
  "Tao Gunka Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Demon", attributeMob: "Neutral" },
  "Lost Dragon Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Shadow" },
  "Fallen Bishop Lv.140": { def: 164.97, dmgred: 136.40, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Lord of the Dead Lv.140": { def: 131.97, dmgred: 136.40, sizeMob: "Large", raceMob: "Demon", attributeMob: "Shadow" },
  "Arc Angeling Lv.140": { def: 164.97, dmgred: 136.40, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" },
  "Gioia Lv.140": { def: 212.68, dmgred: 272.80, sizeMob: "Large", raceMob: "Formless", attributeMob: "Wind" },
  "RSX-0806 Lv.140": { def: 238.66, dmgred: 202.00, sizeMob: "Medium", raceMob: "Formless", attributeMob: "Neutral" },
  "Nidhoggr's Shadow Lv.140": { def: 181.21, dmgred: 134.00, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Shadow" },
  "Gloom Under Night Lv.140": { def: 306.00, dmgred: 300.00, sizeMob: "Large", raceMob: "Formless", attributeMob: "Ghost" },
  "Retribution Lv.140": { def: 256.50, dmgred: 300.00, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Shadow" },
  "Dragon Fly Lv.140": { def: 106.98, dmgred: 204.60, sizeMob: "Small", raceMob: "Insect", attributeMob: "Wind" },
  "Eclipse Lv.140": { def: 130.18, dmgred: 272.80, sizeMob: "Small", raceMob: "Brute", attributeMob: "Neutral" },
  "Mastering Lv.140": { def: 130.18, dmgred: 272.80, sizeMob: "Medium", raceMob: "Plant", attributeMob: "Water" },
  "Ghostring Lv.140": { def: 106.98, dmgred: 204.60, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Ghost" },
  "Toad Lv.140": { def: 98.97, dmgred: 136.40, sizeMob: "Small", raceMob: "Fish", attributeMob: "Water" },
  "King Dramoh Lv.140": { def: 82.47, dmgred: 136.40, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Angeling Lv.140": { def: 98.97, dmgred: 136.40, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" },
  "Deviling Lv.140": { def: 82.47, dmgred: 136.40, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Dark Priest Lv.140": { def: 212.68, dmgred: 272.80, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Undead" },
  "Vagabond Wolf Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Medium", raceMob: "Brute", attributeMob: "Earth" },
  "Chimera Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Brute", attributeMob: "Fire" },
  "Mysteltainn Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Formless", attributeMob: "Shadow" },
  "Ogretooth Lv.140": { def: 212.68, dmgred: 306.35, sizeMob: "Medium", raceMob: "Formless", attributeMob: "Shadow" },
  "Necromancer Lv.140": { def: 131.97, dmgred: 150.75, sizeMob: "Medium", raceMob: "Undead", attributeMob: "Undead" },
  "Coelacanth Lv.140": { def: 139.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Naght Sieger Lv.140": { def: 212.68, dmgred: 272.80, sizeMob: "Large", raceMob: "Demon", attributeMob: "Ghost" },
  "Observation Lv.140": { def: 146.68, dmgred: 272.80, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Neutral" },
  "Skeggiold Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Small", raceMob: "Angel", attributeMob: "Holy" },
  "Queen Scaraba Lv.140": { def: 212.30, dmgred: 268.70, sizeMob: "Small", raceMob: "Insect", attributeMob: "Earth" },
  "Faceworm Queen Lv.140": { def: 245.30, dmgred: 268.70, sizeMob: "Small", raceMob: "Insect", attributeMob: "Poison" },
  "Ktullanux Lv.140": { def: 256.50, dmgred: 542.27, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Water" },
  "Shelter Lv.140": { def: 251.18, dmgred: 258.00, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" },
  "Phreeoni Lv.150": { def: 136.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Brute", attributeMob: "Neutral" },
  "Mistress Lv.150": { def: 161.98, dmgred: 361.00, sizeMob: "Small", raceMob: "Insect", attributeMob: "Wind" },
  "Eddga Lv.150": { def: 136.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Brute", attributeMob: "Fire" },
  "Kraken Lv.150": { def: 161.98, dmgred: 361.00, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Maya Lv.150": { def: 118.76, dmgred: 186.70, sizeMob: "Large", raceMob: "Insect", attributeMob: "Earth" },
  "Orc Hero Lv.150": { def: 110.67, dmgred: 261.40, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Pharaoh Lv.150": { def: 118.76, dmgred: 186.70, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Shadow" },
  "Orc Lord Lv.150": { def: 110.67, dmgred: 261.40, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Doppelganger Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Amon Ra Lv.150": { def: 136.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Morroc Lv.150": { def: 169.17, dmgred: 261.40, sizeMob: "Large", raceMob: "Demon", attributeMob: "Shadow" },
  "Time Holder Lv.150": { def: 196.76, dmgred: 186.70, sizeMob: "Large", raceMob: "Demon", attributeMob: "Neutral" },
  "Tao Gunka Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Demon", attributeMob: "Neutral" },
  "Lost Dragon Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Shadow" },
  "Fallen Bishop Lv.150": { def: 196.76, dmgred: 186.70, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Lord of the Dead Lv.150": { def: 169.17, dmgred: 261.40, sizeMob: "Large", raceMob: "Demon", attributeMob: "Shadow" },
  "Arc Angeling Lv.150": { def: 196.76, dmgred: 186.70, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" },
  "Gioia Lv.150": { def: 259.48, dmgred: 361.00, sizeMob: "Large", raceMob: "Formless", attributeMob: "Wind" },
  "RSX-0806 Lv.150": { def: 293.16, dmgred: 317.00, sizeMob: "Medium", raceMob: "Formless", attributeMob: "Neutral" },
  "Nidhoggr's Shadow Lv.150": { def: 228.13, dmgred: 266.00, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Shadow" },
  "Gloom Under Night Lv.150": { def: 357.57, dmgred: 367.00, sizeMob: "Large", raceMob: "Formless", attributeMob: "Ghost" },
  "Retribution Lv.150": { def: 299.07, dmgred: 367.00, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Shadow" },
  "Dragon Fly Lv.150": { def: 136.62, dmgred: 311.20, sizeMob: "Small", raceMob: "Insect", attributeMob: "Wind" },
  "Eclipse Lv.150": { def: 161.98, dmgred: 361.00, sizeMob: "Small", raceMob: "Brute", attributeMob: "Neutral" },
  "Mastering Lv.150": { def: 161.98, dmgred: 361.00, sizeMob: "Medium", raceMob: "Plant", attributeMob: "Water" },
  "Ghostring Lv.150": { def: 136.62, dmgred: 311.20, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Ghost" },
  "Toad Lv.150": { def: 118.76, dmgred: 186.70, sizeMob: "Small", raceMob: "Fish", attributeMob: "Water" },
  "King Dramoh Lv.150": { def: 110.67, dmgred: 261.40, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Angeling Lv.150": { def: 118.76, dmgred: 186.70, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" },
  "Deviling Lv.150": { def: 110.66, dmgred: 261.40, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Dark Priest Lv.150": { def: 259.48, dmgred: 361.00, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Undead" },
  "Vagabond Wolf Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Medium", raceMob: "Brute", attributeMob: "Earth" },
  "Chimera Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Brute", attributeMob: "Fire" },
  "Mysteltainn Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Formless", attributeMob: "Shadow" },
  "Ogretooth Lv.150": { def: 259.48, dmgred: 385.89, sizeMob: "Medium", raceMob: "Formless", attributeMob: "Shadow" },
  "Necromancer Lv.150": { def: 169.17, dmgred: 272.00, sizeMob: "Medium", raceMob: "Undead", attributeMob: "Undead" },
  "Coelacanth Lv.150": { def: 175.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Naght Sieger Lv.150": { def: 259.48, dmgred: 361.00, sizeMob: "Large", raceMob: "Demon", attributeMob: "Ghost" },
  "Observation Lv.150": { def: 181.48, dmgred: 361.00, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Neutral" },
  "Skeggiold Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Small", raceMob: "Angel", attributeMob: "Holy" },
  "Queen Scaraba Lv.150": { def: 258.55, dmgred: 351.40, sizeMob: "Small", raceMob: "Insect", attributeMob: "Earth" },
  "Faceworm Queen Lv.150": { def: 297.55, dmgred: 351.40, sizeMob: "Small", raceMob: "Insect", attributeMob: "Poison" },
  "Ktullanux Lv.150": { def: 299.07, dmgred: 575.77, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Water" },
  "Shelter Lv.150": { def: 293.16, dmgred: 317.00, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" }
};
const RACE_TYPES = ["Angel","Demon","Formless","Insect","Fish","Demi-Human","Undead","Dragon","Plant","Brute"];
const BLUE_SET = {
  3: {
    30: 5,
    40: 7.5,
    50: 10,
    60: 12.5,
    70: 15,
    80: 17.5,
    90: 20,
    100: 22.5,
    110: 25,
    120: 27.5,
    130: 30,
    140: 32.5,
    150: 35
  /*
  },
  8: {
    30: 5,
    40: 10,
    50: 15,
    60: 20,
    70: 25,
    80: 30,
    90: 35,
    100: 40,
    110: 45,
    120: 50,
    130: 55,
    140: 60,
    150: 65
  */
  }
};
const VESPER_SET = {
  0: 8,
  1: 16,
  2: 24,
  3: 32,
  4: 40,
  5: 48,
  6: 56,
  7: 64,
  8: 72,
  9: 80
};
const WHITE_SET = {
  "Tier 0" : 30,
  "Tier 1" : 36,
  "Tier 2" : 42,
  "Tier 3" : 48,
  "Tier 4" : 54
}

// ========== DOM ELEMENTS CACHE ==========
const DOM_ELEMENTS = {
  topOfPage: document.getElementById('top'),
  atkType: document.getElementById('penCritSelect'),
  weapon: document.getElementById('weaponSelect'),
  wElem: document.getElementById('weaponElementSelect'),
  tSize: document.getElementById('targetSizeSelect'),
  tRace: document.getElementById('targetRaceSelect'),
  tAttr: document.getElementById('targetElementSelect'),
  tDef: document.getElementById('targetDefSelect'),
  blueSet: document.getElementById("blueSet"),
  blueSetLabel: document.getElementById("blueSetLabel"),
  vesperSet: document.getElementById("vesperSet"),
  vesperSetLabel: document.getElementById("vesperSetLabel"),
  whiteSet: document.getElementById("whiteSet"),
  whiteSetLabel: document.getElementById("whiteSetLabel"),
  tDefLabel: document.getElementById('tDefLabel'),
  atkTypeLabel: document.getElementById('atkTypeLabel'),
  weaponLabel: document.getElementById('weaponLabel'),
  wElemLabel: document.getElementById('wElemLabel'),
  tSizeLabel: document.getElementById('tSizeLabel'),
  tRaceLabel: document.getElementById('tRaceLabel'),
  tAttrLabel: document.getElementById('tAttrLabel'),
  pen: document.getElementById('pen'),
  crit: document.getElementById('crit'),
  dmgStack: document.getElementById('dmgStack'),
  dmgStackTips: document.getElementById('dmgStackTips'),
  dmg: document.getElementById('dmg'),
  elemEnh: document.getElementById('elemEnhance'),
  sizeEnh: document.getElementById('sizeEnhance'),
  race: document.getElementById('race'),
  attr: document.getElementById('attr'),
  penLabel: document.getElementById('penLabel'),
  critLabel: document.getElementById('critLabel'),
  dmgLabel: document.getElementById('dmgLabel'),
  elemEnhLabel: document.getElementById('elemEnhLabel'),
  sizeLabel: document.getElementById('sizeLabel'),
  raceLabel: document.getElementById('raceLabel'),
  attrLabel: document.getElementById('attrLabel'),
  hasil: document.getElementById('hasil'),
  rec: document.getElementById('recommendations'),
  submit: document.getElementById('submitBtn'),
  resetRek: document.getElementById('resetRekomenBtn'),
  resetAll: document.getElementById('resetAllBtn'),
  testSpear: document.getElementById('testSpear'),
  testReaper: document.getElementById('testReaper'),
  snackbar: document.getElementById('snackbar'),
  log: document.getElementById("log"),
  openLog: document.getElementById("openLog"),
  closeLog: document.getElementById("closeLog")
};

// ========== UTILITY FOR INPUT DATA ==========
const isEmpty = (v) => v === null || v === undefined || v === '';
const clearNumericInput = (el) => { if (el) el.value = ''; };
const safeNumber = (v) => Math.max(Number(v) || 0, 0);
const formatNumber = (n, fullPrecision = false) => {
  const num = Number(n);
  return fullPrecision ? num : Math.trunc(num * 100) / 100;
};
// ========== CORE CALCULATION HELPER ==========
function getWeaponSizeModifier(weapon, size) {
  const modMap = WEAPON_SIZE_MODIFIER_TABLE[weapon];
  if (!modMap) return 1.0;
  const val = modMap[size];
  return Number.isFinite(val) ? Number(val) : 1.0;
}
function getElementCounter(weaponElem, targetElem) {
  // fallback to neutral attr or 1.00 if still undefined/null
  const elemMap = ELEMENT_COUNTER_TABLE[weaponElem] || ELEMENT_COUNTER_TABLE['Neutral'];
  const base = targetElem ? 
    ((elemMap[targetElem] !== undefined && elemMap[targetElem] !== null) ? elemMap[targetElem] : elemMap['Neutral']) : 
    ((elemMap['Neutral'] !== undefined && elemMap['Neutral'] !== null) ? elemMap['Neutral'] : 1.0);
  return Number.isFinite(base) ? Number(base) : 1.0;
}
function getTargetDefenseData(key) {
  return DEFENSE_TABLE[key] || DEFENSE_TABLE["0def"];
}
function calculateAttackFactor(type, pen, crit, def = 0) {
  // pen / crit design
  if (type === 'pen') {
    const rawPen = (Number(pen) || 0) - (Number(def) || 0);
    if (rawPen <= 0) return 0;
    const effPen = rawPen >= 150 ? ((rawPen * 2) - 150) : rawPen;
    return effPen / 100;
  }
  if (type === 'crit') {
    return (Number(crit) || 0) / 100;
  }
  return 0;
}

// ====================== CORE CALCULATION ======================
// SSOT FORMULA
function calculateMultiplier({
  atkType, penVal, critVal, dmgVal,
  sizeEnhVal, elemEnhVal, raceVal, attrVal,
  weapon, tSize, wElem, tAttr, tRace, tDefKey,
  extras = {}
}) {
  const { def, dmgred } = getTargetDefenseData(tDefKey);
  const atkF = calculateAttackFactor(atkType, penVal, critVal, def);

  const effDmgVal = Number(dmgVal) - dmgred;
  const sizeMod = getWeaponSizeModifier(weapon, tSize);
  const elemCtr = getElementCounter(wElem, tAttr);

  // Base multiplier (core factors only)
  const baseMult = (1 + atkF) *
    (1 + (effDmgVal / 100)) *
    (sizeMod + (Number(sizeEnhVal) / 100)) *
    (elemCtr + (Number(elemEnhVal) / 100)) *
    (1 + (tAttr ? (Number(attrVal) / 100) : 0)) *
    (1 + (tRace ? (Number(raceVal) / 100) : 0));

  // extras single object (single source of truth)
  const blueGroup3Val = Number(extras.blueGroup3Val || extras.blue3 || 0);
  const blueGroup8Val = Number(extras.blueGroup8Val || extras.blue8 || 0);
  const vesperVal = Number(extras.vesperVal || extras.vesper || 0);
  const whiteVal = Number(extras.whiteVal || extras.white || 0);
  const dmgStackVal = Number(extras.dmgStackVal || extras.dmgStack || 0);

  const extraBonuses = [];

  if (Number(vesperVal) > 0) extraBonuses.push({ key: 'Vesper', type: 'extra1', value: Number(vesperVal) / 100 });
  if (Number(blueGroup3Val) > 0) extraBonuses.push({ key: 'BlueGroup3', type: 'extra1', value: Number(blueGroup3Val) / 100 });
  if (Number(whiteVal) > 0) extraBonuses.push({ key: 'White', type: 'extra1', value: Number(whiteVal) / 100 });
  if (Number(dmgStackVal) > 0) extraBonuses.push({ key: 'DmgStack', type: 'extra1', value: Number(dmgStackVal) / 100 });

  // Reaper independent in group1 when active
  try {
    if (typeof isTestReaperActive !== 'undefined' && isTestReaperActive) {
      const reaperVal = ((wElem === tAttr) || (wElem === "Neutral" && !tAttr)) ? (42 / 100) : (14 / 100);
      extraBonuses.push({ key: 'Reaper', type: 'extra1', value: reaperVal });
    }
  } catch(e) {}

  if (Number(blueGroup8Val) > 0) extraBonuses.push({ key: 'BlueGroup8', type: 'extra2', value: Number(blueGroup8Val) / 100 });

  // Spear independent in group2 when active
  try {
    if (typeof isTestSpearActive !== 'undefined' && isTestSpearActive) {
      extraBonuses.push({ key: 'Spear', type: 'extra2', value: (42 / 100) });
    }
  } catch(e) {}

  const groups = {};
  extraBonuses.forEach(b => {
    if (!groups[b.type]) groups[b.type] = { sum: 0, items: [] };
    groups[b.type].sum += b.value;
    groups[b.type].items.push(b);
  });

  let extraMult = 1;
  const extraGroups = [];
  Object.keys(groups).forEach(type => {
    const g = groups[type];
    const factor = 1 + g.sum;
    extraGroups.push({ type, sum: g.sum, factor, items: g.items });
    extraMult *= factor;
  });

  const totalMult = baseMult * extraMult;

  return {
    mult: totalMult,
    def, dmgred, effDmgVal, atkF,
    parts: {
      baseMult: baseMult,
      extraGroups: extraGroups
    }
  };
}
// State management
let isResultShown = false;
function getCurrentCalculationState() {
  const atkType = DOM_ELEMENTS.atkType.value;
  const penVal = Number(DOM_ELEMENTS.pen.value) || 0;
  const critVal = Number(DOM_ELEMENTS.crit.value) || 0;
  const dmgVal = Number(DOM_ELEMENTS.dmg.value) || 0;
  const sizeEnhVal = Number(DOM_ELEMENTS.sizeEnh.value) || 0;
  const elemEnhVal = Number(DOM_ELEMENTS.elemEnh.value) || 0;
  const raceVal = Number(DOM_ELEMENTS.race.value) || 0;
  const attrVal = Number(DOM_ELEMENTS.attr.value) || 0;

  // Detect BlueSet group (*3 or *8) by label text
  const blueSelect = DOM_ELEMENTS.blueSet;
  const selectedBlueOption = blueSelect && blueSelect.options && blueSelect.options[blueSelect.selectedIndex];
  let blueGroup3Val = 0;
  let blueGroup8Val = 0;
  if (selectedBlueOption) {
    const optionText = selectedBlueOption.textContent || "";
    const blueValue = Number(blueSelect.value) || 0;
    if (optionText.includes('*3')) {
      blueGroup3Val = blueValue;
    }
    if (optionText.includes('*8')) {
      blueGroup8Val = blueValue;
    }
  }

  // Extra sets and manual stack
  const vesperVal = Number(DOM_ELEMENTS.vesperSet.value) || 0;
  const whiteVal = Number(DOM_ELEMENTS.whiteSet.value) || 0;
  const dmgStackVal = Number(DOM_ELEMENTS.dmgStack.value) || 0;

  
  // Build extras object (single parameter)
  const extras = {
    blueGroup3Val: blueGroup3Val,
    blueGroup8Val: blueGroup8Val,
    vesperVal: vesperVal,
    whiteVal: whiteVal,
    dmgStackVal: dmgStackVal
  };

const result = calculateMultiplier({
    atkType, penVal, critVal, dmgVal, sizeEnhVal, elemEnhVal,
    raceVal, attrVal,
    weapon: DOM_ELEMENTS.weapon.value,
    tSize: DOM_ELEMENTS.tSize.value,
    wElem: DOM_ELEMENTS.wElem.value,
    tAttr: DOM_ELEMENTS.tAttr.value,
    tRace: DOM_ELEMENTS.tRace.value,
    tDefKey: DOM_ELEMENTS.tDef.value,
    extras
  });

  return {
    atkType, penVal, critVal, dmgVal, sizeEnhVal, elemEnhVal,
    raceVal, attrVal, blueGroup3Val, blueGroup8Val,
    vesperVal, whiteVal, dmgStackVal,
    mult: result.mult, def: result.def, dmgred: result.dmgred,
    effDmgVal: result.effDmgVal, atkF: result.atkF
  ,
    parts: result.parts || {},
    extraGroups: (result.parts && Array.isArray(result.parts.extraGroups)) ? result.parts.extraGroups : []
  };
}
// Debounce utility
let processMainCalculationTimeout = null;
function processMainCalculation() {
  // Clear existing timeout
  if (processMainCalculationTimeout) {
    clearTimeout(processMainCalculationTimeout);
  }
  
  processMainCalculationTimeout = setTimeout(() => {
    executeMainCalculation();
  }, 300);
}
function executeMainCalculation() {
  if (!validateRequiredFields()) return;

  const calculationState = getCurrentCalculationState();
  if (!validateStatsVsTarget(calculationState)) return;

  const isPenMode = calculationState.atkType === 'pen';
  const attackFactor = calculateAttackFactor(
    isPenMode ? 'pen' : 'crit',
    calculationState.penVal,
    calculationState.critVal,
    calculationState.def
  );
  const sizeModifier = getWeaponSizeModifier(DOM_ELEMENTS.weapon.value, DOM_ELEMENTS.tSize.value);
  const elementCounter = getElementCounter(DOM_ELEMENTS.wElem.value, DOM_ELEMENTS.tAttr.value);

  const includeRace = !!DOM_ELEMENTS.tRace.value && (calculationState.raceVal > 0);
  const includeAttr = !!DOM_ELEMENTS.tAttr.value && (calculationState.attrVal > 0);
  const includeExtra = (calculationState.blueGroup3Val > 0 || calculationState.blueGroup8Val > 0 || 
                       calculationState.vesperVal > 0 || calculationState.whiteVal > 0 || 
                       calculationState.dmgStackVal > 0);

  // Breakdown list for UI display (must match render logic)
  
  // compute extra group authoritative factors (prefer calculation result)
  var extra1Factor = 1;
  var extra2Factor = 1;
  try {
    if (calculationState.parts && Array.isArray(calculationState.parts.extraGroups)) {
      var eg1 = calculationState.parts.extraGroups.find(function(g){ return g.type === 'extra1'; });
      var eg2 = calculationState.parts.extraGroups.find(function(g){ return g.type === 'extra2'; });
      extra1Factor = eg1 ? eg1.factor : (1 + (calculationState.blueGroup3Val / 100) + (calculationState.vesperVal / 100) + (calculationState.whiteVal / 100) + (calculationState.dmgStackVal / 100));
      extra2Factor = eg2 ? eg2.factor : (1 + (calculationState.blueGroup8Val / 100));
    } else {
      extra1Factor = 1 + (calculationState.blueGroup3Val / 100) + (calculationState.vesperVal / 100) + (calculationState.whiteVal / 100) + (calculationState.dmgStackVal / 100);
      extra2Factor = 1 + (calculationState.blueGroup8Val / 100);
    }
  } catch (e) {
    extra1Factor = 1 + (calculationState.blueGroup3Val / 100) + (calculationState.vesperVal / 100) + (calculationState.whiteVal / 100) + (calculationState.dmgStackVal / 100);
    extra2Factor = 1 + (calculationState.blueGroup8Val / 100);
  }

  const includeExtraTwo = (calculationState.blueGroup8Val > 0 || (typeof isTestSpearActive !== 'undefined' && isTestSpearActive));
  const factorList = [
    {
      key: 'main',
      label: (isPenMode ? 'Type (PEN)' : 'Type (CRIT)'),
      val: isPenMode ? calculationState.penVal : calculationState.critVal,
      mult: 1 + attackFactor
    },
    {
      key: 'dmg',
      label: 'Final P/M DMG BNS',
      val: calculationState.dmgVal,
      mult: 1 + (calculationState.effDmgVal || 0) / 100
    },
    {
      key: 'elem',
      label: 'Element',
      val: calculationState.elemEnhVal,
      mult: elementCounter + calculationState.elemEnhVal / 100,
      extra: `counter ${elementCounter}`
    },
    {
      key: 'size',
      label: 'Size',
      val: calculationState.sizeEnhVal,
      mult: sizeModifier + calculationState.sizeEnhVal / 100,
      extra: `mod ${sizeModifier}`
    },
    {
      key: 'race',
      label: 'Race',
      val: calculationState.raceVal,
      mult: 1 + calculationState.raceVal / 100,
      show: includeRace
    },
    {
      key: 'attr',
      label: 'Attribute',
      val: calculationState.attrVal,
      mult: 1 + calculationState.attrVal / 100,
      show: includeAttr
    },
    {
      key: 'extra',
      label: 'Extra#1',
      val: calculationState.blueGroup3Val + calculationState.vesperVal + calculationState.whiteVal + calculationState.dmgStackVal,
      mult: extra1Factor,
      show: includeExtra
    },
    {
      key: 'extraTwo',
      label: 'Extra#2',
      val: calculationState.blueGroup8Val,
      mult: extra2Factor,
      show: includeExtraTwo
    }
  ];

  renderMultiplierBreakdown(calculationState, factorList, elementCounter, sizeModifier, isPenMode);
  generateRecommendationTable(calculationState);

  // Enable test buttons after successful calculation
  try {
    if (DOM_ELEMENTS.testReaper) DOM_ELEMENTS.testReaper.disabled = false;
    if (DOM_ELEMENTS.testSpear) DOM_ELEMENTS.testSpear.disabled = false;
  } catch (e) { console.warn('enable test buttons', e); }

  isResultShown = true;
  DOM_ELEMENTS.submit.disabled = true;
  DOM_ELEMENTS.resetRek.disabled = false;
  DOM_ELEMENTS.resetAll.disabled = false;
  DOM_ELEMENTS.testSpear.disabled = false;
  DOM_ELEMENTS.testReaper.disabled = false;
  lockAllInputs();
}

// === results dom manipulation (breakdown n rec) ===
// Optimized utility functions
const createEl = (tag, props = {}, children = []) => {
  const el = document.createElement(tag);
  
  // Set properties efficiently
  Object.entries(props).forEach(([key, value]) => {
    switch (key) {
      case "class": el.className = value; break;
      case "for": el.setAttribute("for", value); break;
      case "text": el.textContent = value; break;
      default: el.setAttribute(key, value);
    }
  });
  
  // Append children efficiently
  const childArray = Array.isArray(children) ? children : [children];
  const fragment = document.createDocumentFragment();
  
  childArray.forEach(child => {
    if (child) {
      fragment.appendChild(typeof child === "string" ? document.createTextNode(child) : child);
    }
  });
  
  el.appendChild(fragment);
  return el;
};

// Cached DOM elements for performance
const getDOMCache = () => ({
  targetDefense: DOM_ELEMENTS.tDef,
  targetSize: DOM_ELEMENTS.tSize,
  targetRace: DOM_ELEMENTS.tRace,
  targetAttribute: DOM_ELEMENTS.tAttr,
  weaponElement: DOM_ELEMENTS.wElem,
  weapon: DOM_ELEMENTS.weapon,
  vesperSet: DOM_ELEMENTS.vesperSet,
  blueSet: DOM_ELEMENTS.blueSet,
  whiteSet: DOM_ELEMENTS.whiteSet,
  penetration: DOM_ELEMENTS.pen,
  critical: DOM_ELEMENTS.crit
});

function renderMultiplierBreakdown(calculationState, damageFactorList, elementalCounter, weaponSizeModifier, isPenetrationMode) {
  const resultContainer = DOM_ELEMENTS.hasil;
  const showFullPrecision = resultContainer?.dataset?.showFullPrecision === "1";
  const domCache = getDOMCache();

  // Format numbers based on precision setting
  const formatValue = num => showFullPrecision ? Number(num) || 0 : Math.trunc((Number(num) || 0) * 100) / 100;

  // Get authoritative extra damage groups safely
  const getExtraGroups = () => {
    try {
      const groups = calculationState?.parts?.extraGroups || [];
      return {
        extra1: groups.find(g => g.type === 'extra1') || null,
        extra2: groups.find(g => g.type === 'extra2') || null
      };
    } catch (e) {
      return { extra1: null, extra2: null };
    }
  };

  const { extra1: authExtra1, extra2: authExtra2 } = getExtraGroups();

  // Re-lock all numeric inputs after target swap
  const relockAllInputs = () => {
    document.querySelectorAll(".input-wrap").forEach(wrapper => {
      if (wrapper.dataset.tempUnlocked === "1") return;
      
      const input = wrapper.querySelector("select, input");
      if (!input) return;
      
      try {
        bindInputLockGuard(wrapper);
        wrapper.classList.add("locked");
        input.disabled = true;
      } catch (e) {
        // Silent error handling
      }
    });
  };

  // Factory functions for creating factor items
  const factorCreators = {
    main: (factor) => {
      const defenseLabel = domCache.targetDefense.options[domCache.targetDefense.selectedIndex]?.text || "Target";
      const subList = createEl("ul");

      if (isPenetrationMode) {
        const rawPen = calculationState.penVal || 0;
        const targetDef = calculationState.def || 0;
        const basePen = rawPen - targetDef;

        const items = [
          createEl("li", { text: `Raw PEN + Final PEN: ${formatValue(rawPen)}` }),
          createEl("li", { text: `Target DEF: ${formatValue(targetDef)}` })
        ];

        if (basePen >= 150) {
          const effectivePercent = (basePen * 2) - 150;
          items.push(
            createEl("li", { text: `1.00 + ((( ${formatValue(rawPen)} - ${formatValue(targetDef)} ) × 2 ) - 150 ) / 100` }),
            createEl("li", {}, [`1.00 + ( ${formatValue(effectivePercent)} / 100 ) → `, createEl("code", { text: `×${formatValue(factor.mult)}` })])
          );
        } else {
          items.push(createEl("li", {}, [
            `1.00 + (( ${formatValue(rawPen)} - ${formatValue(targetDef)} ) / 100 ) → `,
            createEl("code", { text: `×${formatValue(factor.mult)}` })
          ]));
        }

        items.forEach(item => subList.appendChild(item));
      } else {
        // CRIT mode
        subList.appendChild(createEl("li", { text: `Crit DMG: ${formatValue(factor.val)}` }));
        subList.appendChild(createEl("li", {}, [
          `1.00 + ( ${formatValue(factor.val)} / 100 ) → `,
          createEl("code", { text: `×${formatValue(factor.mult)}` })
        ]));
      }

      return createEl("li", { text: `Attack Type: ${isPenetrationMode ? "PEN" : "CRIT"} vs ${defenseLabel}` }, subList);
    },

    dmg: (factor) => {
      const items = [
        createEl("li", { text: `P/M BO: ${formatValue(factor.val)}` }),
        createEl("li", { text: `Target Reduction: ${formatValue(calculationState.dmgred || 0)}` }),
        createEl("li", {}, [
          `1.00 + (( ${formatValue(factor.val)} - ${formatValue(calculationState.dmgred || 0)} ) / 100 ) → `,
          createEl("code", { text: `×${formatValue(factor.mult)}` })
        ])
      ];

      return createEl("li", { text: "Final P/M Damage Bonus" }, createEl("ul", {}, items));
    },

    elem: (factor) => {
      const items = [
        createEl("li", { text: `Counter: ${formatValue(elementalCounter)}` }),
        createEl("li", { text: `${domCache.weaponElement.value} Enhance: ${formatValue(factor.val)}` }),
        createEl("li", {}, [
          `${formatValue(elementalCounter)} + ${formatValue(factor.val / 100)} → `,
          createEl("code", { text: `×${formatValue(factor.mult)}` })
        ])
      ];

      if (!domCache.targetAttribute.value) {
        items.push(createEl("li", { text: "Tools assume target Neutral if you're not targeting any attribute." }));
      }

      return createEl("li", {
        text: `Element: ${domCache.weaponElement.value || "Neutral"} vs ${domCache.targetAttribute.value || "Neutral"}`
      }, createEl("ul", {}, items));
    },

    size: (factor) => {
      const items = [
        createEl("li", { text: `Modifier: ${formatValue(weaponSizeModifier)}` }),
        createEl("li", { text: `${domCache.targetSize.value} Enhance: ${formatValue(factor.val)}` }),
        createEl("li", {}, [
          `${formatValue(weaponSizeModifier)} + ${formatValue(factor.val / 100)} → `,
          createEl("code", { text: `×${formatValue(factor.mult)}` })
        ])
      ];

      return createEl("li", {
        text: `Size: ${domCache.weapon.value || "Weapon"} vs ${domCache.targetSize.value}`
      }, createEl("ul", {}, items));
    },

    race: (factor) => {
      const raceLabel = domCache.targetRace.options[domCache.targetRace.selectedIndex]?.text || "Target Race";
      const items = [
        createEl("li", { text: `DMG to ${raceLabel}: ${formatValue(factor.val)}` }),
        createEl("li", {}, [
          `1.00 + ( ${formatValue(factor.val)} / 100 ) → `,
          createEl("code", { text: `×${formatValue(factor.mult)}` })
        ])
      ];

      return createEl("li", { text: `Race: ${raceLabel}` }, createEl("ul", {}, items));
    },

    attr: (factor) => {
      const attrLabel = domCache.targetAttribute.options[domCache.targetAttribute.selectedIndex]?.text || "Target Attribute";
      const items = [
        createEl("li", { text: `DMG to ${attrLabel} Attribute: ${formatValue(factor.val)}` }),
        createEl("li", {}, [
          `1.00 + ( ${formatValue(factor.val)} / 100 ) → `,
          createEl("code", { text: `×${formatValue(factor.mult)}` })
        ])
      ];

      return createEl("li", { text: `Attribute: ${attrLabel}` }, createEl("ul", {}, items));
    },

    extra: (factor) => {
      const subList = createEl("ul");
      
      const extraValues = {
        blueGroup3: Number(calculationState.blueGroup3Val) || 0,
        vesperValue: Number(calculationState.vesperVal) || 0,
        whiteValue: Number(calculationState.whiteVal) || 0,
        damageStack: Number(calculationState.dmgStackVal) || 0
      };
      
      const rawParts = [];
      
      // Add damage components
      const components = [
        { value: extraValues.vesperValue, label: "Vesper SET", select: domCache.vesperSet },
        { value: extraValues.blueGroup3, label: "Blue SET (Ferocity)", select: domCache.blueSet },
        { value: extraValues.whiteValue, label: "White SET (110*3)", select: domCache.whiteSet },
        { value: extraValues.damageStack, label: "Final DMG BNS", format: true }
      ];

      components.forEach(({ value, label, select, format }) => {
        if (value > 0) {
          if (select) {
            subList.appendChild(createEl("li", { text: `${label}: ${select.options[select.selectedIndex].text}` }));
          } else {
            subList.appendChild(createEl("li", { text: `${label}: ${formatValue(value)}` }));
          }
          subList.appendChild(createEl("li", { text: `${formatValue(value)} / 100` }));
          rawParts.push(value / 100);
        }
      });
      
      // Add reaper scythe bonus if active
      if (typeof isTestReaperActive !== "undefined" && isTestReaperActive) {
        const elemMatch = (domCache.weaponElement.value && domCache.targetAttribute.value && 
                          domCache.weaponElement.value === domCache.targetAttribute.value) ||
                         (domCache.weaponElement.value === "Neutral" && !domCache.targetAttribute.value);
        const reaperPercent = elemMatch ? 42 : 14;
        
        subList.appendChild(createEl("li", { text: `Reaper Scythe: ${domCache.weaponElement.value || "?"} vs ${domCache.targetAttribute.value || "Neutral"}` }));
        subList.appendChild(createEl("li", { text: `${formatValue(reaperPercent)} / 100` }));
        subList.appendChild(createEl("li", {
          class: "note",
          text: elemMatch ? 
            "Elements match. Real bonus is 84% (10s duration / 20s CD), displayed here as(sume) 42% for 100% uptime." :
            "Elements differ. Real bonus is 28% (10s duration / 20s CD), displayed here as(sume) 14% for 100% uptime."
        }));
        rawParts.push(reaperPercent / 100);
      }
      
      // Calculate total and display
      const totalBonus = rawParts.reduce((acc, val) => acc + val, 0);
      const bonusStr = rawParts.map(formatValue).join(" + ");
      
      if (authExtra1) {
        try {
          const authSum = Number(authExtra1.sum) || 0;
          const displayStr = (Array.isArray(authExtra1.items) && authExtra1.items.length) ?
            authExtra1.items.map(item => formatValue(item.val || item.value || item)).join(" + ") :
            formatValue(authSum);
          subList.appendChild(createEl("li", {}, [`1 + ${displayStr} → `, createEl("code", { text: `×${formatValue(1 + authSum)}` })]));
        } catch (e) {
          subList.appendChild(createEl("li", {}, [`1 + ${bonusStr} → `, createEl("code", { text: `×${formatValue(1 + totalBonus)}` })]));
        }
      } else if (rawParts.length > 0) {
        subList.appendChild(createEl("li", {}, [`1 + ${bonusStr} → `, createEl("code", { text: `×${formatValue(1 + totalBonus)}` })]));
      } else {
        subList.appendChild(createEl("li", { text: "× 1.00 (no stat)" }));
      }
      
      return createEl("li", { text: "Extra#1: Final DMG Bonus" }, subList);
    },

    extraTwo: (factor) => {
      const subList = createEl("ul");
      const blueGroup8 = Number(calculationState.blueGroup8Val) || 0;
      const rawParts = [];
      
      if (blueGroup8 > 0) {
        subList.appendChild(createEl("li", { text: `Blue SET: ${domCache.blueSet.options[domCache.blueSet.selectedIndex].text}` }));
        subList.appendChild(createEl("li", { text: `${formatValue(blueGroup8)} / 100` }));
        rawParts.push(blueGroup8 / 100);
      }
      
      if (typeof isTestSpearActive !== "undefined" && isTestSpearActive) {
        subList.appendChild(createEl("li", { text: "Divinity#1 Flash: Spear of Eternity" }));
        subList.appendChild(createEl("li", { text: "42 / 100" }));
        subList.appendChild(createEl("li", {
          class: "note",
          text: "This bonus is shown as(sume) 100% uptime (actual bonus is 84%)."
        }));
        rawParts.push(0.42);
      }
      
      const totalBonus = rawParts.reduce((acc, val) => acc + val, 0);
      const bonusStr = rawParts.map(formatValue).join(" + ");
      
      if (authExtra2) {
        try {
          const authSum = Number(authExtra2.sum) || 0;
          const displayStr = (Array.isArray(authExtra2.items) && authExtra2.items.length) ?
            authExtra2.items.map(item => formatValue(item.val || item.value || item)).join(" + ") :
            formatValue(authSum);
          subList.appendChild(createEl("li", {}, [`1 + ${displayStr} → `, createEl("code", { text: `×${formatValue(1 + authSum)}` })]));
        } catch (e) {
          subList.appendChild(createEl("li", {}, [`1 + ${bonusStr} → `, createEl("code", { text: `×${formatValue(1 + totalBonus)}` })]));
        }
      } else if (rawParts.length > 0) {
        subList.appendChild(createEl("li", {}, [`1 + ${bonusStr} → `, createEl("code", { text: `×${formatValue(1 + totalBonus)}` })]));
      } else {
        subList.appendChild(createEl("li", { text: "× 1.00 (no stat)" }));
      }
      
      return createEl("li", { text: "Extra#2: Bonus DMG to MVP/MINI" }, subList);
    }
  };

  // Create factor item using factory
  const createFactorItem = (factor) => {
    if (factor.show === false) {
      return createEl("li", { text: `${factor.label}: ×1.00 (no stat)` });
    }

    const creator = factorCreators[factor.key];
    return creator ? creator(factor) : createEl("li", {}, [
      `${factor.label}: ${formatValue(factor.val)} → `,
      createEl("code", { text: `×${formatValue(factor.mult)}` })
    ]);
  };

  // Create precision toggle button
  const createPrecisionToggle = () => {
    const btn = createEl("button", {
      type: "button",
      class: "toggle-precision",
      text: showFullPrecision ? "Beautify!" : "Want to see?"
    });

    btn.addEventListener("click", (e) => {
      e.preventDefault();
      if (!resultContainer?.dataset) return;
      
      resultContainer.dataset.showFullPrecision = 
        resultContainer.dataset.showFullPrecision === "1" ? "0" : "1";
      processMainCalculation();
      showSnackbar(resultContainer.dataset.showFullPrecision === "1"
        ? "Precise numbers displayed"
        : "Rounded numbers displayed"
      );
    });

    return btn;
  };

  // Create target swap functionality
  const createTargetSwap = () => {
    const swapOptions = [
      { key: "0def", label: "Dummy (0 DEF)" },
      { key: "130boss", label: "Avg. 130 BOSS" },
      { key: "140boss", label: "Avg. 140 BOSS" },
      { key: "150boss", label: "Avg. 150 BOSS" }
    ];

    const presetKeys = new Set(["0def", "130boss", "140boss", "150boss"]);
    
    // Add other defense keys
    Object.keys(DEFENSE_TABLE).forEach(key => {
      if (!presetKeys.has(key)) {
        swapOptions.push({ key, label: key });
      }
    });

    const select = createEl("select", { id: "breakdown-swap", class: "breakdown-swap" });
    
    // Create options efficiently
    const fragment = document.createDocumentFragment();
    swapOptions.forEach(({ key, label }) => {
      const targetData = getTargetDefenseData(key);
      const def = Number(targetData.def || 0);
      const dmgred = Number(targetData.dmgred || 0);
      
      const option = createEl("option", { value: key, text: label });
      
      // Check if stats are insufficient
      const attackType = calculationState.atkType.toLowerCase();
      const pen = Number(domCache.penetration?.value || 0);
      const dmg = Number(DOM_ELEMENTS.dmg?.value || 0);
      const insufficient = attackType === "pen" 
        ? (pen <= def || dmg <= dmgred)
        : (dmg <= dmgred);

      if (insufficient) {
        option.disabled = true;
        option.textContent += " (stats not enough)";
      }
      
      fragment.appendChild(option);
    });

    select.appendChild(fragment);
    select.value = domCache.targetDefense.value || "0def";

    // Add event listener for swap functionality
    select.addEventListener("change", () => handleTargetSwap(select, presetKeys, domCache));

    return { select, presetKeys };
  };

  // Handle target swap logic (extracted for clarity)
  const handleTargetSwap = (swapSelect, presetKeys, domCache) => {
    const prevKey = domCache.targetDefense.value;
    const currKey = swapSelect.value;
    const prevData = DEFENSE_TABLE[prevKey] || {};
    const currData = DEFENSE_TABLE[currKey] || {};
    const isPreset = key => presetKeys.has(key);

    domCache.targetDefense.value = currKey;

    // Check if mob characteristics are the same
    const sameMobFactors = currData.sizeMob === prevData.sizeMob &&
      currData.raceMob === prevData.raceMob &&
      currData.attributeMob === prevData.attributeMob;

    // Simple swap conditions
    const isSimpleSwap = (isPreset(prevKey) && isPreset(currKey)) ||
      (!isPreset(prevKey) && isPreset(currKey)) ||
      (!isPreset(prevKey) && !isPreset(currKey) && 
       (prevKey.replace(/\d+$/, "") === currKey.replace(/\d+$/, "") || sameMobFactors));

    if (isSimpleSwap) {
      // Handle simple swap
      if (!isPreset(prevKey) && isPreset(currKey)) {
        // Clear race and attribute when switching from specific to preset
        [domCache.targetRace, domCache.targetAttribute].forEach((el, idx) => {
          if (el) {
            el.value = "";
            try {
              el.dispatchEvent(new Event("input", { bubbles: true }));
              el.dispatchEvent(new Event("change", { bubbles: true }));
            } catch (e) {}
          }
          const fieldEl = DOM_ELEMENTS[idx === 0 ? "race" : "attr"];
          if (fieldEl) {
            fieldEl.value = "";
            try {
              fieldEl.dispatchEvent(new Event("input", { bubbles: true }));
              fieldEl.dispatchEvent(new Event("change", { bubbles: true }));
            } catch (e) {}
          }
        });
        updateDynamicFieldLabels();
      }

      relockAllInputs();
      resultContainer.dataset.specificMode = "0";
      isTestReaperActive = false;
      isTestSpearActive = false;isFlashActive = false;
      processMainCalculation();
      showSnackbar('Swap to same type mob, auto calc!');
      
      return;
    }

    // Complex swap - handle specific target logic
    domCache.targetSize.value = currData.sizeMob || "";
    domCache.targetRace.value = currData.raceMob || "";
    domCache.targetAttribute.value = currData.attributeMob || "";
    updateDynamicFieldLabels();

    // Determine fields to unlock
    const attackType = calculationState.atkType.toLowerCase();
    const fieldsToUnlock = ["dmg", "dmgStack"];
    
    if (attackType === "pen") fieldsToUnlock.push("pen");
    if (attackType === "crit") fieldsToUnlock.push("crit");
    if (domCache.targetSize.value) fieldsToUnlock.push("sizeEnh");
    if (domCache.targetRace.value) fieldsToUnlock.push("race");
    if (domCache.targetAttribute.value) fieldsToUnlock.push("attr");
    if (domCache.weaponElement.value) fieldsToUnlock.push("elemEnh");

    const unlockedInputs = [];
    
    // Unlock required fields
    fieldsToUnlock.forEach(fieldId => {
      const field = DOM_ELEMENTS[fieldId];
      if (!field) return;
      
      const wrapper = field.closest(".input-wrap");
      if (wrapper) {
        try { 
          unbindInputLockGuard(wrapper); 
        } catch (e) {}
        wrapper.classList.remove("locked");
        wrapper.dataset.tempUnlocked = "1";
      }
      
      field.disabled = false;
      unlockedInputs.push({ fieldId, element: field, wrapper });
    });

    // Enable submit, disable others
    if (DOM_ELEMENTS.submit) DOM_ELEMENTS.submit.disabled = false;
    
    Object.keys(DOM_ELEMENTS).forEach(key => {
      const el = DOM_ELEMENTS[key];
      if (key !== 'submit' && el && typeof el.disabled !== 'undefined') {
        el.disabled = true;
      }
    });
    
    // Disable test buttons
    if (DOM_ELEMENTS.testSpear) DOM_ELEMENTS.testSpear.disabled = true;
    if (DOM_ELEMENTS.testReaper) DOM_ELEMENTS.testReaper.disabled = true;
    
    // Keep unlocked inputs enabled
    unlockedInputs.forEach(({ element }) => {
      element.disabled = false;
    });

    // Validation and relock function
    const validateAndRelock = () => {
      let allValid = true;
      
      unlockedInputs.forEach(({ fieldId, element }) => {
        const shouldSkip = (fieldId === "sizeEnh" && !domCache.targetSize.value) ||
          (fieldId === "race" && !domCache.targetRace.value) ||
          (fieldId === "attr" && !domCache.targetAttribute.value) ||
          (fieldId === "elemEnh" && !domCache.weaponElement.value);
        
        if (shouldSkip) return;

        const val = Number(element.value);
        const min = Number(element.getAttribute("min")) || 0;
        if (!(element.value && !isNaN(val) && val >= min)) {
          allValid = false;
        }
      });

      if (!allValid) return;

      try {
        if (!validateRequiredFields()) return;
      } catch (e) { 
        return; 
      }

      // Relock inputs
      unlockedInputs.forEach(({ element, wrapper }) => {
        if (wrapper) {
          wrapper.removeAttribute("data-temp-unlocked");
          wrapper.classList.add("locked");
          try { 
            bindInputLockGuard(wrapper); 
          } catch (e) {}
        }
        element.disabled = true;
        element.removeEventListener("blur", validateAndRelock);
      });

      // Re-enable all elements
      Object.keys(DOM_ELEMENTS).forEach(key => {
        const el = DOM_ELEMENTS[key];
        if (key !== 'submit' && el && typeof el.disabled !== 'undefined') {
          el.disabled = false;
        }
      });
      
      if (DOM_ELEMENTS.testSpear) DOM_ELEMENTS.testSpear.disabled = false;
      if (DOM_ELEMENTS.testReaper) DOM_ELEMENTS.testReaper.disabled = false;

      resultContainer.dataset.specificMode = "0";
      DOM_ELEMENTS.hasil.textContent = 'Input your stats to see the result...';
      DOM_ELEMENTS.rec.textContent = 'Balancing stat recommendations for a higher output multiplier.';

      showSnackbar('Please click Submit button to calculate with new target!');
    };

    // Handle field changes and focus
    const fieldChanges = [
      { changed: currData.sizeMob !== prevData.sizeMob, fieldId: "sizeEnh" },
      { changed: currData.raceMob !== prevData.raceMob, fieldId: "race" },
      { changed: currData.attributeMob !== prevData.attributeMob, fieldId: "attr" }
    ];

    let focusTarget = null;
    fieldChanges.forEach(({ changed, fieldId }) => {
      if (!changed) return;
      
      const field = DOM_ELEMENTS[fieldId];
      if (field) {
        field.value = "";
        try {
          field.dispatchEvent(new Event("input", { bubbles: true }));
          field.dispatchEvent(new Event("change", { bubbles: true }));
        } catch (e) {}
        if (!focusTarget) focusTarget = field;
      }
    });

    // Find first empty field to focus
    const firstEmpty = unlockedInputs.find(({ element }) => !element.value);
    const targetFocus = focusTarget || firstEmpty?.element || unlockedInputs[0]?.element;
    
    DOM_ELEMENTS.hasil.textContent = 'Input your stats to see the result...';
    DOM_ELEMENTS.rec.textContent = 'Balancing stat recommendations for a higher output multiplier.';

    if (targetFocus) {
      scrollAndFocusElement(targetFocus, "Target Swapped, refill and calc again!");
    }
  };

  // Build main breakdown content
  const buildBreakdown = () => {
    const precisionBtn = createPrecisionToggle();
    const { select: swapSelect } = createTargetSwap();

    // Create factor breakdown list
    const factorList = createEl("ul", { class: "factor-breakdown" });
    const fragment = document.createDocumentFragment();
    
    damageFactorList.forEach(factor => {
      fragment.appendChild(createFactorItem(factor));
    });
    
    factorList.appendChild(fragment);

    // Create multiplier display
    const multiplierParts = damageFactorList.map(factor => 
      factor.show === false ? 
        "× 1.00 (no " + factor.label.toLowerCase() + ")" :
        "× " + formatValue(factor.mult)
    );

    const targetInfo = [
      domCache.targetSize.value,
      domCache.targetRace.value,
      domCache.targetAttribute.value
    ].filter(Boolean).join(" + ");

    const defenseText = domCache.targetDefense.options[domCache.targetDefense.selectedIndex]?.text || "";

    // Build main content
    const content = [
      createEl("blockquote", { class: "noted" }, [
        "By default, every factor starts at ×1.00. Numbers show how it changes with your stats.",
        createEl("br"), createEl("br"),
        "Values shown to two decimal places for readability. The final result is computed with full precision(",
        precisionBtn,
        "), so it may differ slightly if you recompute using the displayed (rounded) numbers."
      ]),
      factorList,
      createEl("hr", { class: "separ" }),
      createEl("div", { id: "swap-wrapper", class: "breakdown-swap-wrapper" }, [
        createEl("label", { for: "breakdown-swap", id: "swap-label", text: "Swap Target:" }),
        swapSelect
      ]),
      createEl("p", {}, [
        "Your multiplier to ",
        createEl("i", {}, [`${targetInfo} (${defenseText})`]),
        ":"
      ]),
      createEl("blockquote", { class: "noted" }, [
        `1.00 ${multiplierParts.join(" ")} = `,
        createEl("code", { text: `×${formatValue(calculationState.mult)}` }),
        createEl("br"), createEl("br"),
        "Only base multipliers! Real output depends on class, skills, buffs (vesper, blue and white stack), and more. More accurate? Just use ",createEl("a",{class:"job-sim", target:"_blank", href: "//discord.com/channels/784407151342256148/909016309218541568/1407521807459811328", text: "job sim!"}),
        createEl("br"), createEl("br"),
        "Avg 130, Necro, Ogre, Ktul defs less accurate than others!",
        createEl("br"), createEl("br"),
        "In the table, an upward arrow means higher than your stat, a square means roughly equal (±3%), and a downward means lower."
      ])
    ];

    const container = createEl("div", { id: "multiplier-breakdown", class: "multiplier-breakdown" });
    const mainFragment = document.createDocumentFragment();
    
    content.forEach(element => mainFragment.appendChild(element));
    container.appendChild(mainFragment);

    return { container, swapSelect };
  };

  // Setup event bindings
  const setupEventBindings = (swapSelect) => {
    // Bind main target select to swap select (prevent duplicate listeners)
    if (!domCache.targetDefense.dataset.swapBound) {
      domCache.targetDefense.addEventListener("change", () => {
        swapSelect.value = domCache.targetDefense.value;
      });
      domCache.targetDefense.dataset.swapBound = "1";
    }

    // Update attack type input states
    const attackType = calculationState.atkType.toLowerCase();
    if (domCache.penetration && domCache.critical) {
      if (attackType === "pen") {
        domCache.penetration.disabled = false;
        domCache.critical.disabled = true;
      } else {
        domCache.penetration.disabled = true;
        domCache.critical.disabled = false;
      }
    }
  };

  // Main execution
  const { container, swapSelect } = buildBreakdown();
  setupEventBindings(swapSelect);

  // Clear and append to result container
  resultContainer.innerHTML = "";
  resultContainer.appendChild(container);
}

const RECOMMENDATION_CONFIG = {
  randomMode: 'clamp', 
  maxAttempts: 200,
  centerScale: 0.25, // rand around stats 
  jitter: 0.15, // keep closest 
  jitterStep: 0.08, // scaling jitter
  jitterStepEvery: 40, // every 40 attempt 
  jitterMax: 0.5, // stop scaling now
  clampMaxFraction: 0.6, // more closest to center
  clampMaxAbsolute: 0.3, // and more
  upDownThreshold: 3, // Â±3 assume nochange
  raceAttrCap: 420, // race attr total cap = max ea + any
  raceAttrSoloCap: 330, // 3 slot ea10(270) + any
  raceAttrTol: 8, // tolerance for cap
  smallThreshold: 140, // if user race and/or attr < 2slot ea8 = small
  smallMin: 90, // new base for user (1slot ea10)
  smallExp: 0.6, 
  ratioMin: 0.4, // min ratio share
  ratioMax: 0.7, // max ratio
  ratioNoise: 0.08, // with noise 
  bias: { // weights share
    main: 1,
    dmg: 0.8,
    elem: 0.8,
    size: 0.8,
    race: 0.8,
    attr: 0.8
  },
  cats: [ // normal cats
    { label: '0-8%', min: 1.00, max: 1.08 },
    { label: '10-20%', min: 1.10, max: 1.20 },
    { label: '20-30%', min: 1.20, max: 1.30 },
    { label: '50-100%', min: 1.50, max: 2.00 }
  ],
  forSmallCats: [ // cats for lack race&attr
    { label: '50-100%', min: 1.50, max: 2.00 },
    { label: '100-200%', min: 2.00, max: 3.00 },
    { label: '200-300%', min: 3.00, max: 4.00 },
    { label: '300-400%', min: 4.00, max: 5.00 }
  ]
};
function calculateRecommendationWeights({ includeRace, includeAttr, baseMain, baseDmg, baseElem, baseSize, baseRace, baseAttr }) {
  const biasConfig = RECOMMENDATION_CONFIG.bias;
  const rawStatWeights = [
    safeNumber(baseMain) * biasConfig.main,
    safeNumber(baseDmg) * biasConfig.dmg,
    safeNumber(baseElem) * biasConfig.elem,
    safeNumber(baseSize) * biasConfig.size
  ];

  const maxRawWeight = Math.max(...rawStatWeights, 1);
  const normalizedStatWeights = rawStatWeights.map(weightValue => weightValue / maxRawWeight);
  const coreStatSum = normalizedStatWeights.reduce((accumulator, currentWeight) => accumulator + currentWeight, 0) || 1;
  const coreStatShare = (includeRace || includeAttr) ? 0.8 : 1.0;
  const additionalStatShare = 1 - coreStatShare;

  let finalWeights = {
    main: normalizedStatWeights[0] / coreStatSum * coreStatShare,
    dmg: normalizedStatWeights[1] / coreStatSum * coreStatShare,
    elem: normalizedStatWeights[2] / coreStatSum * coreStatShare,
    size: normalizedStatWeights[3] / coreStatSum * coreStatShare,
    race: 0,
    attr: 0
  };

  const effectiveRaceValue = includeRace ? Math.max(Math.pow(baseRace, RECOMMENDATION_CONFIG.smallExp), RECOMMENDATION_CONFIG.smallMin) : 0;
  const effectiveAttrValue = includeAttr ? Math.max(Math.pow(baseAttr, RECOMMENDATION_CONFIG.smallExp), RECOMMENDATION_CONFIG.smallMin) : 0;

  const raceIsAvailable = includeRace && effectiveRaceValue > 0 && effectiveRaceValue < RECOMMENDATION_CONFIG.raceAttrCap;
  const attrIsAvailable = includeAttr && effectiveAttrValue > 0 && effectiveAttrValue < RECOMMENDATION_CONFIG.raceAttrCap;

  if (raceIsAvailable && attrIsAvailable) {
    const combinedRaceAttrSum = safeNumber(effectiveRaceValue) + safeNumber(effectiveAttrValue);
    if (combinedRaceAttrSum > 0) {
      finalWeights.race = (safeNumber(effectiveRaceValue) / combinedRaceAttrSum) * additionalStatShare;
      finalWeights.attr = (safeNumber(effectiveAttrValue) / combinedRaceAttrSum) * additionalStatShare;
    } else {
      finalWeights.race = additionalStatShare / 2;
      finalWeights.attr = additionalStatShare / 2;
    }
  } else if (raceIsAvailable) {
    finalWeights.race = additionalStatShare;
  } else if (attrIsAvailable) {
    finalWeights.attr = additionalStatShare;
  } else if (includeRace || includeAttr) {
    const coreStatKeys = ["main", "dmg", "elem", "size"];
    normalizedStatWeights.forEach((weightValue, statIndex) => {
      finalWeights[coreStatKeys[statIndex]] += (weightValue / coreStatSum) * additionalStatShare;
    });
  }

  const totalWeightSum = Object.values(finalWeights).reduce((accumulator, currentWeight) => accumulator + currentWeight, 0) || 1;
  Object.keys(finalWeights).forEach(weightKey => { finalWeights[weightKey] /= totalWeightSum; });
  return finalWeights;
}

function applySmallValueAdjustment(inputValue, baseRace, baseAttr) {
  const combinedRaceAttrTotal = baseRace + baseAttr;
  if (combinedRaceAttrTotal > 0 && combinedRaceAttrTotal < RECOMMENDATION_CONFIG.smallThreshold) {
    // Enhance small values for better recommendations
    return Math.max(Math.pow(inputValue, RECOMMENDATION_CONFIG.smallExp), RECOMMENDATION_CONFIG.smallMin);
  }
  return inputValue;
}
function generateRandomValue(baseStatValue, jitterAmount = RECOMMENDATION_CONFIG.jitter) {
  const numericBaseValue = Number(baseStatValue) || 0;
  const randomizationMode = RECOMMENDATION_CONFIG.randomMode;
  
  if (randomizationMode === "clamp") {
    const randomDelta = (Math.random() * 2 - 1) * jitterAmount;
    const maxClampValue = Math.min(RECOMMENDATION_CONFIG.clampMaxFraction * jitterAmount, RECOMMENDATION_CONFIG.clampMaxAbsolute);
    const clampedDelta = Math.max(Math.min(randomDelta, maxClampValue), -maxClampValue);
    return Math.max(0, numericBaseValue * (1 + clampedDelta));
  }
  
  if (randomizationMode === "normal") {
    let uniformRandom1 = 0, uniformRandom2 = 0;
    while (uniformRandom1 === 0) uniformRandom1 = Math.random();
    while (uniformRandom2 === 0) uniformRandom2 = Math.random();
    const normalDistValue = Math.sqrt(-2.0 * Math.log(uniformRandom1)) * Math.cos(2.0 * Math.PI * uniformRandom2);
    return Math.max(0, numericBaseValue * (1 + normalDistValue * jitterAmount * 0.5));
  }
  
  const simpleDelta = (Math.random() * 2 - 1) * jitterAmount;
  return Math.max(0, numericBaseValue * (1 + simpleDelta));
}
function getMaxAllowedValue(userStatValue, capLimit, toleranceValue, isSmallUser) {
  return userStatValue >= capLimit ? (isSmallUser ? capLimit + toleranceValue : userStatValue + toleranceValue) : capLimit;
}
function avoidCapLimit(inputValue, capLimit) {
  // Avoid rendering exactly at cap value
  if (inputValue < capLimit) return inputValue;
  const randomOffset = capLimit * (0.01 + Math.random() * 0.02);
  return capLimit - randomOffset;
}
function createFactorCell(currentValue, originalBaseValue) {
  const roundedCurrent = Math.round(currentValue);
  const roundedBase = Math.round(originalBaseValue);
  let cellClassName = 'neutral';
  
  if (roundedCurrent >= roundedBase + RECOMMENDATION_CONFIG.upDownThreshold) {
    cellClassName = 'up';
  } else if (roundedCurrent <= roundedBase - RECOMMENDATION_CONFIG.upDownThreshold) {
    cellClassName = 'down';
  }
  
  const valueSpan = document.createElement('span');
  valueSpan.className = cellClassName;
  valueSpan.textContent = roundedCurrent;
  
  const tableCell = document.createElement('td');
  tableCell.appendChild(valueSpan);
  return tableCell;
}
function generateRecommendationTable(gameState) {
  const originalMultiplier = gameState.mult;
  const recommendationContainer = DOM_ELEMENTS.rec;
  recommendationContainer.innerHTML = '';
  
  const shouldIncludeRace = !!DOM_ELEMENTS.tRace.value && (Number(gameState.raceVal) || 0) > 0;
  const shouldIncludeAttr = !!DOM_ELEMENTS.tAttr.value && (Number(gameState.attrVal) || 0) > 0;
  const isPenetrationMode = gameState.atkType === 'pen';

  const userMainStat = isPenetrationMode ? gameState.penVal : gameState.critVal;
  const userDmgStat = gameState.dmgVal || 0;
  const userSizeStat = gameState.sizeEnhVal || 0;
  const userElemStat = gameState.elemEnhVal || 0;
  const userAttrStat = shouldIncludeAttr ? (gameState.attrVal || 0) : 0;
  const userRaceStat = shouldIncludeRace ? (gameState.raceVal || 0) : 0;

  
  const statWeights = calculateRecommendationWeights({
    includeRace: shouldIncludeRace, 
    includeAttr: shouldIncludeAttr, 
    baseMain: userMainStat, 
    baseDmg: userDmgStat, 
    baseElem: userElemStat, 
    baseSize: userSizeStat, 
    baseRace: userRaceStat, 
    baseAttr: userAttrStat
  });
  
  const centeringScale = RECOMMENDATION_CONFIG.centerScale;
  const calculateCenteredValue = (baseStatValue, weightValue) => safeNumber(baseStatValue) * (1 + weightValue * centeringScale);

  const centeredMainValue = calculateCenteredValue(userMainStat, statWeights.main);
  const centeredDmgValue = calculateCenteredValue(userDmgStat, statWeights.dmg);
  const centeredElemValue = calculateCenteredValue(userElemStat, statWeights.elem);
  const centeredSizeValue = calculateCenteredValue(userSizeStat, statWeights.size);

  const adjustedAttrValue = shouldIncludeAttr ? applySmallValueAdjustment(userAttrStat, userRaceStat, userAttrStat) : 0;
  const adjustedRaceValue = shouldIncludeRace ? applySmallValueAdjustment(userRaceStat, userRaceStat, userAttrStat) : 0;

  const centeredAttrValue = shouldIncludeAttr ? Math.min(calculateCenteredValue(adjustedAttrValue, statWeights.attr), RECOMMENDATION_CONFIG.raceAttrCap) : 0;
  const centeredRaceValue = shouldIncludeRace ? Math.min(calculateCenteredValue(adjustedRaceValue, statWeights.race), RECOMMENDATION_CONFIG.raceAttrCap) : 0;

  const calculateRaceAttrValues = (currentJitter) => {
    let generatedRaceValue = 0, generatedAttrValue = 0;

    if (shouldIncludeAttr && shouldIncludeRace) {
      const userCombinedTotal = userRaceStat + userAttrStat;
      const boostedCombinedTotal = adjustedRaceValue + adjustedAttrValue;
      const isSmallCombined = userCombinedTotal > 0 && userCombinedTotal < RECOMMENDATION_CONFIG.smallThreshold;
      const maxAllowedTotal = getMaxAllowedValue(userCombinedTotal, RECOMMENDATION_CONFIG.raceAttrCap, RECOMMENDATION_CONFIG.raceAttrTol, isSmallCombined);

      const randomizedTotal = avoidCapLimit(Math.min(generateRandomValue(boostedCombinedTotal, currentJitter), maxAllowedTotal), maxAllowedTotal);
      const distributionRatio = RECOMMENDATION_CONFIG.ratioMin + Math.random() * (RECOMMENDATION_CONFIG.ratioMax - RECOMMENDATION_CONFIG.ratioMin);

      [generatedRaceValue, generatedAttrValue] = [randomizedTotal * distributionRatio, randomizedTotal * (1 - distributionRatio)];
      const actualSum = generatedRaceValue + generatedAttrValue;
      
      if (actualSum > maxAllowedTotal) {
        const scalingFactor = avoidCapLimit(maxAllowedTotal, maxAllowedTotal) / actualSum;
        generatedRaceValue *= scalingFactor;
        generatedAttrValue *= scalingFactor;
      }
    } else if (shouldIncludeRace || shouldIncludeAttr) {
      const userSingleTotal = shouldIncludeRace ? userRaceStat : userAttrStat;
      const boostedSingleTotal = shouldIncludeRace ? adjustedRaceValue : adjustedAttrValue;
      const isSmallSingle = userSingleTotal > 0 && userSingleTotal < RECOMMENDATION_CONFIG.smallThreshold;
      const maxSingleValue = getMaxAllowedValue(userSingleTotal, RECOMMENDATION_CONFIG.raceAttrSoloCap, RECOMMENDATION_CONFIG.raceAttrTol, isSmallSingle);

      if (shouldIncludeRace) {
        generatedRaceValue = avoidCapLimit(Math.min(generateRandomValue(boostedSingleTotal, currentJitter), maxSingleValue), maxSingleValue);
      } else {
        generatedAttrValue = avoidCapLimit(Math.min(generateRandomValue(boostedSingleTotal, currentJitter), maxSingleValue), maxSingleValue);
      }
    }

    return { raceValue: generatedRaceValue, attrValue: generatedAttrValue };
  };

  const generateRecommendationRow = (currentJitter) => {
    let penValue = gameState.penVal, critValue = gameState.critVal;
    
    if (isPenetrationMode) {
      penValue = generateRandomValue(centeredMainValue, currentJitter);
    } else {
      critValue = generateRandomValue(centeredMainValue, currentJitter);
    }

    const dmgValue = generateRandomValue(centeredDmgValue, currentJitter);
    const elemValue = generateRandomValue(centeredElemValue, currentJitter);
    const sizeValue = generateRandomValue(centeredSizeValue, currentJitter);
    const { raceValue: raceValue, attrValue: attrValue } = calculateRaceAttrValues(currentJitter);

    const extraStats = {
      blueGroup3Val: gameState.blueGroup3Val || 0,
      blueGroup8Val: gameState.blueGroup8Val || 0,
      vesperVal: gameState.vesperVal || 0,
      whiteVal: gameState.whiteVal || 0,
      dmgStackVal: gameState.dmgStackVal || 0
    };

    const { mult: calculatedMultiplier } = calculateMultiplier({
      atkType: isPenetrationMode ? 'pen' : 'crit',
      penVal: penValue,
      critVal: critValue,
      dmgVal: dmgValue,
      sizeEnhVal: sizeValue,
      elemEnhVal: elemValue,
      raceVal: raceValue,
      attrVal: attrValue,
      weapon: DOM_ELEMENTS.weapon.value,
      tSize: DOM_ELEMENTS.tSize.value,
      wElem: DOM_ELEMENTS.wElem.value,
      tAttr: DOM_ELEMENTS.tAttr.value,
      tRace: DOM_ELEMENTS.tRace.value,
      tDefKey: DOM_ELEMENTS.tDef.value,
      extras: extraStats
    });

    
    // Avoid round tens for better visual variety
    const avoidRoundTen = (inputValue) => (inputValue % 10 === 0 ? inputValue + 1 : inputValue);

    return {
      mainVal: avoidRoundTen(Math.round(isPenetrationMode ? penValue : critValue)),
      dmgVal: avoidRoundTen(Math.round(dmgValue)),
      elemVal: avoidRoundTen(Math.round(elemValue)),
      sizeVal: avoidRoundTen(Math.round(sizeValue)),
      raceVal: shouldIncludeRace ? avoidRoundTen(Math.round(raceValue)) : null,
      attrVal: shouldIncludeAttr ? avoidRoundTen(Math.round(attrValue)) : null,
      newMultiplier: calculatedMultiplier
    };
  };

  const hasSmallCombinedStats = shouldIncludeRace && shouldIncludeAttr &&
    (userRaceStat + userAttrStat > 0 && userRaceStat + userAttrStat < RECOMMENDATION_CONFIG.smallThreshold);

  const currentCategories = hasSmallCombinedStats ? RECOMMENDATION_CONFIG.forSmallCats : RECOMMENDATION_CONFIG.cats;

  for (const categoryConfig of currentCategories) {
    const tableElement = document.createElement('table');
    tableElement.className = 'recommend-table';
    
    const tableCaption = document.createElement('caption');
    tableCaption.textContent = 'Increase ' + categoryConfig.label;
    tableElement.appendChild(tableCaption);

    const headerRow = document.createElement('tr');
    const columnHeaders = ['STAT', isPenetrationMode ? 'PEN' : 'CRIT', 'P/M BO', 'Element', 'Size'];
    if (shouldIncludeRace) columnHeaders.push('Race');
    if (shouldIncludeAttr) columnHeaders.push('Attribute');
    columnHeaders.push('Multiplier', '\u0394');    
    columnHeaders.forEach(headerText => {
      const headerCell = document.createElement('th');
      headerCell.textContent = headerText;
      headerRow.appendChild(headerCell);
    });
    tableElement.appendChild(headerRow);

    const tableBody = document.createElement('tbody');
    const uniqueKeys = new Set();
    const uniqueDeltas = new Set();
    const uniqueValues = { 
      main: new Set(), 
      dmg: new Set(), 
      elem: new Set(), 
      size: new Set(), 
      attr: new Set(), 
      race: new Set() 
    };
    const acceptedRows = [];
    
    let generationAttempts = 0;
    let dynamicJitter = RECOMMENDATION_CONFIG.jitter;

    while (acceptedRows.length < 5 && generationAttempts < RECOMMENDATION_CONFIG.maxAttempts) {
      generationAttempts++;
      
      const candidateRow = generateRecommendationRow(dynamicJitter);
      
      if (candidateRow.newMultiplier <= originalMultiplier) continue;
      
      const multiplierRatio = candidateRow.newMultiplier / Math.max(originalMultiplier, 1e-9);
      if (multiplierRatio < categoryConfig.min || multiplierRatio > categoryConfig.max) continue;

      const rowUniqueKey = [candidateRow.mainVal, candidateRow.dmgVal, candidateRow.elemVal, candidateRow.sizeVal, candidateRow.raceVal || '-', candidateRow.attrVal || '-'].join('|');
      if (uniqueKeys.has(rowUniqueKey)) continue;
      if (uniqueValues.main.has(candidateRow.mainVal)) continue;
      if (uniqueValues.dmg.has(candidateRow.dmgVal)) continue;
      if (uniqueValues.elem.has(candidateRow.elemVal)) continue;
      if (uniqueValues.size.has(candidateRow.sizeVal)) continue;
      if (shouldIncludeAttr && uniqueValues.attr.has(candidateRow.attrVal)) continue;
      if (shouldIncludeRace && uniqueValues.race.has(candidateRow.raceVal)) continue;
      
      if (
        candidateRow.mainVal > userMainStat &&
        candidateRow.dmgVal > userDmgStat &&
        candidateRow.elemVal > userElemStat &&
        candidateRow.sizeVal > userSizeStat &&
        (!shouldIncludeRace || candidateRow.raceVal > userRaceStat) &&
        (!shouldIncludeAttr || candidateRow.attrVal > userAttrStat)
      ) {
        continue;
      }
      
      const deltaPercentage = ((candidateRow.newMultiplier - originalMultiplier) / originalMultiplier) * 100;
      const roundedDeltaKey = Number(deltaPercentage.toFixed(1));
      if (uniqueDeltas.has(roundedDeltaKey)) continue;

      uniqueKeys.add(rowUniqueKey);
      uniqueDeltas.add(roundedDeltaKey);
      uniqueValues.main.add(candidateRow.mainVal);
      uniqueValues.dmg.add(candidateRow.dmgVal);
      uniqueValues.elem.add(candidateRow.elemVal);
      uniqueValues.size.add(candidateRow.sizeVal);
      if (shouldIncludeAttr) uniqueValues.attr.add(candidateRow.attrVal);
      if (shouldIncludeRace) uniqueValues.race.add(candidateRow.raceVal);

      acceptedRows.push({
        main: candidateRow.mainVal, 
        dmg: candidateRow.dmgVal, 
        elem: candidateRow.elemVal, 
        size: candidateRow.sizeVal,
        attr: candidateRow.attrVal, 
        race: candidateRow.raceVal,
        newMultiplier: candidateRow.newMultiplier, 
        deltaPercent: deltaPercentage
      });

      // Increase jitter if having trouble finding valid rows
      if (acceptedRows.length < 5 && generationAttempts % RECOMMENDATION_CONFIG.jitterStepEvery === 0) {
        dynamicJitter = Math.min(dynamicJitter + RECOMMENDATION_CONFIG.jitterStep, RECOMMENDATION_CONFIG.jitterMax);
      }
    }

    // Sort by delta percentage and multiplier
    acceptedRows.sort((rowA, rowB) => rowB.deltaPercent - rowA.deltaPercent || rowB.newMultiplier - rowA.newMultiplier || rowB.main - rowA.main);

    for (let i = 0; i < acceptedRows.length; i++) {
      const acceptedRow = acceptedRows[i];
      const dataRow = document.createElement('tr');
      
      // Add stat number column
      const statNumberCell = document.createElement('td');
      statNumberCell.className = 'build';
      statNumberCell.textContent = 'BUILD#' + (i + 1).toString();
      dataRow.appendChild(statNumberCell);
      
      dataRow.appendChild(createFactorCell(acceptedRow.main, userMainStat));
      dataRow.appendChild(createFactorCell(acceptedRow.dmg, userDmgStat));
      dataRow.appendChild(createFactorCell(acceptedRow.elem, userElemStat));
      dataRow.appendChild(createFactorCell(acceptedRow.size, userSizeStat));
      if (shouldIncludeRace) dataRow.appendChild(createFactorCell(acceptedRow.race, userRaceStat));
      if (shouldIncludeAttr) dataRow.appendChild(createFactorCell(acceptedRow.attr, userAttrStat));
      
      const multiplierCell = document.createElement('td');
      multiplierCell.className = 'mult';
      multiplierCell.textContent = 'x' + acceptedRow.newMultiplier.toFixed(2);
      dataRow.appendChild(multiplierCell);
      
      const deltaCell = document.createElement('td');
      deltaCell.className = 'delta';
      deltaCell.textContent = '+' + acceptedRow.deltaPercent.toFixed(1) + '%';
      dataRow.appendChild(deltaCell);
      
      tableBody.appendChild(dataRow);
    }

    // Add user's current stats row
    const userCurrentStatsRow = document.createElement('tr');
    userCurrentStatsRow.className = 'your-stats-values';
    
    // Add "Yours" in the stat column
    const yoursCell = document.createElement('td');
    yoursCell.textContent = 'YOURS';
    yoursCell.className = 'yours-label';
    userCurrentStatsRow.appendChild(yoursCell);
    
    userCurrentStatsRow.appendChild(createFactorCell(userMainStat, userMainStat, true));
    userCurrentStatsRow.appendChild(createFactorCell(userDmgStat, userDmgStat, true));
    userCurrentStatsRow.appendChild(createFactorCell(userElemStat, userElemStat, true));
    userCurrentStatsRow.appendChild(createFactorCell(userSizeStat, userSizeStat, true));
    if (shouldIncludeRace) userCurrentStatsRow.appendChild(createFactorCell(userRaceStat, userRaceStat, true));
    if (shouldIncludeAttr) userCurrentStatsRow.appendChild(createFactorCell(userAttrStat, userAttrStat, true));
    
    const userMultiplierCell = document.createElement('td');
    userMultiplierCell.className = 'mult current-mult';
    userMultiplierCell.textContent = 'x' + gameState.mult.toFixed(2);
    userCurrentStatsRow.appendChild(userMultiplierCell);
    
    const userDeltaCell = document.createElement('td');
    userDeltaCell.className = 'delta current-delta';
    userDeltaCell.textContent = '-';
    userCurrentStatsRow.appendChild(userDeltaCell);
    
    tableBody.appendChild(userCurrentStatsRow);

    tableElement.appendChild(tableBody);
    const tableWrapper = document.createElement('div');
    tableWrapper.className = 'table-wrapper';
    tableWrapper.appendChild(tableElement);
    
    if (acceptedRows.length) {
      recommendationContainer.appendChild(tableWrapper);
    }
  }
}
function regenerateRecommendations() {
  if (!isResultShown) return;
  const calculationState = getCurrentCalculationState();
  generateRecommendationTable(calculationState);
}


// ======== FLASH ======
const debounceMap = new Map();
function smoothDebounce(fn, delay, key) {
  const existing = debounceMap.get(key);
  if (existing) {
    clearTimeout(existing);
  }
  
  const timeoutId = setTimeout(() => {
    debounceMap.delete(key);
    fn();
  }, delay);
  
  debounceMap.set(key, timeoutId);
}
let isTestReaperActive = false;
let isTestSpearActive = false;
function simulateFlash(event) {
  try {
    const btn = event?.currentTarget;
    if (!btn) return;
    
    // Prevent multiple rapid clicks
    if (btn.disabled) return;
    
    // Temporarily disable button for smooth UX
    btn.disabled = true;
    setTimeout(() => btn.disabled = false, 200);
    
    if (btn === DOM_ELEMENTS.testReaper) {
      isTestReaperActive = !isTestReaperActive;
      btn.classList.toggle('activated', isTestReaperActive);
      
      // Debounced pulse flash when activated
      if (isTestReaperActive) {
        smoothDebounce(() => {
          if (typeof triggerPulseFlash === 'function') {
            triggerPulseFlash();
          }
        }, 100, 'reaper-flash');
      }
      
      // Debounced calculation
      smoothDebounce(() => {
        if (typeof processMainCalculation === 'function') {
          processMainCalculation();
        }
      }, 150, 'reaper-calc');
      
      if (typeof showSnackbar === 'function') {
        showSnackbar(isTestReaperActive ? 'Reaper Flash Active' : 'Reaper Off');
      }
    }
    
    if (btn === DOM_ELEMENTS.testSpear) {
      isTestSpearActive = !isTestSpearActive;
      btn.classList.toggle('activated', isTestSpearActive);
      
      // Debounced pulse flash when activated
      if (isTestSpearActive) {
        smoothDebounce(() => {
          if (typeof triggerPulseFlash === 'function') {
            triggerPulseFlash();
          }
        }, 100, 'spear-flash');
      }
      
      // Debounced calculation
      smoothDebounce(() => {
        if (typeof processMainCalculation === 'function') {
          processMainCalculation();
        }
      }, 150, 'spear-calc');
      
      if (typeof showSnackbar === 'function') {
        showSnackbar(isTestSpearActive ? 'Spear Flash Active' : 'Spear Off');
      }
    }
  } catch (e) {
    console.warn('simulateFlash error', e);
  }
}
let isFlashActive = false;
function triggerPulseFlash() {
  // Early exit for non-mobile or if already active
  if (window.innerWidth >= 480 || isFlashActive) {
    if (window.innerWidth >= 480) {
      console.log('Flash effect hanya untuk mobile (<480px)');
    }
    return;
  }
  
  isFlashActive = true;
  
  // Use requestAnimationFrame for smooth rendering
  requestAnimationFrame(() => {
    const flash = document.createElement('div');
    
    // Optimized CSS with better GPU acceleration
    flash.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background: radial-gradient(ellipse 120% 150% at center,
        rgba(88, 101, 242, 0.4) 0%, rgba(88, 101, 242, 0.25) 35%,
        rgba(79, 84, 92, 0.15) 65%, rgba(54, 57, 63, 0.08) 85%, transparent 100%);
      opacity: 0; transform: scale3d(0.8, 0.8, 1); pointer-events: none; z-index: 999;
      mix-blend-mode: overlay; display: flex; align-items: center; justify-content: center;
      will-change: opacity, transform; backface-visibility: hidden;
      animation: pulseFlashAnim 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards, 
                 lightningFlicker 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    `;
    
    const lightning = document.createElement('div');
    lightning.innerHTML = '&#x26A1;';
    lightning.style.cssText = `
      font-size: 3.2rem; color: #dcddde; opacity: 0; transform: scale3d(0.8, 0.8, 1);
      text-shadow: 0 0 6px rgba(220, 221, 222, 0.9), 
                   0 0 18px rgba(88, 101, 242, 0.7), 
                   0 0 30px rgba(88, 101, 242, 0.3);
      filter: drop-shadow(0 0 4px rgba(185, 187, 190, 0.5));
      will-change: opacity, transform; backface-visibility: hidden;
      animation: lightningAnim 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
    `;
    
    flash.appendChild(lightning);
    
    // Safe DOM insertion with error handling
    try {
      document.body.appendChild(flash);
    } catch (e) {
      console.warn('Flash DOM insertion failed', e);
      isFlashActive = false;
      return;
    }
    
    // Optimized cleanup with multiple fallbacks
    const cleanup = () => {
      if (flash.parentNode) {
        try {
          flash.parentNode.removeChild(flash);
        } catch (e) {
          // Fallback for cross-browser compatibility
          flash.remove?.() || flash.parentNode?.removeChild(flash);
        }
      }
      isFlashActive = false;
    };
    
    // Primary cleanup timer
    const cleanupTimer = setTimeout(cleanup, 1300);
    
    // Fallback cleanup on animation end (cross-browser support)
    const handleAnimationEnd = () => {
      clearTimeout(cleanupTimer);
      cleanup();
      flash.removeEventListener('animationend', handleAnimationEnd);
      flash.removeEventListener('webkitAnimationEnd', handleAnimationEnd);
    };
    
    // Cross-browser animation event listeners
    flash.addEventListener('animationend', handleAnimationEnd, { passive: true });
    flash.addEventListener('webkitAnimationEnd', handleAnimationEnd, { passive: true });
    
    // Emergency cleanup for iOS Safari
    setTimeout(() => {
      if (isFlashActive) {
        cleanup();
      }
    }, 2000);
  });
}

// ========== DROPDOWN ==========
function setOptions(select, options, placeholder, customLabels = {}) {
  // Generate HTML for options
  const optionElements = [];
  
  if (placeholder) {
    optionElements.push(`<option value="">${placeholder}</option>`);
  }
  
  options.forEach(opt => {
    const value = typeof opt === "string" ? opt : opt.value;
    const label = customLabels[value] || (typeof opt === "string" ? opt : opt.label);
    const disabled = opt.disabled ? 'disabled' : '';
    
    optionElements.push(`<option value="${value}" ${disabled}>${label}</option>`);
  });
  
  select.innerHTML = optionElements.join("");
}
function populateDropdownOptions() {
  // Populate attack type dropdown
  setOptions(DOM_ELEMENTS.atkType, [
    { value: "pen", label: "P/M PEN" },
    { value: "crit", label: "Critical" }
  ], "Select Attack Type");
  
  // Populate weapon dropdown from lookup table
  setOptions(DOM_ELEMENTS.weapon, Object.keys(WEAPON_SIZE_MODIFIER_TABLE), "Select Weapon");
  
  // Populate weapon element dropdown
  setOptions(DOM_ELEMENTS.wElem, Object.keys(ELEMENT_COUNTER_TABLE), "Select Attribute");
  
  populateTargetDropdowns();
  populateSetDropdowns();
  bindTargetDefenseListener();
  bindThreeSetListeners();
}
function populateTargetDropdowns() {
  const targetDropdowns = [
    {
      element: DOM_ELEMENTS.tSize,
      options: [
        { value: "Small", label: "Small" },
        { value: "Medium", label: "Medium" },
        { value: "Large", label: "Large" }
      ],
      placeholder: "Select Target Size"
    },
    {
      element: DOM_ELEMENTS.tRace,
      options: RACE_TYPES,
      placeholder: "skip race"
    },
    {
      element: DOM_ELEMENTS.tAttr,
      options: Object.keys(ELEMENT_COUNTER_TABLE),
      placeholder: "skip attribute"
    }
  ];
  
  // Populate target dropdowns and enable them
  targetDropdowns.forEach(({ element, options, placeholder }) => {
    setOptions(element, options, placeholder);
    element.disabled = false;
  });
  
  // Populate defense dropdown with custom labels
  setOptions(DOM_ELEMENTS.tDef, Object.keys(DEFENSE_TABLE), "Select target monster", {
    "0def": "Dummy (0 DEF)",
    "130boss": "Average 130 BOSS",
    "140boss": "Average 140 BOSS",
    "150boss": "Average 150 BOSS"
  });
}
function populateSetDropdowns() {
  // Vesper Set dropdown
  const vesperOptions = [
    { value: "", label: "skip vesper set" },
    ...Object.entries(VESPER_SET).map(([tier, val]) => ({
      value: val,
      label: `Tier ${tier}`
    }))
  ];
  setOptions(DOM_ELEMENTS.vesperSet, vesperOptions);
  
  // White Set dropdown
  const whiteOptions = [
    { value: "", label: "skip white set" },
    ...Object.entries(WHITE_SET).map(([tier, val]) => ({
      value: val,
      label: tier
    }))
  ];
  setOptions(DOM_ELEMENTS.whiteSet, whiteOptions);
  
  // Blue Set dropdown with nested mapping
  const blueOptions = [
    { value: "", label: "skip blue set" },
    ...Object.entries(BLUE_SET).flatMap(([multiplier, levels]) =>
      Object.entries(levels).map(([lvl, val]) => ({
        value: val,
        label: `Level ${lvl}*${multiplier}`
      }))
    )
  ];
  setOptions(DOM_ELEMENTS.blueSet, blueOptions);
}
function bindTargetDefenseListener() {
  // Prevent duplicate listeners
  if (DOM_ELEMENTS.tDef.dataset.boundDefense) return;
  
  DOM_ELEMENTS.tDef.addEventListener('change', function() {
    const selectedKey = this.value;
    const defenseData = DEFENSE_TABLE[selectedKey];
    const targetElements = {
      size: DOM_ELEMENTS.tSize,
      race: DOM_ELEMENTS.tRace,
      attr: DOM_ELEMENTS.tAttr
    };
    
    // Auto-populate and disable fields if defense data contains mob info
    if (defenseData && selectedKey.includes("Lv.")) {
      updateTargetField(targetElements.size, defenseData.sizeMob);
      updateTargetField(targetElements.race, defenseData.raceMob);
      updateTargetField(targetElements.attr, defenseData.attributeMob);
    } else {
      // Reset and enable all target fields
      Object.values(targetElements).forEach(element => {
        element.value = "";
        element.disabled = false;
      });
    }
    
    updateDynamicFieldLabels();
  });
  
  DOM_ELEMENTS.tDef.dataset.boundDefense = "1";
}

// ======== EQ SET ========
function updateTargetField(element, value) {
  // Update field with value and disable if value exists
  if (value) {
    element.value = value;
    element.disabled = true;
  }
}
let selectionOrder = [];
function recordSelection(selectEl) {
  const wasCycleComplete = isCycleComplete();
  
  // Remove from order if deselected
  if (!selectEl?.value) {
    removeFromSelectionOrder(selectEl);
    return;
  }
  
  // Reset cycle if previously complete, otherwise add to order
  if (wasCycleComplete) {
    selectionOrder.length = 0;
    selectionOrder.push(selectEl);
  } else if (!selectionOrder.includes(selectEl)) {
    selectionOrder.push(selectEl);
  }
}
function removeFromSelectionOrder(selectEl) {
  // Remove element from selection order array
  const index = selectionOrder.indexOf(selectEl);
  if (index !== -1) {
    selectionOrder.splice(index, 1);
  }
}
function isCycleComplete() {
  // Check if selection cycle is complete (3 sets or blue *8 multiplier)
  const blueText = DOM_ELEMENTS.blueSet?.selectedOptions[0]?.textContent ?? "";
  const blueIs8x = blueText.includes("*8");
  
  return selectionOrder.length >= 3 || (DOM_ELEMENTS.blueSet?.value && blueIs8x);
}
function resetSelectionOrder() {
  // Reset selection order based on current dropdown values
  selectionOrder.length = 0;
  
  const setElements = [DOM_ELEMENTS.blueSet, DOM_ELEMENTS.vesperSet, DOM_ELEMENTS.whiteSet]
    .filter(Boolean)
    .filter(el => el.value);
  
  selectionOrder.push(...setElements);
}
function setOnlySkip(selectEl) {
  // Disable all options except placeholder
  if (!selectEl) return;
  
  Array.from(selectEl.options).forEach(opt => {
    opt.disabled = !!opt.value;
  });
  selectEl.value = "";
}
function enableAllOptions(selectEl) {
  // Enable all options in select element
  if (!selectEl) return;
  
  Array.from(selectEl.options).forEach(opt => {
    opt.disabled = false;
  });
}
function syncThreeSets() {
  // Synchronize three-set dropdowns based on selection rules
  const setElements = {
    blue: DOM_ELEMENTS.blueSet,
    vesper: DOM_ELEMENTS.vesperSet,
    white: DOM_ELEMENTS.whiteSet
  };
  
  if (!setElements.blue || !setElements.vesper) return;
  
  // Enable all options initially
  Object.values(setElements).filter(Boolean).forEach(enableAllOptions);
  
  const blueText = setElements.blue.selectedOptions[0]?.textContent ?? "";
  const blueIs8x = blueText.includes("*8");
  
  // Blue *8 multiplier rule: disable other sets
  if (setElements.blue.value && blueIs8x) {
    setOnlySkip(setElements.vesper);
    if (setElements.white) setOnlySkip(setElements.white);
    return;
  }
  
  // If any set is selected, disable *8 multiplier options
  if (selectionOrder.length > 0) {
    disableBlue8xOptions(setElements.blue);
  }
  
  // Apply two-set limit rule
  applyTwoSetLimit(setElements);
}
function disableBlue8xOptions(blueElement) {
  // Disable Blue *8 multiplier options and reset if currently selected
  Array.from(blueElement.options).forEach(opt => {
    if (opt.value && opt.textContent.includes("*8")) {
      opt.disabled = true;
    }
  });
  
  // Reset blue selection if it's now disabled
  if (blueElement.value && blueElement.selectedOptions[0]?.disabled) {
    blueElement.value = "";
    removeFromSelectionOrder(blueElement);
  }
}
function applyTwoSetLimit(setElements) {
  // Apply two-set selection limit by disabling unselected sets
  const allSets = Object.values(setElements).filter(Boolean);
  const unselectedSets = allSets.filter(el => !selectionOrder.includes(el));
  
  if (selectionOrder.length >= 2 && unselectedSets.length > 0) {
    unselectedSets.forEach(setOnlySkip);
  }
}
function bindThreeSetListeners() {
  // Bind change event listeners to three-set dropdowns
  const setElements = [DOM_ELEMENTS.blueSet, DOM_ELEMENTS.vesperSet, DOM_ELEMENTS.whiteSet]
    .filter(Boolean);

  setElements.forEach(element => {
    // Skip if already bound to prevent duplicate listeners
    if (element.dataset.boundThree) return;
    
    element.addEventListener("change", () => {
      
      recordSelection(element);
      syncThreeSets();
    });
    
    element.dataset.boundThree = "1";
  });
  
  // Initialize selection order and sync state
  resetSelectionOrder();
  syncThreeSets();
}

// ======== Dynamic UI ========
function handleDropdownChange(event) {
  if (isResultShown) return;
  const elementId = event?.target?.id;
  if (!elementId) return;
  
  if (elementId === 'penCritSelect') {
    clearNumericInput(DOM_ELEMENTS.pen);
    clearNumericInput(DOM_ELEMENTS.crit);
    updateAttackTypeUI();
  }
  if (elementId === 'targetRaceSelect') clearNumericInput(DOM_ELEMENTS.race);
  if (elementId === 'targetElementSelect') clearNumericInput(DOM_ELEMENTS.attr);
  updateDynamicFieldLabels();
}
function updateAttackTypeUI() {
  // show hide field by atktype
  const atkType = DOM_ELEMENTS.atkType.value;
  const penGroup = document.querySelector('.form-group.pen-group');
  const critGroup = document.querySelector('.form-group.crit-group');
  
  if (penGroup && critGroup) {
    penGroup.classList.add('hidden');
    critGroup.classList.add('hidden');
  }
  
  if (atkType === 'pen') {
    if (penGroup) penGroup.classList.remove('hidden');
    DOM_ELEMENTS.pen.disabled = false;
    DOM_ELEMENTS.crit.disabled = true;
    DOM_ELEMENTS.crit.value = '';
  } else if (atkType === 'crit') {
    if (critGroup) critGroup.classList.remove('hidden');
    DOM_ELEMENTS.crit.disabled = false;
    DOM_ELEMENTS.pen.disabled = true;
    DOM_ELEMENTS.pen.value = '';
  } else {
    DOM_ELEMENTS.pen.disabled = true;
    DOM_ELEMENTS.crit.disabled = true;
    DOM_ELEMENTS.pen.value = '';
    DOM_ELEMENTS.crit.value = '';
  }
}
function updateDynamicFieldLabels() {
  // Plebian Vesper Set
const vesperLabels = {
  "48": "BRO?!",
  "56": "REALY?!",
  "64": "Wake UP!",
  "72": "STOP Dreaming!",
  "80": "F2P DETECTED!"
};
const vesperValue = DOM_ELEMENTS.vesperSet.value;
if (!vesperLabels[vesperValue]) {
  DOM_ELEMENTS.vesperSetLabel.textContent = 'Vesper SET'

} else {
    DOM_ELEMENTS.vesperSetLabel.textContent = vesperLabels[vesperValue];
}

  // White SET
const whiteLabels = {
  "36": "Why?",
  "42": "Still dreming yaa",
  "48": "PFTTT!!",
  "54": "Have a Nice Day!"
};
const whiteValue = DOM_ELEMENTS.whiteSet.value;
if (!whiteLabels[whiteValue]) {
  DOM_ELEMENTS.whiteSetLabel.textContent = 'White SET (110*3)';
} else {
  DOM_ELEMENTS.whiteSetLabel.textContent = whiteLabels[whiteValue];
}
  // Race field
  if (DOM_ELEMENTS.tRace.value) {
    DOM_ELEMENTS.race.disabled = false;
    DOM_ELEMENTS.raceLabel.textContent = DOM_ELEMENTS.tRace.value;
    DOM_ELEMENTS.race.placeholder = 'dmg to ' + DOM_ELEMENTS.tRace.value.toLowerCase() + ' % (izlude weapon)';
  } else {
    DOM_ELEMENTS.race.disabled = true;
    DOM_ELEMENTS.raceLabel.textContent = 'Race';
    DOM_ELEMENTS.race.placeholder = 'select target race first';
    DOM_ELEMENTS.race.value = '';
  }

  // Attribute field
  if (DOM_ELEMENTS.tAttr.value) {
    DOM_ELEMENTS.attr.disabled = false;
    DOM_ELEMENTS.attrLabel.textContent = DOM_ELEMENTS.tAttr.value;
    DOM_ELEMENTS.attr.placeholder = 'dmg to ' + DOM_ELEMENTS.tAttr.value.toLowerCase() + ' attr % (weapon alberta)';
  } else {
    DOM_ELEMENTS.attr.disabled = true;
    DOM_ELEMENTS.attrLabel.textContent = '';
    DOM_ELEMENTS.attr.placeholder = 'select target attribute first';
    DOM_ELEMENTS.attr.value = '';
  }

  // PMBO 
  if (DOM_ELEMENTS.atkType.value != '') {
    DOM_ELEMENTS.dmg.disabled = false;
    DOM_ELEMENTS.dmgStack.disabled = false;
    DOM_ELEMENTS.dmg.placeholder = 'final p/m damage bonus %';
    DOM_ELEMENTS.dmgStack.placeholder = 'final damage bonus/stack %'
  } else {
    DOM_ELEMENTS.dmg.disabled = true;
    DOM_ELEMENTS.dmgStack.disabled = true;  
    DOM_ELEMENTS.dmg.placeholder = 'select attack type first';
    DOM_ELEMENTS.dmgStack.placeholder = 'select attack type first'
  }

  // Element field
  if (DOM_ELEMENTS.wElem.value) {
    DOM_ELEMENTS.elemEnh.disabled = false;
    DOM_ELEMENTS.elemEnhLabel.textContent = DOM_ELEMENTS.wElem.value + ' Enhance %';
    DOM_ELEMENTS.elemEnh.placeholder = DOM_ELEMENTS.wElem.value.toLowerCase() + ' enhance %';
  } else {
    DOM_ELEMENTS.elemEnh.disabled = true;
    DOM_ELEMENTS.elemEnhLabel.textContent = 'Element Enhance %';
    DOM_ELEMENTS.elemEnh.placeholder = 'select weapon attribute first';
    DOM_ELEMENTS.elemEnh.value = '';
  }

  // Size enhance field
  if (DOM_ELEMENTS.tSize.value) {
    DOM_ELEMENTS.sizeEnh.disabled = false;
    DOM_ELEMENTS.sizeLabel.textContent = 'DMG to ' + DOM_ELEMENTS.tSize.value + ' %';
    DOM_ELEMENTS.sizeEnh.placeholder = 'dmg to ' + DOM_ELEMENTS.tSize.value.toLowerCase() + ' %';
  } else {
    DOM_ELEMENTS.sizeEnh.disabled = true;
    DOM_ELEMENTS.sizeLabel.textContent = 'DMG to Size %';
    DOM_ELEMENTS.sizeEnh.placeholder = 'select target size first';
    DOM_ELEMENTS.sizeEnh.value = '';
  }
}

// ======== VALIDATION =========
const ValidationSSoT = {
  // Constants
  INVALID_CLASS: 'invalid-value',

  // Optimized Listener Registry with WeakMap for better GC
  listenerRegistry: new Map(),
  elementRefs: new WeakMap(), // Cross-reference for cleanup

  // Cache for performance
  _cache: {
    thresholds: null,
    thresholdTimestamp: 0,
    CACHE_DURATION: 100 // 100ms cache for rapid calls
  },

  // Helper to identify pen & dmg fields - Optimized
  isPenOrDmgField(element) {
    return element && (element.id === 'pen' || element.id === 'dmg');
  },

  // Ultra-safe listener management with better performance
  attachListener(element, eventType, handler, listenerKey) {
    if (!element || !eventType || !handler || !listenerKey) return;

    const elementKey = this.getElementKey(element);
    const fullKey = `${elementKey}_${eventType}_${listenerKey}`;

    // Skip if already exists
    if (this.listenerRegistry.has(fullKey)) return;

    // Use passive listeners where possible for better performance
    const options = (eventType === 'scroll' || eventType === 'touchstart' || eventType === 'touchmove') 
      ? { passive: true } : false;

    // Attach with options
    element.addEventListener(eventType, handler, options);

    // Register with cross-reference for cleanup
    const listenerInfo = { element, eventType, handler, listenerKey, options };
    this.listenerRegistry.set(fullKey, listenerInfo);
    
    // WeakMap cross-reference for element-based cleanup
    if (!this.elementRefs.has(element)) {
      this.elementRefs.set(element, new Set());
    }
    this.elementRefs.get(element).add(fullKey);
  },

  // Optimized listener removal
  removeListener(element, eventType, listenerKey) {
    if (!element || !eventType || !listenerKey) return;

    const elementKey = this.getElementKey(element);
    const fullKey = `${elementKey}_${eventType}_${listenerKey}`;

    const listenerInfo = this.listenerRegistry.get(fullKey);
    if (listenerInfo) {
      element.removeEventListener(eventType, listenerInfo.handler, listenerInfo.options);
      this.listenerRegistry.delete(fullKey);
      
      // Clean cross-reference
      const elementKeys = this.elementRefs.get(element);
      if (elementKeys) {
        elementKeys.delete(fullKey);
        if (elementKeys.size === 0) {
          this.elementRefs.delete(element);
        }
      }
    }
  },

  // Ultra-fast element cleanup using WeakMap
  cleanupElementListeners(element) {
    if (!element) return;

    const elementKeys = this.elementRefs.get(element);
    if (!elementKeys) return;

    // Batch cleanup
    for (const fullKey of elementKeys) {
      const listenerInfo = this.listenerRegistry.get(fullKey);
      if (listenerInfo) {
        element.removeEventListener(listenerInfo.eventType, listenerInfo.handler, listenerInfo.options);
        this.listenerRegistry.delete(fullKey);
      }
    }
    
    this.elementRefs.delete(element);
  },

  // Optimized element key generation
  getElementKey(element) {
    return element.id || (element.className + '_' + (element.dataset.key || Array.prototype.indexOf.call(element.parentNode?.children || [], element)));
  },

  // ===== OPTIMIZED HELPER METHODS =====
  helpers: {
    // Cached validation context for performance
    getValidationContext() {
      const now = performance.now();
      
      // Use cache if fresh
      if (ValidationSSoT._cache.thresholds && 
          (now - ValidationSSoT._cache.thresholdTimestamp) < ValidationSSoT._cache.CACHE_DURATION) {
        return ValidationSSoT._cache.thresholds;
      }

      // Fresh fetch
      const thresholds = ValidationSSoT.getCurrentThresholds();
      const selectedOption = DOM_ELEMENTS.tDef.options[DOM_ELEMENTS.tDef.selectedIndex];
      const targetLabel = selectedOption ? selectedOption.textContent : 'target';
      
      // Cache result
      const result = { thresholds, targetLabel };
      ValidationSSoT._cache.thresholds = result;
      ValidationSSoT._cache.thresholdTimestamp = now;
      
      return result;
    },

    // Micro-optimized number validation with comprehensive cache
    isInvalidNumber: (() => {
      const isValidCache = new Map();
      const CACHE_LIMIT = 100;
      
      return function(value) {
        // Fast path for common cases
        if (value === '' || value === null || value === undefined) return true;
        if (typeof value === 'number') return isNaN(value) || !isFinite(value);
        
        // Cache check
        if (isValidCache.has(value)) return isValidCache.get(value);
        
        const numValue = +value;
        const result = isNaN(numValue) || !isFinite(numValue);
        
        // Manage cache size
        if (isValidCache.size >= CACHE_LIMIT) {
          const firstKey = isValidCache.keys().next().value;
          isValidCache.delete(firstKey);
        }
        
        isValidCache.set(value, result);
        return result;
      };
    })(),

    // Check if value exceeds max attribute
    exceedsMaxValue(element, value) {
      if (!element) return false;
      
      const maxAttr = element.getAttribute("max");
      if (maxAttr === null || maxAttr === '') return false;
      
      const maxVal = +maxAttr;
      const numValue = +(value) || 0;
      
      return numValue > maxVal;
    },

    // Optimized message generation with template caching
    generateRequirementMessage: (() => {
      const templateCache = new Map();
      
      return function(fieldId, threshold, targetLabel) {
        const minRequired = (threshold + 8).toFixed(2);
        
        if (fieldId === 'pen') {
          const penValue = +(DOM_ELEMENTS.pen.value) || 0;
          const penMaxVal = +(DOM_ELEMENTS.pen.getAttribute('max'));
          
          return penValue > penMaxVal ? 
            'what are you doing?' : 
            `Need at least ${minRequired} Final PEN vs ${targetLabel}`;
        } 
        
        if (fieldId === 'dmg') {
          const dmgValue = +(DOM_ELEMENTS.dmg.value) || 0;
          const dmgMaxVal = +(DOM_ELEMENTS.dmg.getAttribute('max'));
          
          return dmgValue > dmgMaxVal ? 
            'what are you doing?' : 
            `Need at least ${minRequired} Final P/M Bonus vs ${targetLabel}`;
        }
      };
    })(),

    // Optimized initialization with debouncing
    performInitialization: (() => {
      let initTimeout;
      
      return function() {
        // Debounce rapid calls
        clearTimeout(initTimeout);
        initTimeout = setTimeout(() => {
          if (!ValidationSSoT.statsValidationState.isReady) {
            ValidationSSoT.initializeStatsValidation();
          }

          if (DOM_ELEMENTS.tDef) {
            const thresholdChangeHandler = () => {
              ValidationSSoT._cache.thresholds = null; // Clear cache
              ValidationSSoT.updateStatsThresholds();
            };

            ValidationSSoT.cleanupElementListeners(DOM_ELEMENTS.tDef);
            ValidationSSoT.attachListener(DOM_ELEMENTS.tDef, 'change', thresholdChangeHandler, 'thresholdUpdate');
          }
        }, 16); // ~1 frame
      };
    })()
  },

  // Cached field configuration
  _fieldRules: null,
  getFieldValidationRules() {
    if (!this._fieldRules) {
      this._fieldRules = [
        { el: DOM_ELEMENTS.atkType, label: 'Attack Type' },
        { el: DOM_ELEMENTS.weapon, label: 'Weapon Type' },
        { el: DOM_ELEMENTS.wElem, label: 'Weapon Attribute' },
        { el: DOM_ELEMENTS.tDef, label: 'Target Boss' },
        { el: DOM_ELEMENTS.tSize, label: 'Target Size' },
        { el: DOM_ELEMENTS.tRace, label: 'Target Race', condition: () => !DOM_ELEMENTS.race.disabled },
        { el: DOM_ELEMENTS.tAttr, label: 'Target Attribute', condition: () => !DOM_ELEMENTS.attr.disabled },
        { el: DOM_ELEMENTS.pen, label: 'Final P M PEN %', condition: () => DOM_ELEMENTS.atkType.value === 'pen' },
        { el: DOM_ELEMENTS.crit, label: 'Critical DMG Bonus %', condition: () => DOM_ELEMENTS.atkType.value === 'crit' },
        { el: DOM_ELEMENTS.dmg, label: 'Final P M DMG Bonus %' },
        { el: DOM_ELEMENTS.elemEnh, label: 'Element Enhance %' },
        { el: DOM_ELEMENTS.sizeEnh, label: 'DMG to Size %' },
        { el: DOM_ELEMENTS.race, label: 'DMG to Race %', condition: () => !DOM_ELEMENTS.race.disabled },
        { el: DOM_ELEMENTS.attr, label: 'DMG to Attribute %', condition: () => !DOM_ELEMENTS.attr.disabled },
        { el: DOM_ELEMENTS.dmgStack, label: 'Final DMG Bonus %' }
      ];
    }
    return this._fieldRules;
  },

  // Optimized threshold fetching with error handling
  getCurrentThresholds() {
    try {
      const defData = getTargetDefenseData(DOM_ELEMENTS.tDef.value || '0def');
      return {
        defVal: +(defData.def) || 0,
        dmgredVal: +(defData.dmgred) || 0
      };
    } catch {
      return { defVal: 0, dmgredVal: 0 };
    }
  },

  // Ultra-optimized class management - REALTIME with smart batching
  applyClassState: (() => {
    const pendingUpdates = new Map(); // Use Map for deduplication
    let updateFrame;
    
    const batchUpdate = () => {
      for (const [element, { isValid, context }] of pendingUpdates) {
        // Skip if element no longer exists in DOM
        if (!element.parentNode) continue;
        
        if (isValid) {
          element.classList.remove(ValidationSSoT.INVALID_CLASS);
        } else {
          element.classList.add(ValidationSSoT.INVALID_CLASS);
          
          // Setup realtime removal for invalid elements
          const removeOnValid = () => {
            if (element.value && element.value !== '') {
              element.classList.remove(ValidationSSoT.INVALID_CLASS);
            }
          };

          ValidationSSoT.attachListener(element, "input", removeOnValid, "fieldValidation");
          ValidationSSoT.attachListener(element, "change", removeOnValid, "fieldValidation");
        }
      }
      pendingUpdates.clear();
    };
    
    return function(element, isValid, context = 'default') {
      if (!element) return;

      // Immediate update for critical operations
      if (context === 'immediate') {
        if (isValid) {
          element.classList.remove(this.INVALID_CLASS);
        } else {
          element.classList.add(this.INVALID_CLASS);
          
          // Setup realtime removal for invalid elements
          const removeOnValid = () => {
            if (element.value && element.value !== '') {
              element.classList.remove(this.INVALID_CLASS);
            }
          };

          this.attachListener(element, "input", removeOnValid, "fieldValidation");
          this.attachListener(element, "change", removeOnValid, "fieldValidation");
        }
        return;
      }

      // Batch non-critical updates with deduplication
      pendingUpdates.set(element, { isValid, context });
      
      if (!updateFrame) {
        updateFrame = requestAnimationFrame(() => {
          batchUpdate();
          updateFrame = null;
        });
      }
    };
  })(),

  // State tracking with optimizations
  statsValidationState: {
    isReady: false,
    isStandby: false,
    touchedFields: new Set()
  },

  // Ultra-optimized stats validation setup
  setupStatsValidation(element) {
    if (!element) return;

    this.cleanupElementListeners(element);

    // ===== REALTIME CLASS MANAGEMENT - HYPER-OPTIMIZED =====
    const realtimeClassValidation = (() => {
      let validationFrame;
      let lastValue = element.value;
      
      return () => {
        // Skip if value hasn't changed
        if (element.value === lastValue && validationFrame) return;
        lastValue = element.value;
        
        // Cancel pending validation
        if (validationFrame) {
          cancelAnimationFrame(validationFrame);
        }
        
        validationFrame = requestAnimationFrame(() => {
          validationFrame = null;
          
          if (!ValidationSSoT.statsValidationState.touchedFields.has(element.id) ||
              ValidationSSoT.statsValidationState.isStandby) return;

          const currentValue = +(element.value) || 0;
          
          // CHECK MAX FIRST - highest priority
          if (ValidationSSoT.helpers.exceedsMaxValue(element, currentValue)) {
            ValidationSSoT.applyClassState(element, false, 'immediate');
            return;
          }
          
          const { thresholds } = ValidationSSoT.helpers.getValidationContext();
          
          let isCurrentlyValid = false;

          if (element.id === 'dmg') {
            const minRequired = thresholds.dmgredVal;
            isCurrentlyValid = currentValue > 0 && (currentValue - minRequired) > 0;
          } else if (element.id === 'pen') {
            const minRequired = thresholds.defVal;
            isCurrentlyValid = currentValue > 0 && (currentValue - minRequired) > 0;
          }

          // REALTIME CLASS MANAGEMENT
          ValidationSSoT.applyClassState(element, isCurrentlyValid, 'immediate');
        });
      };
    })();

    // ===== OPTIMIZED TOUCH DETECTION =====
    const onTouch = () => {
      ValidationSSoT.statsValidationState.touchedFields.add(element.id);
      ValidationSSoT.statsValidationState.isStandby = false;
      realtimeClassValidation();
    };

    // ===== OPTIMIZED BLUR HANDLERS - INDEPENDENT =====
    let onBlur;

    if (element.id === 'pen') {
      onBlur = () => {
        if (!ValidationSSoT.statsValidationState.touchedFields.has('pen') ||
            ValidationSSoT.statsValidationState.isStandby ||
            DOM_ELEMENTS.atkType.value.toLowerCase() !== 'pen') return;

        const penValue = +(DOM_ELEMENTS.pen.value) || 0;
        if (ValidationSSoT.helpers.isInvalidNumber(DOM_ELEMENTS.pen.value) || penValue <= 0) return;

        const { thresholds, targetLabel } = ValidationSSoT.helpers.getValidationContext();
        const defVal = thresholds.defVal;
        const penMaxVal = +(DOM_ELEMENTS.pen.getAttribute('max'));
        const isPenValid = penValue > 0 && (penValue - defVal) > 0 && penValue <= penMaxVal;
        
        if (!isPenValid) {
          const message = ValidationSSoT.helpers.generateRequirementMessage('pen', defVal, targetLabel);
          showSnackbar(message);
        }
      };
    } else if (element.id === 'dmg') {
      onBlur = () => {
        if (!ValidationSSoT.statsValidationState.touchedFields.has('dmg') ||
            ValidationSSoT.statsValidationState.isStandby) return;

        const dmgValue = +(DOM_ELEMENTS.dmg.value) || 0;
        if (ValidationSSoT.helpers.isInvalidNumber(DOM_ELEMENTS.dmg.value) || dmgValue <= 0) return;

        const { thresholds, targetLabel } = ValidationSSoT.helpers.getValidationContext();
        const dmgredVal = thresholds.dmgredVal;
        const dmgMaxVal = +(DOM_ELEMENTS.dmg.getAttribute('max'));
        const isDmgValid = dmgValue > 0 && (dmgValue - dmgredVal) > 0 && dmgValue <= dmgMaxVal;
        
        if (!isDmgValid) {
          const message = ValidationSSoT.helpers.generateRequirementMessage('dmg', dmgredVal, targetLabel);
          showSnackbar(message);
        }
      };
    }

    // ===== ATTACH LISTENERS - BULLETPROOF =====
    this.attachListener(element, "focus", onTouch, "statsTouch");
    this.attachListener(element, "input", realtimeClassValidation, "statsInput");
    this.attachListener(element, "change", realtimeClassValidation, "statsChange");
    if (onBlur) {
      this.attachListener(element, "blur", onBlur, "statsBlur");
    }

    this.statsValidationState.isReady = true;
  },

  // Optimized stats class state
  applyStatsClassState(element, isValid) {
    if (!element) return;
    this.applyClassState(element, isValid, 'immediate');
  },

  // Batch initialization
  initializeStatsValidation() {
    const elements = [DOM_ELEMENTS.pen, DOM_ELEMENTS.dmg].filter(Boolean);
    elements.forEach(el => this.setupStatsValidation(el));
  },

  // Optimized threshold update
  updateStatsThresholds() {
    this.statsValidationState.isStandby = true;
    this.statsValidationState.touchedFields.clear();
    this._cache.thresholds = null; // Clear cache

    // Batch class removal
    [DOM_ELEMENTS.pen, DOM_ELEMENTS.dmg].forEach(el => {
      if (el) el.classList.remove(this.INVALID_CLASS);
    });
  },

  // Optimized threshold change check
  checkStatsAfterThresholdChange() {
    const atkType = DOM_ELEMENTS.atkType.value;
    const { thresholds, targetLabel } = this.helpers.getValidationContext();

    // Batch validation
    const checks = [];

    // PEN check
    if (atkType.toLowerCase() === 'pen' && DOM_ELEMENTS.pen && !this.isEmpty(DOM_ELEMENTS.pen.value)) {
      const penValue = +(DOM_ELEMENTS.pen.value) || 0;
      const defVal = thresholds.defVal;
      const penMaxVal = +(DOM_ELEMENTS.pen.getAttribute('max'));
      const isPenValid = penValue > 0 && (penValue - defVal) > 0 && penValue <= penMaxVal;

      if (!isPenValid) {
        checks.push(() => {
          const message = this.helpers.generateRequirementMessage('pen', defVal, targetLabel);
          showSnackbar(message);
        });
      }
    }

    // DMG check
    if (DOM_ELEMENTS.dmg && !this.isEmpty(DOM_ELEMENTS.dmg.value)) {
      const dmgValue = +(DOM_ELEMENTS.dmg.value) || 0;
      const dmgredVal = thresholds.dmgredVal;
      const dmgMaxVal = +(DOM_ELEMENTS.dmg.getAttribute('max'));
      const isDmgValid = dmgValue > 0 && (dmgValue - dmgredVal) > 0 && dmgValue <= dmgMaxVal;

      if (!isDmgValid) {
        checks.push(() => {
          const message = this.helpers.generateRequirementMessage('dmg', dmgredVal, targetLabel);
          showSnackbar(message);
        });
      }
    }

    // Execute checks
    checks.forEach(check => check());
  },

  // Micro-optimized isEmpty with null safety
  isEmpty: (() => {
    const emptyCache = new Map();
    const CACHE_LIMIT = 50;
    
    return function(value) {
      // Fast path for obvious cases
      if (value === null || value === undefined || value === '') return true;
      if (typeof value !== 'string') return !value;
      
      // Cache check
      if (emptyCache.has(value)) return emptyCache.get(value);
      
      const result = value.trim() === '';
      
      // Manage cache size  
      if (emptyCache.size >= CACHE_LIMIT) {
        const firstKey = emptyCache.keys().next().value;
        emptyCache.delete(firstKey);
      }
      
      emptyCache.set(value, result);
      return result;
    };
  })(),

  // Ultra-optimized numeric normalization
  normalizeNumeric: (() => {
    const normalizeCache = new Map();
    const validPattern = /^\d*\.?\d*$/;
    
    return function(originalValue) {
      if (normalizeCache.has(originalValue)) {
        return normalizeCache.get(originalValue);
      }

      let v = originalValue.trim();
      let hasChanges = false;

      // Batch replacements for better performance
      const beforeClean = v;
      v = v.replace(/[^\d.,]/g, '').replace(/,/g, '.');
      hasChanges = v !== beforeClean;

      // Handle multiple dots
      const dotIndex = v.indexOf('.');
      if (dotIndex !== -1 && v.indexOf('.', dotIndex + 1) !== -1) {
        v = v.slice(0, dotIndex + 1) + v.slice(dotIndex + 1).replace(/\./g, '');
        hasChanges = true;
      }

      // Clean leading zeros and trailing dots
      const beforeZeros = v;
      v = v.replace(/^0+(?=\d)/, '').replace(/\.$/, '');
      if (v !== beforeZeros) hasChanges = true;

      // Fix leading dot
      if (v.startsWith('.')) {
        v = '0' + v;
        hasChanges = true;
      }

      // Validate pattern
      if (!validPattern.test(v) && v !== '') {
        v = '';
        hasChanges = true;
      }

      const result = { value: v, hasChanges };
      
      // Cache with size limit
      if (normalizeCache.size < 100) {
        normalizeCache.set(originalValue, result);
      }
      
      return result;
    };
  })(),

  // Optimized numeric validation
  validateNumericInput(value, element) {
    if (value === '' || isNaN(+value) || !isFinite(+value)) {
      this.applyClassState(element, false, 'immediate');
      return { isValid: false };
    }

    const minVal = +(element.getAttribute("min")) || 0;
    if (+value < minVal) {
      this.applyClassState(element, false, 'immediate');
      return { isValid: false };
    }

    const maxAttr = element.getAttribute("max");
    if (maxAttr !== null && maxAttr !== '') {
      const maxVal = +maxAttr;
      if (+value > maxVal) {
        this.applyClassState(element, false, 'immediate');
        showSnackbar("Bro, you'll broke my engine!");
        return { isValid: false };
      }
    }

    this.applyClassState(element, true, 'immediate');
    return { isValid: true };
  },

  // Enhanced validation with DOM sync control
  validateAndNormalizeInput(element) {
    const originalValue = element.value;
    if (!originalValue) {
      if (!this.isPenOrDmgField(element)) {
        this.applyClassState(element, false, 'immediate');
      }
      return { isValid: false };
    }

    const normalized = this.normalizeNumeric(originalValue);
    
    // Only update DOM if normalization made actual changes
    // Keep original requirement but optimize DOM writes
    if (normalized.hasChanges) {
      // Use original value as per requirement, but we could optimize this
      element.value = element.value;
    }

    const validationResult = this.validateNumericInput(normalized.value, element);

    // Apply class state only for non-PEN/DMG fields
    if (!this.isPenOrDmgField(element)) {
      this.applyClassState(element, validationResult.isValid, 'immediate');
    }

    return validationResult;
  },

  // FIXED: validateRequiredFieldsWithClasses - PEN/DMG now required
  validateRequiredFieldsWithClasses() {
    const fields = this.getFieldValidationRules();

    for (const field of fields) {
      if (!field.el || (field.condition && !field.condition())) continue;

      const fieldValue = field.el.value;
      const isEmpty = this.isEmpty(fieldValue);
      const isPenOrDmg = this.isPenOrDmgField(field.el);

      // Check if field is empty - PEN/DMG now also required
      if (isEmpty) {
        if (!isPenOrDmg) {
          this.applyClassState(field.el, false, 'immediate');
        }
        // PEN/DMG now also fail validation if empty (but no class applied)
        return { isValid: false, field, skipClass: isPenOrDmg };
      }

      // Field has value - validate it for numeric fields
      if (!isPenOrDmg && field.el.type === 'number' || field.el.classList.contains('numeric-input')) {
        const validationResult = this.validateNumericInput(fieldValue, field.el);
        if (!validationResult.isValid) {
          return { isValid: false, field, skipClass: false };
        }
      }
    }

    return { isValid: true, field: null, skipClass: false };
  },

  // Ultra-optimized stats validation with independent paths + max check
  validateStatsWithClasses(state, focusedElement = null) {
    try {
      const { thresholds } = this.helpers.getValidationContext();
      const { defVal, dmgredVal } = thresholds;
      
      let penResult = { isValid: true, element: null };
      let dmgResult = { isValid: true, element: null };

      // ===== INDEPENDENT PEN VALIDATION =====
      if (state.atkType.toLowerCase() === 'pen' && DOM_ELEMENTS.pen) {
        const penVal = +(DOM_ELEMENTS.pen.value) || 0;

        if (this.helpers.isInvalidNumber(DOM_ELEMENTS.pen.value)) {
          this.applyStatsClassState(DOM_ELEMENTS.pen, false);
          penResult = { isValid: false, element: DOM_ELEMENTS.pen };
        } 
        // Check max value first - highest priority
        else if (this.helpers.exceedsMaxValue(DOM_ELEMENTS.pen, penVal)) {
          this.applyStatsClassState(DOM_ELEMENTS.pen, false);
          penResult = { isValid: false, element: DOM_ELEMENTS.pen };
        }
        else {
          const isPenValid = penVal > 0 && (penVal - defVal) > 0;
          this.applyStatsClassState(DOM_ELEMENTS.pen, isPenValid);
          if (!isPenValid) {
            penResult = { isValid: false, element: DOM_ELEMENTS.pen };
          }
        }
      }

      // ===== INDEPENDENT DMG VALIDATION =====
      if (DOM_ELEMENTS.dmg) {
        const dmgVal = +(DOM_ELEMENTS.dmg.value) || 0;

        if (this.helpers.isInvalidNumber(DOM_ELEMENTS.dmg.value)) {
          this.applyStatsClassState(DOM_ELEMENTS.dmg, false);
          dmgResult = { isValid: false, element: DOM_ELEMENTS.dmg };
        }
        // Check max value first - highest priority  
        else if (this.helpers.exceedsMaxValue(DOM_ELEMENTS.dmg, dmgVal)) {
          this.applyStatsClassState(DOM_ELEMENTS.dmg, false);
          dmgResult = { isValid: false, element: DOM_ELEMENTS.dmg };
        }
        else {
          const isDmgValid = dmgVal > 0 && (dmgVal - dmgredVal) > 0;
          this.applyStatsClassState(DOM_ELEMENTS.dmg, isDmgValid);
          if (!isDmgValid) {
            dmgResult = { isValid: false, element: DOM_ELEMENTS.dmg };
          }
        }
      }

      // ===== CONTEXT-BASED RETURN - INDEPENDENT PATHS =====
      if (focusedElement === DOM_ELEMENTS.pen && !penResult.isValid) {
        return penResult;
      }

      if (focusedElement === DOM_ELEMENTS.dmg && !dmgResult.isValid) {
        return dmgResult;
      }

      // Priority: PEN > DMG
      return !penResult.isValid ? penResult : 
             !dmgResult.isValid ? dmgResult : 
             { isValid: true, element: null };

    } catch {
      return { isValid: false, element: null };
    }
  }
};
function normalizeNumericInput(el, pastedValue) {
  if (!el) return;

  const value = (pastedValue ?? el.value).trim();
  const norm = ValidationSSoT.normalizeNumeric(value);

  // PEN/DMG fields: Direct normalization only
  if (ValidationSSoT.isPenOrDmgField(el)) {
    el.value = norm.value;
    return;
  }

  // Other fields: Validate normalized value and update element
  const validationResult = ValidationSSoT.validateNumericInput(norm.value, el);
  el.value = norm.value;
}
function validateRequiredFields() {
  const result = ValidationSSoT.validateRequiredFieldsWithClasses();

  if (!result.isValid && result.field && result.field.el) {
    scrollAndFocusElement(result.field.el);
    return false;
  }

  return true;
}
function validateStatsVsTarget(state, focusedElement = null) {
  // Execute validation but always return true as per original requirement
  const result = ValidationSSoT.validateStatsWithClasses(state, focusedElement);
  
  // Additional realtime threshold check on stats change
  if (!ValidationSSoT.statsValidationState.isStandby) {
    ValidationSSoT.checkStatsAfterThresholdChange();
  }
  
  return result.isValid;
}

// ========== SAFE STATS SYSTEM ==========
const PASSIVE_SUPPORT = (() => {
  let supported = false;
  try {
    const opts = Object.defineProperty({}, 'passive', {
      get() { supported = true; return false; }
    });
    const testHandler = () => {};
    window.addEventListener('test-passive', testHandler, opts);
    window.removeEventListener('test-passive', testHandler, opts);
  } catch (_) {}
  return supported;
})();
const POINTER_SUPPORT = ('PointerEvent' in window && 'onpointerdown' in window);
function showLockedInputMessage(event) {
  const target = event?.currentTarget;
  const now = Date.now();
  
  // Prevent spam clicks with debounce
  if (target) {
    if (target._lastLockTimestamp && (now - target._lastLockTimestamp) < 500) return;
    target._lastLockTimestamp = now;
  }
  
  // Only prevent if wrapper is actually locked
  if (target?.classList?.contains('locked')) {
    if (event?.cancelable) {
      try {
        event.preventDefault();
        event.stopPropagation();
      } catch (_) {}
    }
    
    // Global snackbar debounce to prevent spam
    if (!window._lastSnackbarTime || (now - window._lastSnackbarTime) > 5000) {
      window._lastSnackbarTime = now;
      showSnackbar("Your Stats Locked!");
    }
  }
}
function bindInputLockGuard(wrapElement) {
  if (wrapElement.hasAttribute('data-lock-bound')) return;
  
  const handler = showLockedInputMessage;
  const listeners = [];
  
  if (POINTER_SUPPORT) {
    const opts = { capture: false, passive: false };
    wrapElement.addEventListener('pointerdown', handler, opts);
    listeners.push(['pointerdown', handler, opts]);
  } else {
    const touchOpts = PASSIVE_SUPPORT ? { capture: false, passive: false } : false;
    wrapElement.addEventListener('touchstart', handler, touchOpts);
    listeners.push(['touchstart', handler, touchOpts]);
    wrapElement.addEventListener('click', handler, false);
    listeners.push(['click', handler, false]);
  }
  
  wrapElement._lockListeners = listeners;
  wrapElement.setAttribute('data-lock-bound', '1');
}
function unbindInputLockGuard(wrapElement) {
  if (!wrapElement.hasAttribute('data-lock-bound')) return;
  
  const listeners = wrapElement._lockListeners;
  if (Array.isArray(listeners)) {
    for (const [type, handler, opts] of listeners) {
      try {
        wrapElement.removeEventListener(type, handler, opts);
      } catch (_) {}
    }
  }
  
  delete wrapElement._lockListeners;
  delete wrapElement._lastLockTimestamp;
  wrapElement.removeAttribute('data-lock-bound');
}
function lockAllInputs() {
  // Auto-detect and lock all form elements in .input-wrap containers
  document.querySelectorAll('.input-wrap').forEach(wrapper => {
    const elements = wrapper.querySelectorAll('input, select, textarea');
    if (elements.length === 0) return;
    
    // Lock all form elements in this wrapper
    elements.forEach(el => el.disabled = true);
    
    // Add visual feedback and bind guard
    wrapper.classList.add('locked');
    bindInputLockGuard(wrapper);
  });
}
function unlockAllInputs() {
  // Auto-detect and unlock all form elements in .input-wrap containers
  document.querySelectorAll('.input-wrap').forEach(wrapper => {
    const elements = wrapper.querySelectorAll('input, select, textarea');
    if (elements.length === 0) return;
    
    // Unlock all form elements in this wrapper
    elements.forEach(el => el.disabled = false);
    
    // Remove visual feedback and unbind guard
    wrapper.classList.remove('locked');
    unbindInputLockGuard(wrapper);
  });
}

// ========== NOTIFICATION SYSTEM ==========
let snackbarTimer = null;
function showSnackbar(text) {
  const sb = DOM_ELEMENTS.snackbar;
  if (!sb) return;
  sb.textContent = text;
  if (snackbarTimer) clearTimeout(snackbarTimer);
  sb.classList.remove('show');
  void sb.offsetWidth;
  sb.classList.add('show');
  snackbarTimer = setTimeout(() => {
    sb.classList.remove('show');
  }, 3000);
}
const snackbarAdjusted = document.querySelector(".snackbar");
const inputAdjusted = document.querySelector("input[type=number]");
if (window.innerWidth <= 480) {
  if (window.visualViewport) {
    function updatePosition() {
      const keyboardHeight = window.innerHeight - window.visualViewport.height;
      snackbarAdjusted.style.bottom = 80 + keyboardHeight + "px";
    }
    window.visualViewport.addEventListener("resize", updatePosition);
    window.visualViewport.addEventListener("scroll", updatePosition);
  } else {
    inputAdjusted.addEventListener("focus", () => {
      snackbarAdjusted.style.bottom = "300px";
    });
    inputAdjusted.addEventListener("blur", () => {
      snackbarAdjusted.style.bottom = "16px";
    });
  }
}
function scrollAndFocusElement(el, msg) {
  if (msg) showSnackbar(msg);
  const top = el.getBoundingClientRect().top + window.scrollY - 80;
  window.scrollTo({ top, behavior: 'smooth' });
  if (!el.disabled) el.focus({ preventScroll: true });
  return false;
}
const TOOLTIP_CONFIG = {
  // Hardcode selector
  "#dmgStackTips" : "<strong>Final DMG Bonus</strong> and <strong>F. P/M DMG BONUS</strong> are two <strong>different</strong> things! Look for it in your <strong>detailed stats</strong> where it shows as <strong>Final Damage Stack</strong> or <strong>Final Damage Bonus</strong>. Make sure you don't have any buffs active. Can't find it? Just set 0.",
  "#targetRaceTips" : "Specific MVP/MINi will <strong>auto sync and lock</strong> this option. Select <strong>Avg Lvl Boss</strong> if you want to target spesific race!",
  "#targetAttrTips" : "also same with race.",
  "#dmgRaceTips" : "Unlocked when target race selected, minimum valid value is 0.",
  "#dmgAttrTips" : "same condition with dmg to race"
};
function createTooltip(triggerElement, content) {
  if (!triggerElement || !content) return;
  
  // Create tooltip element
  const tooltipElement = document.createElement("div");
  tooltipElement.className = "tooltip-wrap";
  tooltipElement.innerHTML = content;
  document.body.appendChild(tooltipElement);
  
  let isTooltipVisible = false;
  
  // Toggle tooltip visibility
  function toggleTooltip(event) {
    event.stopPropagation();
    event.preventDefault();
    
    if (isTooltipVisible) {
      hideTooltip();
    } else {
      showTooltip();
    }
  }
  
  function showTooltip() {
    positionTooltip();
    tooltipElement.classList.add('visible');
    isTooltipVisible = true;
  }
  
  function hideTooltip() {
    tooltipElement.classList.remove('visible');
    isTooltipVisible = false;
  }
  
  function positionTooltip() {
    const triggerRect = triggerElement.getBoundingClientRect();
    const scrollX = window.pageXOffset;
    const scrollY = window.pageYOffset;
    
    // Get tooltip dimensions
    tooltipElement.style.visibility = 'hidden';
    tooltipElement.style.display = 'block';
    const tooltipWidth = tooltipElement.offsetWidth;
    const tooltipHeight = tooltipElement.offsetHeight;
    tooltipElement.style.visibility = '';
    tooltipElement.style.display = '';
    
    // Calculate center position relative to trigger
    let leftPosition = triggerRect.left + scrollX + (triggerRect.width / 2);
    let topPosition = triggerRect.top + scrollY - tooltipHeight - 12;
    
    // Keep tooltip in viewport
    const viewportPadding = 16;
    const maxLeft = window.innerWidth - tooltipWidth - viewportPadding;
    leftPosition = Math.max(viewportPadding, Math.min(leftPosition - (tooltipWidth / 2), maxLeft));
    
    // Flip to bottom if no space at top
    if (topPosition < viewportPadding) {
      topPosition = triggerRect.bottom + scrollY + 12;
    }
    
    // Use transform for smoother positioning
    tooltipElement.style.left = '0px';
    tooltipElement.style.top = '0px';
    tooltipElement.style.transform = `translate(${leftPosition}px, ${topPosition}px)`;
  }
  
  // Event handlers for tooltip interaction
  triggerElement.addEventListener("click", toggleTooltip);
  triggerElement.addEventListener("touchend", function(event) {
    event.preventDefault();
    toggleTooltip(event);
  });
  
  triggerElement.addEventListener("keydown", function(event) {
    if (event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      toggleTooltip(event);
    } else if (event.key === "Escape" && isTooltipVisible) {
      hideTooltip();
    }
  });
  
  document.addEventListener("click", function(event) {
    if (isTooltipVisible && !triggerElement.contains(event.target) && !tooltipElement.contains(event.target)) {
      hideTooltip();
    }
  });
  
  // Handle touch events for mobile
  document.addEventListener("touchend", function(event) {
    if (isTooltipVisible && !triggerElement.contains(event.target) && !tooltipElement.contains(event.target)) {
      hideTooltip();
    }
  });
  
  document.addEventListener("keydown", function(event) {
    if (event.key === "Escape" && isTooltipVisible) hideTooltip();
  });
  
  // Reposition on viewport changes
  window.addEventListener('resize', () => isTooltipVisible && positionTooltip());
  window.addEventListener('scroll', () => isTooltipVisible && positionTooltip());
}
function setupTooltips(config) {
  Object.entries(config).forEach(([key, content]) => {
    let elements = [];
    
    try {
      if (typeof key === 'string') {
        // Handle selector string like "#dmg-help", ".tooltip-trigger"
        elements = document.querySelectorAll(key);
      } else {
        // Handle DOM element directly from cache
        // Convert element reference to actual element
        const element = (typeof key === 'object' && key instanceof Element) ? key : null;
        if (element) {
          elements = [element];
        }
      }
      
      // Apply tooltip to all matched elements
      elements.forEach(element => {
        if (element && element instanceof Element) {
          createTooltip(element, content);
        }
      });
    } catch (error) {
      console.warn('Error setting up tooltip for key:', key, error);
    }
  });
}

// ========== EVENT BINDING  ==========
function bindAllEventListeners() {
  if (bindAllEventListeners.bound) return;
  bindAllEventListeners.bound = true;

  populateDropdownOptions();
  
DOM_ELEMENTS.submit.addEventListener('click', () => {
  processMainCalculation();

});

DOM_ELEMENTS.resetRek.addEventListener('click', () => {
  regenerateRecommendations();
  if (typeof showSnackbar === 'function') {
    showSnackbar("Table Refreshed!");
  }
});

DOM_ELEMENTS.resetAll.addEventListener('click', () => {
  unlockAllInputs();
  resetAllData()});

  // Test button listeners (guarded to avoid double binding)
  try {
    if (DOM_ELEMENTS.testReaper && !DOM_ELEMENTS.testReaper.dataset.simBound) {
      DOM_ELEMENTS.testReaper.addEventListener('click', simulateFlash);
      DOM_ELEMENTS.testReaper.dataset.simBound = '1';
    }
    if (DOM_ELEMENTS.testSpear && !DOM_ELEMENTS.testSpear.dataset.simBound) {
      DOM_ELEMENTS.testSpear.addEventListener('click', simulateFlash);
      DOM_ELEMENTS.testSpear.dataset.simBound = '1';
    }
  } catch (e) { console.warn('attach test listeners', e); }


  // Dropdown change listeners
  [
    'penCritSelect', 'weaponSelect', 'weaponElementSelect',
    'targetSizeSelect', 'targetRaceSelect', 'targetElementSelect','vesperSet','whiteSet'
  ].forEach(elementId => {
    const element = document.getElementById(elementId);
    if (element) element.addEventListener('change', handleDropdownChange);
  });
  
  // Numeric input validation
  ["pen", "crit", "dmg", "elemEnh", "sizeEnh", "race", "attr", "dmgStack"].forEach(fieldKey => {
    const element = DOM_ELEMENTS[fieldKey];
    if (!element) return;
    element.addEventListener("blur", () => normalizeNumericInput(element));
    element.addEventListener("paste", event => {
      event.preventDefault();
      let pastedText = (event.clipboardData || window.clipboardData).getData("text");
      normalizeNumericInput(element, pastedText);
    });
  });
}

// ======== ACCORDION =========
document.querySelectorAll("details").forEach(function(details) {
  const summary = details.querySelector("summary");
  const content = details.querySelector(".body");
  
  summary.addEventListener("click", function(e) {
    e.preventDefault();
    if (details.hasAttribute("open")) {
      content.style.maxHeight = content.scrollHeight + "px";
      requestAnimationFrame(function() {
        content.style.maxHeight = "0px";
      });
      const closeHandler = function() {
        details.removeAttribute("open");
        content.removeEventListener("transitionend", closeHandler);
      };
      content.addEventListener("transitionend", closeHandler);
    } else {
      details.setAttribute("open", "");
      content.style.maxHeight = "0px";
      requestAnimationFrame(function() {
        content.style.maxHeight = content.scrollHeight + "px";
      });
    }
  });
});

// ======== OPTIMIZED STICKY HANDLER ========
class StickyHandler {
  constructor() {
    this.elements = new Map();
    this.isActive = false;
    this.isCollapsed = false;
    this.observers = new Set();
    this.rafId = null;
    this.lastScrollY = 0;
    this.isMobile = false;
    
    // Pre-calculate constants
    this.MOBILE_BREAKPOINT = 480;
    this.BUTTON_HEIGHT = 56;
    this.BASE_OFFSET = 20;
    
    // Cached DOM queries
    this.cache = new Map();
    
    this.init();
  }

  // Optimized element getter with caching
  getElement(id) {
    if (this.cache.has(id)) {
      return this.cache.get(id);
    }
    
    const element = document.getElementById(id);
    if (element) {
      this.cache.set(id, element);
    }
    return element;
  }

  // Clear cache when DOM changes
  clearCache() {
    this.cache.clear();
  }

  // Calculate safe bottom position
  calculateSafeBottomPosition(index = 0) {
    return `calc(${this.BASE_OFFSET + index * this.BUTTON_HEIGHT}px + env(safe-area-inset-bottom))`;
  }

  // Initialize all sticky elements - MINIMAL APPROACH
  initElements() {
    const elementIds = {
      resetRek: "resetRekomenBtn",
      resetAll: "resetAllBtn", 
      swapBoss: "breakdown-swap",
      swapLabel: "swap-label",
      stickyStart: DOM_ELEMENTS?.hasil,
      testSpear: DOM_ELEMENTS?.testSpear,
      testReaper: DOM_ELEMENTS?.testReaper
    };

    // JUST GET REFERENCES, DON'T INTERFERE WITH EXISTING ELEMENTS
    Object.entries(elementIds).forEach(([key, id]) => {
      const element = typeof id === 'string' ? this.getElement(id) : id;
      if (element) {
        this.elements.set(key, element);
        // Only preserve text for non-critical buttons
        if (!['swapBoss', 'swapLabel'].includes(key)) {
          this.preserveOriginalText(element);
        }
      }
    });

    // Create our own buttons only
    this.initToggleButton();
    this.initBackButton();
  }

  // Initialize toggle button with safe creation
  initToggleButton() {
    let toggleBtn = this.getElement("toggleStickyBtn");
    
    if (!toggleBtn) {
      toggleBtn = document.createElement("button");
      toggleBtn.id = "toggleStickyBtn";
      toggleBtn.className = "sticky-toggle";
      toggleBtn.setAttribute("data-collapse", "false");
      document.body.appendChild(toggleBtn);
      this.cache.set("toggleStickyBtn", toggleBtn);
    }
    
    this.elements.set('toggleBtn', toggleBtn);
    
    // Only bind if not already bound
    if (!toggleBtn.hasAttribute('data-sticky-bound')) {
      toggleBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        this.isCollapsed = !this.isCollapsed;
        toggleBtn.setAttribute("data-collapse", this.isCollapsed.toString());
        toggleBtn.classList.toggle("active", !this.isCollapsed);
        
        this.updateStickyState(true);
      }, { passive: false });
      
      toggleBtn.setAttribute('data-sticky-bound', 'true');
    }
  }

  // Initialize back button with safe creation
  initBackButton() {
    let backBtn = this.getElement("backToHasilBtn");
    
    if (!backBtn) {
      backBtn = document.createElement("button");
      backBtn.id = "backToHasilBtn";
      backBtn.className = "sticky-back";
      document.body.appendChild(backBtn);
      this.cache.set("backToHasilBtn", backBtn);
    }
    
    this.elements.set('backBtn', backBtn);
    
    if (!backBtn.hasAttribute('data-sticky-bound')) {
      backBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        const stickyStart = this.elements.get('stickyStart');
        if (stickyStart) {
          stickyStart.scrollIntoView({ 
            behavior: "smooth",
            block: "start",
            inline: "nearest"
          });
        }
      }, { passive: false });
      
      backBtn.setAttribute('data-sticky-bound', 'true');
    }
  }

  // Preserve original text for buttons
  preserveOriginalText(element) {
    if (element && !element.hasAttribute("data-original-text")) {
      element.setAttribute("data-original-text", element.textContent || "");
    }
  }

  // Check if mobile view
  checkMobileView() {
    const newIsMobile = window.innerWidth <= this.MOBILE_BREAKPOINT;
    if (newIsMobile !== this.isMobile) {
      this.isMobile = newIsMobile;
      return true;
    }
    return false;
  }

  // Get all sticky buttons in order
  getStickyButtons() {
    const buttonOrder = [
      'toggleBtn',
      'swapBoss', 
      'testSpear',
      'testReaper',
      'resetRek',
      'resetAll',
      'backBtn'
    ];
    
    return buttonOrder
      .map(key => this.elements.get(key))
      .filter(Boolean);
  }

  // Reset all sticky styles - MINIMAL INTERFERENCE
  resetStickyStyles() {
    const allButtons = this.getStickyButtons();
    
    allButtons.forEach(button => {
      // Only remove classes we added
      button.classList.remove("sticky", "collapsed");
      // Only reset styles we set
      button.style.transform = "";
      
      const originalText = button.getAttribute("data-original-text");
      if (originalText !== null) {
        button.textContent = originalText;
      }
    });
    
    const swapLabel = this.elements.get('swapLabel');
    if (swapLabel) {
      swapLabel.classList.remove("hidden");
    }
  }

  // Update sticky state efficiently
  updateStickyState(force = false) {
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
    }
    
    this.rafId = requestAnimationFrame(() => {
      this.performStickyUpdate(force);
      this.rafId = null;
    });
  }

  // Main sticky update logic
  performStickyUpdate(force = false) {
    const viewChanged = this.checkMobileView();
    
    // Desktop mode - disable sticky
    if (!this.isMobile) {
      if (viewChanged || force) {
        this.isActive = false;
        this.resetStickyStyles();
      }
      return;
    }

    // Mobile mode - check if sticky should be active
    const stickyStart = this.elements.get('stickyStart');
    if (!stickyStart) return;
    
    const rect = stickyStart.getBoundingClientRect();
    const shouldBeActive = rect.top <= 0;
    
    if (!force && shouldBeActive === this.isActive && !viewChanged) {
      return;
    }
    
    this.isActive = shouldBeActive;
    
    const swapLabel = this.elements.get('swapLabel');
    if (swapLabel) {
      swapLabel.classList.toggle("hidden", this.isActive);
    }

    if (!this.isActive) {
      this.resetStickyStyles();
      return;
    }

    this.applyStickyStyles();
  }

  // Apply sticky styles to buttons - MINIMAL CSS CHANGES
  applyStickyStyles() {
    const buttons = this.getStickyButtons();
    
    buttons.forEach((button, index) => {
      button.classList.add("sticky");
      button.classList.toggle("collapsed", this.isCollapsed);
      
      const transform = this.isCollapsed ? 
        "translateY(0)" : 
        `translateY(-${index * this.BUTTON_HEIGHT}px)`;
      button.style.transform = transform;
    });
    
    this.updateButtonText();
  }

  // Update button text based on sticky state
  updateButtonText() {
    const textButtons = ['resetRek', 'resetAll', 'testSpear', 'testReaper'];
    
    textButtons.forEach(key => {
      const button = this.elements.get(key);
      if (!button) return;
      
      const originalText = button.getAttribute("data-original-text") || "";
      button.textContent = this.isActive ? "" : originalText;
    });
  }

  // Throttled scroll handler
  createScrollHandler() {
    let ticking = false;
    
    return () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          const newScrollY = window.pageYOffset || document.documentElement.scrollTop;
          if (Math.abs(newScrollY - this.lastScrollY) > 5) {
            this.updateStickyState();
            this.lastScrollY = newScrollY;
          }
          ticking = false;
        });
        ticking = true;
      }
    };
  }

  // Initialize with proper error handling
  init() {
    try {
      this.initElements();
      
      const scrollHandler = this.createScrollHandler();
      const resizeHandler = () => this.updateStickyState(true);
      
      const eventOptions = { passive: true, capture: false };
      
      window.addEventListener('scroll', scrollHandler, eventOptions);
      window.addEventListener('resize', resizeHandler, eventOptions);
      
      if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
        window.addEventListener('orientationchange', () => {
          setTimeout(() => this.updateStickyState(true), 200);
        }, eventOptions);
      }
      
      this.updateStickyState(true);
      
    } catch (error) {
      console.error('StickyHandler initialization failed:', error);
    }
  }

  // Mutation observer for dynamic content
  initMutationObserver() {
    if (typeof MutationObserver === 'undefined') return;
    
    const observer = new MutationObserver((mutations) => {
      let needsUpdate = false;
      
      mutations.forEach(mutation => {
        if (mutation.type === 'childList') {
          const hasImportantElement = Array.from(mutation.addedNodes).some(node => 
            node.nodeType === 1 && (
              node.id === 'breakdown-swap' || 
              ['resetRekomenBtn', 'resetAllBtn', 'swap-label'].includes(node.id) ||
              node.querySelector?.('#breakdown-swap, #resetRekomenBtn, #resetAllBtn, #swap-label')
            )
          );
          
          if (hasImportantElement) {
            needsUpdate = true;
          }
        }
      });
      
      if (needsUpdate) {
        // Clear specific cache entries
        ['breakdown-swap', 'resetRekomenBtn', 'resetAllBtn', 'swap-label'].forEach(id => {
          this.cache.delete(id);
        });
        
        setTimeout(() => {
          this.initElements();
          this.updateStickyState(true);
        }, 50);
      }
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    
    this.observers.add(observer);
  }

  // Cleanup method
  destroy() {
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
    }
    
    this.observers.forEach(observer => observer.disconnect());
    this.observers.clear();
    
    this.cache.clear();
    this.elements.clear();
  }
}
function calculateSafeBottomPosition(index = 0) {
  if (window.stickyHandler) {
    return window.stickyHandler.calculateSafeBottomPosition(index);
  }
  // Fallback
  return `calc(${20 + index * 56}px + env(safe-area-inset-bottom))`;
}
function manageStickyElements() {
  if (window.stickyHandler) {
    window.stickyHandler.updateStickyState(true);
  }
}

// ======== INTEGRATION WITH GLOBAL INIT ========
class AppInitializer {
  constructor() {
    this.isInitialized = false;
    this.observers = new Set();
    this.eventHandlers = new Map();
    this.stickyHandler = null;
    
    // Optimized throttle for viewport changes
    this.viewportChangeHandler = this.rafThrottle(() => {
      if (this.stickyHandler) {
        this.stickyHandler.updateStickyState();
      }
    });
    
    this.init();
  }

  // RAF-based throttle for better performance
  rafThrottle(func) {
    let rafId = null;
    let lastArgs = null;
    
    const throttled = (...args) => {
      lastArgs = args;
      if (rafId === null) {
        rafId = requestAnimationFrame(() => {
          func.apply(this, lastArgs);
          rafId = null;
        });
      }
    };
    
    throttled.cancel = () => {
      if (rafId !== null) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
    };
    
    return throttled;
  }

  // Legacy throttle for backward compatibility
  throttle(func, delay) {
    let timeoutId;
    let lastExecTime = 0;
    
    return (...args) => {
      const currentTime = Date.now();
      
      if (currentTime - lastExecTime > delay) {
        func.apply(this, args);
        lastExecTime = currentTime;
      } else {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          func.apply(this, args);
          lastExecTime = Date.now();
        }, delay - (currentTime - lastExecTime));
      }
    };
  }

  // Safe DOM element getter
  getElement(selector) {
    try {
      return typeof selector === 'string' ? document.getElementById(selector) : selector;
    } catch {
      return null;
    }
  }

  // Centralized event listener management
  addEventListenerSafe(element, event, handler, options = {}) {
    if (!element) return false;
    
    const key = `${element.id || 'anonymous'}-${event}`;
    if (this.eventHandlers.has(key)) return false;
    
    const safeOptions = { once: false, passive: true, ...options };
    element.addEventListener(event, handler, safeOptions);
    this.eventHandlers.set(key, { element, event, handler, options: safeOptions });
    
    return true;
  }

  // Initialize sticky handler
  initStickyHandler() {
    if (!this.stickyHandler) {
      this.stickyHandler = new StickyHandler();
      this.stickyHandler.initMutationObserver();
      
      // Expose globally for backward compatibility
      window.stickyHandler = this.stickyHandler;
    }
  }

  // Initialize mutation observer for non-sticky related changes
  initMutationObserver() {
    if (typeof MutationObserver === 'undefined') return;
    
    const observer = new MutationObserver((mutations) => {
      const hasBreakdownSwap = mutations.some(mutation => 
        Array.from(mutation.addedNodes).some(node => 
          node.nodeType === 1 && (node.id === 'breakdown-swap' || 
          node.querySelector?.('#breakdown-swap'))
        )
      );
      
      if (hasBreakdownSwap && !this.stickyHandler) {
        requestAnimationFrame(() => this.initStickyHandler());
      }
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    
    this.observers.add(observer);
  }

  // Initialize modal functionality
  initModal() {
    const { log, openLog, closeLog } = DOM_ELEMENTS || {};
    if (!log) return;
    
    log.style.display = 'none';
    
    if (openLog) {
      this.addEventListenerSafe(openLog, 'click', () => {
        log.style.display = 'flex';
      });
    }
    
    if (closeLog) {
      this.addEventListenerSafe(closeLog, 'click', () => {
        log.style.display = 'none';
      });
    }
  }

  // Initialize core functionality
  initCore() {
    const coreInitializers = [
      'bindAllEventListeners',
      'updateAttackTypeUI', 
      'updateDynamicFieldLabels'
    ];
    
    coreInitializers.forEach(funcName => {
      if (typeof window[funcName] === 'function') {
        try {
          window[funcName]();
        } catch (error) {
          console.warn(`Failed to initialize ${funcName}:`, error);
        }
      }
    });
  }

  // Initialize viewport change handlers
  initViewportHandlers() {
    this.addEventListenerSafe(window, 'scroll', this.viewportChangeHandler, { passive: true });
    this.addEventListenerSafe(window, 'resize', this.viewportChangeHandler, { passive: true });
    
    // iOS viewport fix
    if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
      this.addEventListenerSafe(window, 'orientationchange', () => {
        setTimeout(() => this.viewportChangeHandler(), 200);
      });
    }
  }

  // Initialize validation
  initValidation() {
    if (typeof ValidationSSoT !== 'undefined' && 
        ValidationSSoT.helpers?.performInitialization) {
      try {
        ValidationSSoT.helpers.performInitialization();
      } catch (error) {
        console.warn('Validation initialization failed:', error);
      }
    }
  }

  // Legacy method for backward compatibility
  manageStickyElements() {
    if (this.stickyHandler) {
      this.stickyHandler.updateStickyState(true);
    }
  }

  // Initialize tooltip
  initTooltip() {
    if (typeof TOOLTIP_CONFIG !== 'undefined' && typeof setupTooltips === 'function') {
      try {
        setupTooltips(TOOLTIP_CONFIG);
      } catch (error) {
        console.warn('Tooltip initialization failed:', error);
      }
    }
  }

  // Main initialization
  initializeApp() {
    if (!DOM_ELEMENTS?.log) {
      console.warn('DOM_ELEMENTS.log not found');
      return;
    }
    
    this.initMutationObserver();
    this.initModal();
    this.initCore();
    this.initStickyHandler(); // Initialize sticky handler
    this.initViewportHandlers();
    this.initTooltip();
    this.initValidation();
  }

  // Safe initialization with duplicate prevention
  safeInit() {
    if (this.isInitialized) return;
    
    this.isInitialized = true;
    
    try {
      this.initializeApp();
    } catch (error) {
      console.error('App initialization failed:', error);
      this.isInitialized = false;
    }
  }

  // Main entry point
  init() {
    if (document.readyState === 'loading') {
      this.addEventListenerSafe(document, 'DOMContentLoaded', 
        () => this.safeInit(), 
        { once: true, passive: false }
      );
    } else {
      requestAnimationFrame(() => this.safeInit());
    }
  }

  // Cleanup method for SPA scenarios
  destroy() {
    // Cancel RAF throttle
    if (this.viewportChangeHandler?.cancel) {
      this.viewportChangeHandler.cancel();
    }
    
    // Destroy sticky handler
    if (this.stickyHandler) {
      this.stickyHandler.destroy();
      this.stickyHandler = null;
      window.stickyHandler = null;
    }
    
    // Remove all event listeners
    this.eventHandlers.forEach(({ element, event, handler, options }) => {
      element.removeEventListener(event, handler, options);
    });
    this.eventHandlers.clear();
    
    // Disconnect observers
    this.observers.forEach(observer => observer.disconnect());
    this.observers.clear();
    
    this.isInitialized = false;
  }
}
const appInitializer = new AppInitializer();
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { AppInitializer, StickyHandler };
} else if (typeof window !== 'undefined') {
  window.AppInitializer = AppInitializer;
  window.StickyHandler = StickyHandler;
  // Legacy global functions
  window.calculateSafeBottomPosition = calculateSafeBottomPosition;
  window.manageStickyElements = manageStickyElements;
}

// ======== RESET ========
function resetAllData() {
  if (!confirm('Reset all data')) return;
  
  document.querySelectorAll('input').forEach(input =>
    input.value = ''
  );
  document.querySelectorAll('select').forEach(select => select.value = '');
  
  isResultShown = false;
  processMainCalculationTimeout = null;
  isTestReaperActive = false;
  isTestSpearActive = false;
  isFlashActive = false;
  
  selectionOrder = [];
  bindThreeSetListeners();
  
  DOM_ELEMENTS.hasil.textContent = 'Input your stats to see the result...';
  DOM_ELEMENTS.rec.textContent = 'Balancing stat recommendations for a higher output multiplier.';
  DOM_ELEMENTS.submit.disabled = false;
  DOM_ELEMENTS.resetRek.disabled = true;
  DOM_ELEMENTS.resetAll.disabled = true;
  DOM_ELEMENTS.testSpear.disabled = true;
  DOM_ELEMENTS.testReaper.disabled = true;
  
  DOM_ELEMENTS.testSpear.classList.remove('activated');
  DOM_ELEMENTS.testReaper.classList.remove('activated');
  // reset test flags and their UI 
  updateAttackTypeUI();
  updateDynamicFieldLabels();
  scrollAndFocusElement(DOM_ELEMENTS.topOfPage, 'Cleared!')
  
}
</script>
 </body>
</html>
