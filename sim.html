<!DOCTYPE html>
<!-- 96% chatgpt, 3% claude sonnet, 1% me just asking ai to write this line -->
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1" name="viewport"/>
  <title>Alt-Sim</title>
  <meta name="description" content="Calculate your base, randomize your stats!"/>
  <style>/* Reset */
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#f9f9fb;--text:#2e2e2e;--label:#1a1a1a;--primary:#3f51b5;--secondary:#607d8b;
  --danger:#f44336;--border:#e6e9ef;--radius:12px;--shadow:0 4px 12px rgba(0,0,0,0.06)
}
body{font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text);line-height:1.5;padding-bottom:env(safe-area-inset-bottom);}

.container{max-width:800px;margin:0 auto;padding:20px}

.form-row{display:grid;grid-template-columns:repeat(2,1fr);gap:20px;margin-bottom:16px}
.form-group{display:flex;flex-direction:column}
.form-group label{font-size:1.05rem;font-weight:700;margin-bottom:8px;color:#111;letter-spacing:.3px}

.input-wrap select,
.input-wrap input{
  font-size:.95rem;height:44px;width:100%;padding:8px 12px;
  border:1px solid var(--border);border-radius:8px;background:#fff;box-shadow:var(--shadow);
  color:#999;transition:background .2s,opacity .2s
}
.input-wrap select{padding:8px 36px 8px 12px;appearance:none;-webkit-appearance:none;-moz-appearance:none;
  background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='gray'><path d='M4 6l4 4 4-4z'/></svg>");
  background-repeat:no-repeat;background-position:right 12px center;background-size:16px
}
.input-wrap select:focus,
.input-wrap input:focus{
  border-color:var(--primary);outline:none;box-shadow:0 0 0 2px rgba(63,81,181,.2)
}

.input-wrap select:disabled,
.input-wrap input:disabled{
  background:#f1f1f1;color:#999;opacity:.6;cursor:not-allowed;box-shadow:none
}

.btn-row{display:flex;gap:12px;margin-top:18px}
.btn-row button{
  height:44px;padding:0 16px;border:none;border-radius:8px;cursor:pointer;font-weight:600;color:#fff;
  transition:background .2s ease,opacity .2s ease
}
#submitBtn{background:#5a6fd6}
#submitBtn:hover{background:#4a5fc1}
#resetRekomenBtn{background:#7c8d98}
#resetRekomenBtn:hover{background:#6c7d88}
#resetAllBtn{background:#e35b54}
#resetAllBtn:hover{background:#d54b44}
#submitBtn:disabled,#resetRekomenBtn:disabled,#resetAllBtn:disabled{opacity:.5;cursor:not-allowed}

#hasil,#recommendations{
  background:#fff;padding:14px;margin-top:16px;border:1px solid var(--border);
  border-radius:8px;box-shadow:var(--shadow)
}

#recommendations{display:grid;grid-template-columns:repeat(2,1fr);gap:16px}
.table-wrapper{
  width:100%;overflow-x:auto;padding:0;margin:0;border-radius:8px;
  border:1px solid #f0f0f0;background:#fff;box-shadow:0 6px 14px rgba(0,0,0,.05)
}

#recommendations table{width:100%;border-collapse:collapse;background:transparent;border:none;border-radius:inherit;margin:0}
#recommendations caption{
  text-align:left;font-weight:700;font-size:1.1rem;padding:12px 14px;background:#f5f6f8;
  border-bottom:1px solid var(--border);border-radius:8px 8px 0 0
}
#recommendations th,#recommendations td{
  padding:10px;border:1px solid #eee;text-align:center;font-size:.9rem
}
#recommendations th{background:#f5f6f8;font-weight:600;color:#444}

#recommendations td span{display:inline-flex;align-items:center;justify-content:center;gap:2px}
span.up::before{content:"\25B2";color:#4CAF50;font-size:.55em;margin-right:1px;position:relative;top:.5px}
span.down::before{content:"\25BC";color:#2196F3;font-size:.55em;margin-right:1px;position:relative;top:.5px}
span.neutral::before{content:"\25A0";color:#9E9E9E;font-size:.45em;margin-right:1px;position:relative;top:.5px}
td.mult{font-weight:bold}
td.delta{color:#4CAF50;font-weight:500}

.snackbar{
  position:fixed;left:50%;transform:translateX(-50%);bottom:16px;
  background:rgba(20,20,20,.9);color:#fff;padding:10px 14px;border-radius:10px;
  opacity:0;pointer-events:none;transition:opacity .2s ease;text-align:center
}
.snackbar.show{opacity:1;pointer-events:auto}

.hidden{display:none!important}

@media(max-width:800px){
  .form-row{grid-template-columns:1fr;gap:12px}
  .form-group{margin-bottom:0}
  .btn-row{flex-direction:column}
  #recommendations{grid-template-columns:1fr}
}

#multiplier-breakdown{
  background:#f9f9fb;border:1px solid #ddd;border-radius:10px;padding:14px;
  box-shadow:0 2px 5px rgba(0,0,0,.05);color:#222;font-family:Inter,system-ui,sans-serif
}
#multiplier-breakdown>p:first-of-type{font-size:.95rem;font-weight:600;color:#333;margin-bottom:6px}
#multiplier-breakdown>p:nth-of-type(2){
  font-size:.95rem;line-height:1.5;margin-bottom:12px;background:#fff;padding:8px 10px;
  border-radius:8px;border:1px solid #e3e3e3;font-variant-numeric:tabular-nums;color:#222
}
.factor-breakdown{margin:0;padding:0;list-style:none;font-size:.93rem;color:#222}
.factor-breakdown>li{margin:8px 0;line-height:1.4;padding-left:0}
.factor-breakdown li ul{
  margin:6px 0 0 14px;padding-left:10px;list-style:none;font-size:.9rem;color:#555;
  border-left:2px solid #e9edf3;border-radius:4px
}
.factor-breakdown li ul li{margin:4px 0;font-weight:500}
.factor-breakdown li ul li.note{font-size:.85rem;color:#777;font-style:italic}
.factor-breakdown>li span.neutral-flag{color:#666;font-weight:500;margin-left:6px;font-size:.9rem;font-family:ui-monospace,monospace}
#multiplier-breakdown blockquote.noted{
  margin-top:12px;padding:8px 10px;border-left:3px solid #e9edf3;background:#f1f3f6;
  color:#444;font-size:.88rem;border-radius:6px
}

.breakdown-swap-wrapper{display:flex;align-items:center;gap:8px;margin:12px 0}
.breakdown-swap-wrapper label{font-size:14px;color:#444;font-weight:500;white-space:nowrap}
.breakdown-swap{
  appearance:none;-webkit-appearance:none;-moz-appearance:none;
  background:#fff url("data:image/svg+xml;utf8,<svg fill='%23777' height='20' viewBox='0 0 24 24' width='20' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/></svg>") no-repeat right 10px center/16px;
  border:1px solid #ccc;border-radius:6px;padding:6px 32px 6px 12px;font-size:14px;font-family:inherit;
  cursor:pointer;outline:none;transition:all .2s ease;width:180px;max-width:100%;
  text-overflow:ellipsis;white-space:nowrap;overflow:hidden
}
.breakdown-swap:hover{border-color:#666}
.breakdown-swap:focus{border-color:#2196f3;box-shadow:0 0 0 2px rgba(33,150,243,.2)}
.breakdown-swap option{max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}
.breakdown-swap option:disabled{color:#aaa;background:#f5f5f5}

#resetRekomenBtn.sticky,#resetAllBtn.sticky,#breakdown-swap.sticky,
#backToHasilBtn.sticky,#toggleStickyBtn.sticky{
  position:fixed;width:48px;height:48px;display:flex;align-items:center;justify-content:center;
  border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,.2);cursor:pointer;z-index:1000;border:none;
  background-repeat:no-repeat;background-position:center;background-size:26px;

  position: fixed;
}


#resetRekomenBtn.sticky{background:#7c8d98 url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 24 24'%3E%3Cpath d='M17.65 6.35A7.95 7.95 0 0 0 12 4a8 8 0 1 0 7.9 9h-2.02a6 6 0 1 1-5.88-7c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z'/%3E%3C/svg%3E") center/26px no-repeat}
#resetAllBtn.sticky{background:#e35b54 url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 -960 960 960'%3E%3Cpath fill='%23fff' d='M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm400-600H280v520h400v-520ZM360-280h80v-360h-80v360Zm160 0h80v-360h-80v360ZM280-720v520-520Z'/%3E%3C/svg%3E") center/26px no-repeat}
#breakdown-swap.sticky{
  background:#d65a31 url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='white' viewBox='0 -960 960 960'%3E%3Cpath d='M769-88 645-212l-88 88-43-43q-17-17-17-42t17-42l199-199q17-17 42-17t42 17l43 43-88 88 123 124q9 9 9 21t-9 21l-64 65q-9 9-21 9t-21-9Zm111-636L427-271l19 20q17 17 17 42t-17 42l-43 43-88-88L191-88q-9 9-21 9t-21-9l-65-65q-9-9-9-21t9-21l124-124-88-88 43-43q17-17 42-17t42 17l20 19 453-453h160v160ZM320-568l38-38 38-38-38 38-38 38Zm-42 42L80-724v-160h160l198 198-42 42-181-180h-75v75l180 181-42 42Zm105 212 437-435v-75h-75L308-389l75 75Zm0 0-37-38-38-37 38 37 37 38Z'/%3E%3C/svg%3E") center/26px no-repeat;
  color:transparent;text-shadow:none;appearance:none;-webkit-appearance:none;-moz-appearance:none
}
#backToHasilBtn.sticky{background:#4caf50 url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 24 24'%3E%3Cpath d='M4 12l1.41 1.41L11 7.83V20h2V7.83l5.59 5.58L20 12l-8-8-8 8z'/%3E%3C/svg%3E") center/26px no-repeat}
#toggleStickyBtn.sticky{background:#ff9800 url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%23fff' d='M3 6h18v2H3V6zm0 5h18v2H3v-2zm0 5h18v2H3v-2z'/%3E%3C/svg%3E") center/26px no-repeat}
#toggleStickyBtn.sticky.active{background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%23fff' d='M18.3 5.71L12 12l-6.3-6.29-1.41 1.41L10.59 13.4l-6.3 6.3 1.41 1.41L12 14.83l6.29 6.29 1.42-1.41-6.3-6.3 6.3-6.29z'/%3E%3C/svg%3E")}

#howto{
  background:#5a6fd6;margin:0 auto 16px;width:100%;border:1px solid var(--border);
  border-radius:var(--radius);box-shadow:var(--shadow);font-size:.95rem;overflow:hidden
}
#howto summary{
  display:flex;align-items:center;justify-content:space-between;
  padding:12px 12px 12px 16px;cursor:pointer;font-weight:600;font-size:1rem;
  color:#fff;background:var(--primary);border-bottom:1px solid var(--border);line-height:1.4
}
#howto summary::-webkit-details-marker{display:none}
#howto summary::after{
  content:"";flex-shrink:0;width:16px;height:16px;margin-left:8px;
  background:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%23fff'><path d='M4 6l4 4 4-4z'/></svg>") center/16px no-repeat;
  transition:transform .25s ease;align-self:center
}
#howto[open] summary::after{transform:rotate(180deg)}
#howto .body{padding:5px 16px;background:#fff;}

#howto ol{counter-reset:step;margin:0;padding:0}
#howto ol>li{
  list-style:none;position:relative;margin:12px 0;padding-left:24px;
  color:var(--label)
}
#howto ol>li::before{
  counter-increment:step;content:counter(step) ".";
  position:absolute;left:0;top:0;color:var(--primary);font-weight:700
}

#howto ul{margin:6px 0 0;padding:0}
#howto ul li{
  list-style:none;margin:4px 0;padding-left:14px;color:var(--text);
  position:relative
}
#howto ul li::before{content:"–";position:absolute;left:0;color:var(--secondary)}
#howto li.muted{color:#777;font-style:italic;}
.footer {
  margin-top: 20px;
  font-size: 11px;
}
.footer svg {
  display: inline-block;
  margin: 0 2px -2px 0;
}

.input-wrap select { background-clip: padding-box; }
/* global smooth transitions — minimal & non-invasive */
button, a, input, .snackbar, .sticky-btn, .card, summary::after {
  transition-timing-function: ease-in-out !important;
  transition-duration: 0.28s !important;
}

#version {
margin-bottom: 20px;
font-size: 11px;
}
#version button {
font-family: monospace;
font-weight: bolder;
font-size: 11px;
text-decoration: underline dotted;
outline: none;
border: 0;
background: none;
color: var(--primary);
}
.changelog {
position: relative;
max-width: 70%;
margin: auto;
font-family: "Roboto", Arial, sans-serif;
color: #333;
font-size: 14px;
}

.changelog h2 {
font-size: 24px;
font-weight: 600;
margin-bottom: 0.6rem;
color: var(--primary);
border-bottom: 2px solid #e0e0e0;
padding-bottom: 0.3rem;
}

.changelog .version {
margin-bottom: 0.6rem;
}

.changelog .version h3 {
font-size: 20px;
font-weight: 500;
color: #202124;
margin: 0 0 0.3rem 0;
}

.changelog .version ul {
list-style: none;
padding-left: 0.2rem;
margin: 0;
}

.changelog .version ul li {
position: relative;
margin: 0.15rem 0;
padding-left: 0.9rem;
line-height: 1.25;
font-size: 0.85rem;
}

.changelog .version ul li::before {
content: "•";
color: var(--primary);
font-weight: bold;
position: absolute;
left: 0;
font-size: 0.85rem;
}

.changelog .version ul ul {
margin-top: 0.15rem;
padding-left: 0.6rem;
border-left: 1px solid #e0e0e0;
}

/* overlay */
#log {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0,0,0,0.4);
z-index: 1000;
display: flex;
align-items: center;
justify-content: center;
padding: 1rem;
box-sizing: border-box;
}

/* popup */
#log .changelog {
background: #fff;
width: 100%;
max-width: 70%;
max-height: 500px;
padding: 1rem 1.2rem;
border-radius: 10px;
box-shadow: 0 4px 20px rgba(0,0,0,0.15);
animation: fadeInUp 0.3s ease;
position: relative;
overflow-y: auto;
}

/* close button */
#log .close {
position: absolute;
top: 10px;
right: 14px;
font-size: 1.4rem;
font-weight: bold;
color: #666;
cursor: pointer;
}

.changelog .sub-cats {
  font-size: 18px;
  display: block;
}

/* responsive mobile */
@media (max-width: 480px) {
#log .changelog {
max-width: 80%;
max-height: 500px;
}
}

@keyframes fadeInUp {
from { opacity: 0; transform: translateY(20px); }
to { opacity: 1; transform: translateY(0); }
}
</style>
<script>
  (function() {

    try {
      if (!('scrollBehavior' in document.documentElement.style)) {
        var _winScrollTo = window.scrollTo;
        if (_winScrollTo) {
          window.scrollTo = function(a, b) {
            if (a && typeof a === 'object') {
              _winScrollTo.call(window, a.left || 0, a.top || 0);
            } else {
              _winScrollTo.call(window, a, b);
            }
          };
        }
        if (typeof Element !== 'undefined' && Element.prototype && Element.prototype.scrollIntoView) {
          var _elScrollIntoView = Element.prototype.scrollIntoView;
          Element.prototype.scrollIntoView = function(arg) {
            try { _elScrollIntoView.call(this); } catch (e) {}
          };
        }
      }
    } catch (e) {}

    try {
      var supportsPreventScroll = true;
      try {
        var _testEl = document.createElement('div');
        _testEl.focus({ preventScroll: true });
      } catch (err) {
        supportsPreventScroll = false;
      }
      if (!supportsPreventScroll && typeof Element !== 'undefined' && Element.prototype && Element.prototype.focus) {
        var nativeFocus = Element.prototype.focus;
        Element.prototype.focus = function(options) {
          if (options && options.preventScroll) {
            var x = window.scrollX || window.pageXOffset || 0;
            var y = window.scrollY || window.pageYOffset || 0;
            nativeFocus.call(this);
            try { window.scrollTo(x, y); } catch (e) {}
          } else {
            nativeFocus.call(this);
          }
        };
      }
    } catch (e) {}

    try {
      if (window.NodeList && !NodeList.prototype.forEach) {
        NodeList.prototype.forEach = Array.prototype.forEach;
      }
    } catch (e) {}

    try {
      if (!document.documentElement.dataset) {
        Object.defineProperty(Element.prototype, 'dataset', {
          get: function() {
            var attrs = this.attributes;
            var map = {};
            for (var i = 0; i < attrs.length; i++) {
              var name = attrs[i].name;
              if (name.indexOf('data-') === 0) {
                var prop = name.substr(5).replace(/-([a-z])/g, function(m, p) { return p.toUpperCase(); });
                map[prop] = attrs[i].value;
              }
            }
            return map;
          }
        });
      }
    } catch (e) {}

    try {
      if (typeof window.safeGet !== 'function') {
        window.safeGet = function(obj, path) {
          if (!path) return undefined;
          try {
            return path.split('.').reduce(function(acc, key) {
              return (acc && acc[key] !== undefined) ? acc[key] : undefined;
            }, obj);
          } catch (e) {
            return undefined;
          }
        };
      }
    } catch (e) {}

    try {
      (function() {
        var lastTouchTime = 0;
        document.addEventListener('touchstart', function() {
          lastTouchTime = Date.now();
        }, true);
        document.addEventListener("click", function(e) {
          if (Date.now() - lastTouchTime < 300) {
            const id = e.target && e.target.id;
            const cls = e.target && e.target.className && e.target.className.toString();
            const tag = e.target && e.target.tagName && e.target.tagName.toLowerCase();

            const isSummaryOrInside = (function(n){
  while(n){ if(n.tagName && n.tagName.toLowerCase()==='summary') return true; n = n.parentNode; }
  return false;
})(e.target);
const allowedTags = ["input", "select", "option", "button", "a", "summary"];

const isAllowed =
  id === "closeLog" ||
  (cls && cls.indexOf("sticky") !== -1) ||
  allowedTags.includes(tag) ||
  isSummaryOrInside;

            if (!isAllowed) {
              e.stopImmediatePropagation();
              e.preventDefault();
            }
          }
        }, true);
      })();
    } catch (e) {}

    try {
      (function() {
        var reposition = function() {
          try {
            var sb = document.querySelector('.snackbar.show');
            if (sb) {
              if (!sb.hasAttribute('data-compat-bottom')) {
                var cur = sb.style.bottom;
                if (cur) sb.setAttribute('data-compat-bottom', cur);
              }
              if (sb.getAttribute('data-compat-bottom')) {
                sb.style.bottom = sb.getAttribute('data-compat-bottom');
              } else {
                sb.style.bottom = '20px';
              }
            }
          } catch (e) {}
        };
        window.addEventListener('resize', reposition, false);
      })();
    } catch (e) {}
  })();
(function(){
  try {
    if (!Object.values) {
      Object.values = function(o){ return Object.keys(o).map(function(k){ return o[k]; }); };
    }
  } catch(e){}
  try {
    if (!Number.isFinite) {
      Number.isFinite = function(v){ return typeof v === 'number' && isFinite(v); };
    }
  } catch(e){}
})();</script>
<!-- end compat-shim -->

</head>
 <body>
<div class="container">
<div id="version">
  <p>[<button id="openLog" type="button">Changelog</button>] <i>v1.0.8 - Aug 31, 25</i></p>
</div>
<details id="howto">
  <summary>
    <span>How to Use</span>
  </summary>
  <div class="body">
<ol>
  <li>Set All Required Dropdowns
    <ul>
      <li>Attack Type → choose <b>PEN</b> or <b>CRIT</b></li>
      <li>Weapon Type → select your weapon</li>
      <li>Weapon Attribute → select element</li>
      <li>Target DEF → choose <b>0 / 130 / 140 / 150</b></li>
      <li>Target Size → select <b>Small / Medium / Large</b></li>
      <li>(Optional) Target Race / Target Attribute</li>
    </ul>
    <ul>
      <li><i>Note: If Race or Attribute is chosen, the related % input becomes mandatory.</i></li>
    </ul>
  </li>

  <li>Enter Your Stats
    <ul>
      <li>If PEN → Final P/M PEN %</li>
      <li>If CRIT → Critical DMG Bonus %</li>
      <li>Final P/M DMG Bonus %</li>
      <li>Element Enhance %</li>
      <li>Size Enhance %</li>
      <li>Race % / Attribute % (required if you selected Race/Attribute)</li>
    </ul>
  </li>

  <li>Calculate
    <ul>
      <li>Click <b>Calculate</b></li>
      <li>All inputs will lock after calculation</li>
      <li>Validation prevents:
        <ul>
          <li>PEN ≤ target DEF</li>
          <li>Final P/M DMG Bonus ≤ target damage reduction</li>
        </ul>
      </li>
    </ul>
  </li>

  <li>Multiplier Breakdown
    <ul>
      <li>Shows all factor contributions</li>
      <li>Can <b>Swap Target DEF</b> to see the difference</li>
      <li>Only base multipliers are shown (skills, buffs, etc. not included)</li>
    </ul>
  </li>

  <li>Recommendations
    <ul>
      <li>Generates stat combos that give higher multipliers</li>
      <li><b>Refresh Recommendations</b> → re-roll random suggestions</li>
      <li><b>Reset All</b> → clear all inputs and unlock fields</li>
    </ul>
  </li>
</ol>
  </div>
</details>
  <div class="form-row">
    <div class="form-group">
      <label for="penCritSelect" id="atkTypeLabel">Attack Type</label>
      <div class="input-wrap">
        <select id="penCritSelect"></select>
      </div>
    </div>

    <div class="form-group">
      <label for="targetDefSelect" id="tDefLabel">Target Defense</label>
      <div class="input-wrap">
        <select id="targetDefSelect"></select>
      </div>
    </div>

    <div class="form-group">
      <label for="weaponSelect" id="weaponLabel">Weapon Type</label>
      <div class="input-wrap">
        <select id="weaponSelect"></select>
      </div>
    </div>

    <div class="form-group">
      <label for="weaponElementSelect" id="wElemLabel">Weapon Attribute</label>
      <div class="input-wrap">
        <select id="weaponElementSelect"></select>
      </div>
    </div>

    <div class="form-group">
      <label for="targetSizeSelect" id="tSizeLabel">Target Size</label>
      <div class="input-wrap">
        <select id="targetSizeSelect"></select>
      </div>
    </div>

    <div class="form-group">
      <label for="targetRaceSelect" id="tRaceLabel">Target Race</label>
      <div class="input-wrap">
        <select id="targetRaceSelect"></select>
      </div>
    </div>

    <div class="form-group">
      <label for="targetElementSelect" id="tAttrLabel">Target Attribute</label>
      <div class="input-wrap">
        <select id="targetElementSelect"></select>
      </div>
    </div>
  </div>

  <div class="form-row">
    <div class="form-group pen-group">
      <label for="pen" id="penLabel">Final P M PEN %</label>
      <div class="input-wrap">
        <input id="pen" type="number" min="1" disabled placeholder="total converted raw pen + fpen..." />
      </div>
    </div>

    <div class="form-group crit-group">
      <label for="crit" id="critLabel">Critical DMG Bonus %</label>
      <div class="input-wrap">
        <input id="crit" type="number" min="1" disabled placeholder="crit dmg bns..." />
      </div>
    </div>

    <div class="form-group">
      <label for="dmg" id="dmgLabel">Final P M DMG Bonus %</label>
      <div class="input-wrap">
        <input id="dmg" type="number" min="1" placeholder="input f. p/m dmg bns..." />
      </div>
    </div>

    <div class="form-group">
      <label for="elemEnhance" id="elemEnhLabel">Element Enhance %</label>
      <div class="input-wrap">
        <input id="elemEnhance" type="number" min="1" />
      </div>
    </div>

    <div class="form-group">
      <label for="sizeEnhance" id="sizeLabel">DMG to Size %</label>
      <div class="input-wrap">
        <input id="sizeEnhance" type="number" min="1" />
      </div>
    </div>

    <div class="form-group">
      <label for="race" id="raceLabel">DMG to Race %</label>
      <div class="input-wrap">
        <input id="race" type="number" min="1" disabled />
      </div>
    </div>

    <div class="form-group">
      <label for="attr" id="attrLabel">DMG to Attribute %</label>
      <div class="input-wrap">
        <input id="attr" type="number" min="1" disabled />
      </div>
    </div>
  </div>

  <div class="btn-row">
    <button id="submitBtn" type="button">Calculate</button>
    <button class="reset-recommendations reset-rek-btn" id="resetRekomenBtn" type="button" disabled>Refresh Recommendations</button>
    <button id="resetAllBtn" type="button" disabled>Reset All</button>
  </div>

  <div id="hasil">Input stats to see the result...</div>

  <div id="recommendations">
    Randomize stat for a higher output multiplier.
  </div>
  <div class="footer"><i>Have an issue?</i><br/>
  Silja [Odin-Nastia] <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="evenodd" clip-rule="evenodd" viewBox="0 0 512 512"><path fill="#5865F2" d="M105 0h302c57.928.155 104.845 47.072 105 104.996V407c-.155 57.926-47.072 104.844-104.996 104.998L105 512C47.074 511.844.156 464.926.002 407.003L0 105C.156 47.072 47.074.155 104.997 0H105z"/><g data-name=""><g data-name="Discord Logos"><path fill="#fff" fill-rule="nonzero" d="M368.896 153.381a269.506 269.506 0 00-67.118-20.637 186.88 186.88 0 00-8.57 17.475 250.337 250.337 0 00-37.247-2.8c-12.447 0-24.955.946-37.25 2.776-2.511-5.927-5.427-11.804-8.592-17.454a271.73 271.73 0 00-67.133 20.681c-42.479 62.841-53.991 124.112-48.235 184.513a270.622 270.622 0 0082.308 41.312c6.637-8.959 12.582-18.497 17.63-28.423a173.808 173.808 0 01-27.772-13.253c2.328-1.688 4.605-3.427 6.805-5.117 25.726 12.083 53.836 18.385 82.277 18.385 28.442 0 56.551-6.302 82.279-18.387 2.226 1.817 4.503 3.557 6.805 5.117a175.002 175.002 0 01-27.823 13.289 197.847 197.847 0 0017.631 28.4 269.513 269.513 0 0082.363-41.305l-.007.007c6.754-70.045-11.538-130.753-48.351-184.579zM201.968 300.789c-16.04 0-29.292-14.557-29.292-32.465s12.791-32.592 29.241-32.592 29.599 14.684 29.318 32.592c-.282 17.908-12.919 32.465-29.267 32.465zm108.062 0c-16.066 0-29.267-14.557-29.267-32.465s12.791-32.592 29.267-32.592c16.475 0 29.522 14.684 29.241 32.592-.281 17.908-12.894 32.465-29.241 32.465z" data-name="Discord Logo - Large - White"/></g></g></svg>sanditama#7047</div>
</div>

<div class="log" id="log">
  <div class="changelog">
    <div class="header-log"><span class="close" id="closeLog">&times;</span>
    <h2>Changelog</h2>
    </div>
<div class="version">
  <h3>[Unreleased]</h3>
  <ul>
    <li>MINIGAME!</li>
  </ul>
</div>

<div class="version">
  <h3>[v1.0.1] - Aug 31, 2025</h3>
  <ul>
    <li><span class="sub-cats">Added</span>
      <ul>
        <li>Changelog</li>
        <li>"How to Use" section at the top of the page</li>
        <li>Target DEF dropdown (used in calculations)
          <ul>
            <li>Dummy (0 DEF)</li>
            <li>Average MVP/MINI Lv. 130</li>
            <li>Average MVP/MINI Lv. 140</li>
            <li>Average MVP/MINI Lv. 150</li>
          </ul>
        </li>
        <li>Swap target DEF</li>
        <li>Double tap/click guard</li>
        <li>Sticky collapsible button on scroll (mobile only)</li>
      </ul>
    </li>
    
    <li><span class="sub-cats">Updated</span>
      <ul>
        <li>Calculation formula
          <ul>
            <li>Added counter DEF to formula</li>
          </ul>
        </li>
      </ul>
    </li>
    
    <li><span class="sub-cats">Improved</span>
      <ul>
        <li>Cross-browser compatibility</li>
        <li>Main flow and logic</li>
        <li>Input data validation</li>
        <li>Results with more detailed breakdown by factor</li>
        <li>Recommendation table logic</li>
      </ul>
    </li>
  </ul>
</div>
    
    <div class="version">
      <h3>[v1.0.0] - Aug 28, 2025</h3>
      <ul>
        <li>Initial release with basic features
          <ul>
            <li>6 dropdowns and 6 numeric fields for data input</li>
            <li>3 buttons</li>
            <li>Result card</li>
            <li>Randomize stats in the recommendations table</li>
          </ul>
        </li>
      </ul>
    </div>
  </div>
</div>
  <div aria-live="polite" class="snackbar" id="snackbar" role="status">
  </div>
<script>
const elementCounter = {
  Neutral:{Neutral:1,Fire:1,Water:1,Earth:1,Wind:1,Poison:1,Holy:1,
           Shadow:1,Ghost:0.70,Undead:1},
  Fire:{Neutral:1,Fire:0.25,Water:1,Earth:1.25,Wind:1,Poison:1,Holy:0.75,
        Shadow:1,Ghost:1,Undead:1.125},
  Water:{Neutral:1,Fire:1.25,Water:0.25,Earth:1,Wind:0.90,Poison:1,Holy:0.75,
         Shadow:1,Ghost:1,Undead:1},
  Earth:{Neutral:1,Fire:0.90,Water:1,Earth:0.25,Wind:1.25,Poison:1,Holy:0.75,
         Shadow:1,Ghost:1,Undead:1},
  Wind:{Neutral:1,Fire:1,Water:1.375,Earth:0.90,Wind:0.25,Poison:1,Holy:0.70,
        Shadow:1,Ghost:1,Undead:1},
  Poison:{Neutral:1,Fire:1.125,Water:1,Earth:1.125,Wind:1.125,Poison:0,Holy:0.75,
          Shadow:0.50,Ghost:1,Undead:-0.25},
  Holy:{Neutral:1,Fire:1,Water:1,Earth:1,Wind:1,Poison:1,Holy:0,
        Shadow:1.375,Ghost:1,Undead:1.375},
  Shadow:{Neutral:1.125,Fire:1,Water:1,Earth:1,Wind:1,Poison:0.50,Holy:1.375,
          Shadow:0,Ghost:1,Undead:-0.25},
  Ghost:{Neutral:0.90,Fire:1,Water:1,Earth:1,Wind:1,Poison:1,Holy:0.75,
         Shadow:0.75,Ghost:1.375,Undead:1},
  Undead:{Neutral:1,Fire:1,Water:1,Earth:1,Wind:1,Poison:0.50,Holy:1.375,
          Shadow:0,Ghost:1.25,Undead:0}
};
const weaponSizeModifier = {
  "Empty Handed":{Large:0.5,Medium:0.5,Small:0.5},
  "One-Handed Sword":{Large:0.75,Medium:1,Small:0.75},
  "Two-Handed Sword":{Large:1,Medium:0.75,Small:0.75},
  "Two-Handed Spear":{Large:1,Medium:0.75,Small:0.75},
  "Dagger":{Large:0.75,Medium:0.75,Small:1},
  "Katar":{Large:0.75,Medium:1,Small:0.75},
  "Light Knuckle":{Large:0.75,Medium:0.75,Small:1},
  "Heavy Knuckle":{Large:1,Medium:0.75,Small:0.75},
  "GS":{Large:1,Medium:1,Small:1},
  "Ninja Sword":{Large:1,Medium:0.75,Small:0.75},
  "Huuma Shuriken":{Large:1,Medium:1,Small:1},
  "Tome":{Large:0.75,Medium:1,Small:1},
  "Book":{Large:1,Medium:1,Small:1},
  "Two-Handed Rod":{Large:1,Medium:1,Small:1},
  "One-Handed Rod":{Large:1,Medium:1,Small:1},
  "Mace":{Large:1,Medium:0.75,Small:0.75},
  "One-Handed Axe":{Large:0.75,Medium:0.75,Small:0.75},
  "Two-Handed Axe":{Large:0.5,Medium:0.75,Small:0.75},
  "Bow":{Large:0.75,Medium:1,Small:1},
  "Instrument":{Large:0.75,Medium:1,Small:0.75},
  "Whip":{Large:0.75,Medium:1,Small:0.75}
};
const defTable = {
  "0def": { def: 0, dmgred: 0 },
  "130boss": { def: 220 , dmgred:170 },
  "140boss": { def: 250, dmgred: 210 },
  "150boss": { def: 360, dmgred: 300 }
};
const raceTypes = [
  "Angel","Demon","Formless","Insect","Fish",
  "Demi-Human","Undead","Dragon","Plant","Brute"
];
const els = {
  atkType: document.getElementById('penCritSelect'),
  weapon: document.getElementById('weaponSelect'),
  wElem: document.getElementById('weaponElementSelect'),
  tSize: document.getElementById('targetSizeSelect'),
  tRace: document.getElementById('targetRaceSelect'),
  tAttr: document.getElementById('targetElementSelect'),
  tDef: document.getElementById('targetDefSelect'),
  tDefLabel: document.getElementById('tDefLabel'),
  atkTypeLabel: document.getElementById('atkTypeLabel'),
  weaponLabel: document.getElementById('weaponLabel'),
  wElemLabel: document.getElementById('wElemLabel'),
  tSizeLabel: document.getElementById('tSizeLabel'),
  tRaceLabel: document.getElementById('tRaceLabel'),
  tAttrLabel: document.getElementById('tAttrLabel'),
  pen: document.getElementById('pen'),
  crit: document.getElementById('crit'),
  dmg: document.getElementById('dmg'),
  elemEnh: document.getElementById('elemEnhance'),
  sizeEnh: document.getElementById('sizeEnhance'),
  race: document.getElementById('race'),
  attr: document.getElementById('attr'),
  penLabel: document.getElementById('penLabel'),
  critLabel: document.getElementById('critLabel'),
  dmgLabel: document.getElementById('dmgLabel'),
  elemEnhLabel: document.getElementById('elemEnhLabel'),
  sizeLabel: document.getElementById('sizeLabel'),
  raceLabel: document.getElementById('raceLabel'),
  attrLabel: document.getElementById('attrLabel'),
  hasil: document.getElementById('hasil'),
  rec: document.getElementById('recommendations'),
  submit: document.getElementById('submitBtn'),
  resetRek: document.getElementById('resetRekomenBtn'),
  resetAll: document.getElementById('resetAllBtn'),
  snackbar: document.getElementById('snackbar'),
  log: document.getElementById("log"),
  openLog: document.getElementById("openLog"),
  closeLog: document.getElementById("closeLog")
};
function isEmpty(v) {
  return v === null || v === undefined || v === '';
}
function clearNumeric(el) {
  if (el) el.value = '';
}
function scrollAndFocus(el, msg) {
  showSnack(msg);
  const top = el.getBoundingClientRect().top + window.scrollY - 80;
  window.scrollTo({ top, behavior: 'smooth' });
  if (!el.disabled) el.focus({ preventScroll: true });
  return false;
}
let snackTimer = null;
function showSnack(text) {
  let sb = document.getElementById('snackbar');
  sb.textContent = text;
  if (snackTimer) clearTimeout(snackTimer);
  sb.classList.add('show');
  snackTimer = setTimeout(() => sb.classList.remove('show'), 3000);
}
function normalizeInput(el, pastedValue) {
  if (!el) return;
  let v = (pastedValue ?? el.value).replace(',', '.').trim();
  if (/^\d+\.$/.test(v)) {
    v = v.slice(0, -1);
  }
  if (!/^\d+(\.\d+)?$/.test(v)) {
    showSnack("Numbers only!");
    el.value = '';
    return;
  }
  if (/^0\d+/.test(v)) {
    showSnack("No leading zeros!");
    el.value = String(Number(v));
    return;
  }
  if (v === '' || Number(v) < 1) {
    showSnack("Min value is 1!");
    el.value = '';
    return;
  }
  el.value = v;
}


function getWeaponSizeMod(weapon, size) {
  const map = weaponSizeModifier[weapon];
  if (!map) return 1.0;
  const val = map[size];
  return Number.isFinite(val) ? Number(val) : 1.0;
}

function getElemCounter(welem, tElem) {
  const map = elementCounter[welem] || elementCounter['Neutral'];
  const base = tElem ? ((map[tElem] !== undefined && map[tElem] !== null) ? map[tElem] : map['Neutral']) : ((map['Neutral'] !== undefined && map['Neutral'] !== null) ? map['Neutral'] : 1.0);
  return Number.isFinite(base) ? Number(base) : 1.0;
}
function getTargetDefData(key) {
  return defTable[key] || defTable["0def"];
}
function calcAttackFactor(type, pen, crit, def = 0) {
  if (type === 'pen') {
    const rawPen = (Number(pen) || 0) - (Number(def) || 0);
    if (rawPen <= 0) return 0;
    const effPen = rawPen >= 150 ? ((rawPen * 2) - 150) : rawPen;
    return effPen / 100;
  }
  if (type === 'crit') {
    return (Number(crit) || 0) / 100;
  }
  return 0;
}
function calcMultiplier({
  atkType, penVal, critVal, dmgVal, sizeEnhVal, elemEnhVal, raceVal, attrVal,
  weapon, tSize, wElem, tAttr, tRace, tDefKey
}) {
  const { def, dmgred } = getTargetDefData(tDefKey);
  const atkF = calcAttackFactor(atkType, penVal, critVal, def);
  const effDmgVal = (Number(dmgVal) || 0) - (Number(dmgred) || 0);
  const sizeMod = getWeaponSizeMod(weapon, tSize);
  const elemCtr = getElemCounter(wElem, tAttr);
  const mult = (1 + atkF) *
    (1 + (effDmgVal / 100)) *
    (sizeMod + (Number(sizeEnhVal) || 0) / 100) *
    (elemCtr + (Number(elemEnhVal) || 0) / 100) *
    (1 + (tAttr ? (Number(attrVal) || 0) / 100 : 0)) *
    (1 + (tRace ? (Number(raceVal) || 0) / 100 : 0));
  return { mult, def, dmgred, effDmgVal, atkF };
}
function computeMultiplier() {
  const atkType = els.atkType.value;
  const penVal = Number(els.pen.value) || 0;
  const critVal = Number(els.crit.value) || 0;
  const dmgVal = Number(els.dmg.value) || 0;
  const sizeEnhVal = Number(els.sizeEnh.value) || 0;
  const elemEnhVal = Number(els.elemEnh.value) || 0;
  const raceVal = Number(els.race.value) || 0;
  const attrVal = Number(els.attr.value) || 0;
  const result = calcMultiplier({
    atkType,
    penVal,
    critVal,
    dmgVal,
    sizeEnhVal,
    elemEnhVal,
    raceVal,
    attrVal,
    weapon: els.weapon.value,
    tSize: els.tSize.value,
    wElem: els.wElem.value,
    tAttr: els.tAttr.value,
    tRace: els.tRace.value,
    tDefKey: els.tDef.value
  });
  return {
    atkType, penVal, critVal, dmgVal,
    sizeEnhVal, elemEnhVal, raceVal, attrVal,
    mult: result.mult,
    def: result.def,
    dmgred: result.dmgred,
    effDmgVal: result.effDmgVal,
    atkF: result.atkF
  };
}
const TABLE_CONFIG = {
  jitter: 0.4,
  randomMode: 'clamp',
  centerScale: 0.4,
  raceAttrCap: 480,
  bias: { main: 1, dmg: 1.2, elem: 0.9, size: 0.9, race: 0.8, attr: 0.8 },
  cats: [
    { label: '<8%',    min: 1.00, max: 1.08 },
    { label: '10-20%', min: 1.10, max: 1.20 },
    { label: '20-30%', min: 1.20, max: 1.30 },
    { label: '50-100%',min: 1.50, max: 2.00 }
  ]
};
function calculateWeights({ includeRace, includeAttr, baseMain, baseDmg, baseElem, baseSize, baseRace, baseAttr }) {
  const B = TABLE_CONFIG.bias;
  const s1 = v => Math.max(Number(v) || 0, 0);

  const raws = [
    s1(baseMain) * B.main,
    s1(baseDmg) * B.dmg,
    s1(baseElem) * B.elem,
    s1(baseSize) * B.size
  ];

  const maxRaw = Math.max(...raws, 1);
  const norms = raws.map(v => v / maxRaw);
  const coreSum = norms.reduce((a, b) => a + b, 0) || 1;
  const coreShare = (includeRace || includeAttr) ? 0.8 : 1.0;
  const addShare = 1 - coreShare;

  let w = {
    main: norms[0] / coreSum * coreShare,
    dmg: norms[1] / coreSum * coreShare,
    elem: norms[2] / coreSum * coreShare,
    size: norms[3] / coreSum * coreShare,
    race: 0,
    attr: 0
  };

  const raceAvail = includeRace && baseRace < TABLE_CONFIG.raceAttrCap;
  const attrAvail = includeAttr && baseAttr < TABLE_CONFIG.raceAttrCap;

  if (raceAvail && attrAvail) {
    const rSum = s1(baseRace) + s1(baseAttr);
    if (rSum > 0) {
      w.race = (s1(baseRace) / rSum) * addShare;
      w.attr = (s1(baseAttr) / rSum) * addShare;
    } else {
      w.race = addShare / 2;
      w.attr = addShare / 2;
    }
  } else if (raceAvail) {
    w.race = addShare;
  } else if (attrAvail) {
    w.attr = addShare;
  } else if (includeRace || includeAttr) {
    const keys = ["main", "dmg", "elem", "size"];
    norms.forEach((v, i) => {
      w[keys[i]] += (v / coreSum) * addShare;
    });
  }

  const total = Object.values(w).reduce((a, b) => a + b, 0) || 1;
  Object.keys(w).forEach(k => { w[k] /= total; });

  return w;
}
function generateRecommendations(state) {
  const base = state.mult;
  const recRoot = els.rec;
  recRoot.innerHTML = '';
  const includeRace = !!els.tRace.value;
  const includeAttr = !!els.tAttr.value;
  const isPen = state.atkType === 'pen';
  const s1 = (v)=>Math.max(Number(v)||0,0);
  const randAround = (val, j = TABLE_CONFIG.jitter) => {
    const v = Number(val) || 0;
    const mode = TABLE_CONFIG.randomMode;
    if (mode === "clamp") {
      const delta = (Math.random() * 2 - 1) * j;
      const maxClamp = Math.min(0.6 * j, 0.3);
      const clamped = Math.max(Math.min(delta, maxClamp), -maxClamp);
      return Math.max(0, v * (1 + clamped));
    }
    if (mode === "normal") {
      let u = 0, v2 = 0;
      while (u === 0) u = Math.random();
      while (v2 === 0) v2 = Math.random();
      const num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v2);
      return Math.max(0, v * (1 + num * j * 0.5));
    }
    const delta = (Math.random() * 2 - 1) * j;
    return Math.max(0, v * (1 + delta));
  };
  const renderFactorCell = (val, baseVal)=>{
    const rounded = Math.round(val), baseRounded = Math.round(baseVal);
    let cls = 'neutral'; if (rounded >= baseRounded+6) cls='up'; else if (rounded <= baseRounded-6) cls='down';
    const span = document.createElement('span'); span.className=cls; span.textContent=rounded;
    const td = document.createElement('td'); td.appendChild(span); return td;
  };
  const sizeMod = getWeaponSizeMod(els.weapon.value, els.tSize.value);
  const elemCtr = getElemCounter(els.wElem.value, els.tAttr.value);
  const basePen  = state.penVal||0;
  const baseCrit = state.critVal||0;
  const baseMain = isPen ? basePen : baseCrit;
  const baseDmg  = state.dmgVal||0;
  const baseSize = state.sizeEnhVal||0;
  const baseElem = state.elemEnhVal||0;
  const baseAttr = includeAttr ? (state.attrVal||0) : 0;
  const baseRace = includeRace ? (state.raceVal||0) : 0;
  const W = calculateWeights({ includeRace, includeAttr, baseMain, baseDmg, baseElem, baseSize, baseRace, baseAttr });
  const CS = TABLE_CONFIG.centerScale;
  const center = (base, w)=> s1(base) * (1 + w*CS);
  const cMain = center(baseMain, W.main);
  const cDmg  = center(baseDmg,  W.dmg);
  const cElem = center(baseElem, W.elem);
  const cSize = center(baseSize, W.size);
  const cAttr = includeAttr ? Math.min(center(baseAttr, W.attr), TABLE_CONFIG.raceAttrCap) : 0;
  const cRace = includeRace ? Math.min(center(baseRace, W.race), TABLE_CONFIG.raceAttrCap) : 0;
  for (const cat of TABLE_CONFIG.cats) {
    const tbl = document.createElement('table'); tbl.className='recommend-table';
    const cap = document.createElement('caption'); cap.textContent='Category '+cat.label; tbl.appendChild(cap);
    const trHead = document.createElement('tr');
    const headers = [isPen?'PEN':'CRIT','P/M BO','Element','Size'];
    if (includeRace) headers.push('Race');
    if (includeAttr) headers.push('Attribute');
    headers.push('Multiplier','\u2206');
    headers.forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trHead.appendChild(th); });
    tbl.appendChild(trHead);
    const tbody = document.createElement('tbody');
    const seen = new Set(), seenDelta = new Set();
    const seenMain = new Set(), seenDmg = new Set(), seenElem = new Set(),
          seenSize = new Set(), seenAttr = new Set(), seenRace = new Set();
    const rows = [];
    const MAX_ATTEMPTS = 1200;
    let attempts = 0, jitter = TABLE_CONFIG.jitter;
    while (rows.length < 5 && attempts < MAX_ATTEMPTS) {
      attempts++;
      let rPen = basePen, rCrit = baseCrit;
      if (isPen) { rPen = randAround(cMain, jitter); } else { rCrit = randAround(cMain, jitter); }
      const rDmg  = randAround(cDmg,  jitter);
      const rElem = randAround(cElem, jitter);
      const rSize = randAround(cSize, jitter);
      let rAttr = 0, rRace = 0;
      if (includeAttr && includeRace) {
        const cap = TABLE_CONFIG.raceAttrCap;
        const tol = 30;
        const userTotal = (baseRace + baseAttr) || 0;
        const maxTotal = (userTotal >= cap) ? (userTotal + tol) : cap;
        const total = Math.min(randAround(userTotal, jitter), maxTotal);
        const baseRatio = userTotal ? (baseRace / userTotal) : 0.5;
        const noise = (Math.random() * 0.2) - 0.1;
        const ratio = Math.min(Math.max(baseRatio + noise, 0.3), 0.7);
        let rRaceTmp = total * ratio;
        let rAttrTmp = total * (1 - ratio);
        const sum = rRaceTmp + rAttrTmp;
        if (sum > maxTotal) {
          const scale = maxTotal / sum;
          rRaceTmp *= scale;
          rAttrTmp *= scale;
        }
        rRace = rRaceTmp;
        rAttr = rAttrTmp;
      } else if (includeRace) {
        rRace = Math.min(randAround(cRace, jitter), TABLE_CONFIG.raceAttrCap);
      } else if (includeAttr) {
        rAttr = Math.min(randAround(cAttr, jitter), TABLE_CONFIG.raceAttrCap);
      }
      const { mult: newMult } = calcMultiplier({
        atkType: isPen ? 'pen' : 'crit',
        penVal: rPen,
        critVal: rCrit,
        dmgVal: rDmg,
        sizeEnhVal: rSize,
        elemEnhVal: rElem,
        raceVal: rRace,
        attrVal: rAttr,
        weapon: els.weapon.value,
        tSize: els.tSize.value,
        wElem: els.wElem.value,
        tAttr: els.tAttr.value,
        tRace: els.tRace.value,
        tDefKey: els.tDef.value
      });
      if (newMult <= base) continue;
      const ratio = newMult / Math.max(base, 1e-9);
      if (ratio < cat.min || ratio > cat.max) continue;
      const mainVal = Math.round(isPen ? rPen : rCrit);
      const dmgVal  = Math.round(rDmg);
      const elemVal = Math.round(rElem);
      const sizeVal = Math.round(rSize);
      const raceVal = includeRace ? Math.round(rRace) : null;
      const attrVal = includeAttr ? Math.round(rAttr) : null;
      const key = [mainVal,dmgVal,elemVal,sizeVal,raceVal||'-',attrVal||'-'].join('|');
      if (seen.has(key)) continue;
      if (seenMain.has(mainVal)) continue;
      if (seenDmg.has(dmgVal)) continue;
      if (seenElem.has(elemVal)) continue;
      if (seenSize.has(sizeVal)) continue;
      if (includeAttr && seenAttr.has(attrVal)) continue;
      if (includeRace && seenRace.has(raceVal)) continue;
      const deltaPct = ((newMult - base)/base)*100;
      const deltaKey = Number(deltaPct.toFixed(1));
      if (seenDelta.has(deltaKey)) continue;
      seen.add(key); seenDelta.add(deltaKey);
      seenMain.add(mainVal); seenDmg.add(dmgVal); seenElem.add(elemVal); seenSize.add(sizeVal);
      if (includeAttr) seenAttr.add(attrVal);
      if (includeRace) seenRace.add(raceVal);
      rows.push({ main: mainVal, dmg: dmgVal, elem: elemVal, size: sizeVal,
        attr: attrVal, race: raceVal, newMult, deltaPct });
      if (rows.length < 5 && attempts % 800 === 0) {
        jitter = Math.min(jitter + 0.1, 0.9);
      }
    }
    rows.sort((a,b)=> b.deltaPct-a.deltaPct || b.newMult-a.newMult || b.main-a.main);
    if (rows.length) {
      for (const row of rows) {
        const tr = document.createElement('tr');
        tr.appendChild(renderFactorCell(row.main, baseMain));
        tr.appendChild(renderFactorCell(row.dmg,  baseDmg));
        tr.appendChild(renderFactorCell(row.elem, baseElem));
        tr.appendChild(renderFactorCell(row.size, baseSize));
        if (includeRace) tr.appendChild(renderFactorCell(row.race, baseRace));
        if (includeAttr) tr.appendChild(renderFactorCell(row.attr, baseAttr));
        const tdMult = document.createElement('td'); tdMult.className='mult';  tdMult.textContent='x'+row.newMult.toFixed(2); tr.appendChild(tdMult);
        const tdDelta= document.createElement('td'); tdDelta.className='delta'; tdDelta.textContent='+'+row.deltaPct.toFixed(1)+'%'; tr.appendChild(tdDelta);
        tbody.appendChild(tr);
      }
    } else {
      const tr = document.createElement('tr'); const td = document.createElement('td');
      td.colSpan = headers.length; td.textContent = 'No combination found'; tr.appendChild(td); tbody.appendChild(tr);
    }
    tbl.appendChild(tbody);
    const wrap = document.createElement('div'); wrap.className='table-wrapper'; wrap.appendChild(tbl); recRoot.appendChild(wrap);
  }
  showSnack('Recommendations updated');
}
let resultShown = false;
function onDropdownChange(e) {
  if (resultShown) return;
  const id = (e && e.target && e.target.id); if (!id) return;
  if (id==='penCritSelect'){clearNumeric(els.pen);clearNumeric(els.crit);updateAtkUI();}
  if (id==='targetRaceSelect') clearNumeric(els.race);
  if (id==='targetElementSelect') clearNumeric(els.attr);
  updateDynamicUI();
}
function updateAtkUI() {
  const atkType=els.atkType.value;
  const penGroup=document.querySelector('.form-group.pen-group');
  const critGroup=document.querySelector('.form-group.crit-group');
  if(penGroup&&critGroup){penGroup.classList.add('hidden');critGroup.classList.add('hidden');}
  if(atkType==='pen'){if(penGroup)penGroup.classList.remove('hidden');
    els.pen.disabled=false;els.crit.disabled=true;els.crit.value='';}
  else if(atkType==='crit'){if(critGroup)critGroup.classList.remove('hidden');
    els.crit.disabled=false;els.pen.disabled=true;els.pen.value='';}
  else{els.pen.disabled=true;els.crit.disabled=true;els.pen.value='';els.crit.value='';}
}
function updateDynamicUI() {
  if (els.tRace.value) {
    els.race.disabled = false;
    els.raceLabel.textContent = 'DMG to ' + els.tRace.value + ' %';
    els.race.placeholder = 'dmg to '+els.tRace.value+'...';
  } else {
    els.race.disabled = true;
    els.raceLabel.textContent = 'DMG to Race %';
    els.race.placeholder = 'Select target race first';
    els.race.value = '';
  }
  if (els.tAttr.value) {
    els.attr.disabled = false;
    els.attrLabel.textContent = 'DMG to ' + els.tAttr.value + ' Attribute %';
    els.attr.placeholder = 'dmg to '+els.tAttr.value+' attr mob...';
  } else {
    els.attr.disabled = true;
    els.attrLabel.textContent = 'DMG to Attribute %';
    els.attr.placeholder = 'Select target attribute first';
    els.attr.value = '';
  }
  if (els.wElem.value) {
    els.elemEnh.disabled = false;
    els.elemEnhLabel.textContent = els.wElem.value + ' Enhance %';
    els.elemEnh.placeholder = els.wElem.value+' enhance...';
  } else {
    els.elemEnh.disabled = true;
    els.elemEnhLabel.textContent = 'Element Enhance %';
    els.elemEnh.placeholder = 'Select weapon attribute first';
    els.elemEnh.value = '';
  }
  if (els.tSize.value) {
    els.sizeEnh.disabled = false;
    els.sizeLabel.textContent = 'DMG to ' + els.tSize.value + ' %';
    els.sizeEnh.placeholder = 'dmg to '+els.tSize.value+'...';
  } else {
    els.sizeEnh.disabled = true;
    els.sizeLabel.textContent = 'DMG to Size %';
    els.sizeEnh.placeholder = 'Select target size first';
    els.sizeEnh.value = '';
  }
}
function validateRequired() {
  const dropdowns = [
    { el: els.atkType, label: 'Attack Type' },
    { el: els.tDef, label: 'Target Defense' },
    { el: els.weapon, label: 'Weapon Type' },
    { el: els.wElem, label: 'Weapon Attribute' },
    { el: els.tSize, label: 'Target Size' }
  ];
  for (const f of dropdowns) {
    if (!f.el) continue;
    if (isEmpty(f.el.value)) return scrollAndFocus(f.el, `Please fill ${f.label}`);
  }
  if (!els.race.disabled && isEmpty(els.tRace.value))
    return scrollAndFocus(els.tRace, 'Please fill Target Race');
  if (!els.attr.disabled && isEmpty(els.tAttr.value))
    return scrollAndFocus(els.tAttr, 'Please fill Target Attribute');
  const atk = (els.atkType.value || '').toLowerCase();
  if (atk === 'pen' && isEmpty(els.pen.value))
    return scrollAndFocus(els.pen, 'Please fill Final P M PEN %');
  if (atk === 'crit' && isEmpty(els.crit.value))
    return scrollAndFocus(els.crit, 'Please fill Critical DMG Bonus %');
  const inputs = [
    { el: els.dmg, label: 'Final P M DMG Bonus %' },
    { el: els.elemEnh, label: 'Element Enhance %' },
    { el: els.sizeEnh, label: 'DMG to Size %' },
    { el: els.race, label: 'DMG to Race %', optional: true },
    { el: els.attr, label: 'DMG to Attribute %', optional: true }
  ];
  for (const f of inputs) {
    if (!f.el) continue;
    if (f.optional && f.el.disabled) continue;
    if (isEmpty(f.el.value)) return scrollAndFocus(f.el, `Please fill ${f.label}`);
  }
  return true;
}
function validateValueVsDef(state) {
  try {
    const tDefEl = els.tDef;
    const selectedOpt = tDefEl.options[tDefEl.selectedIndex];
    const targetLabel = selectedOpt ? selectedOpt.textContent : 'target';
    const defKey = tDefEl.value;
    const defData = getTargetDefData(defKey || '0def');
    const defVal = Number(defData.def || 0);
    const dmgredVal = Number(defData.dmgred || 0);
    const atk = (state.atkType || '').toLowerCase();
    if (atk === 'pen') {
      const penEl = els.pen;
      const penV = Number(penEl.value) || 0;
      if (penV <= 0 || (penV - defVal) <= 0) {
        return scrollAndFocus(penEl, `Need ≥ ${defVal} PEN vs ${targetLabel}`);
      }
    }
    const dmgEl = els.dmg;
    const dmgV = Number(dmgEl.value) || 0;
    if (dmgV <= 0 || (dmgV - dmgredVal) <= 0) {
      return scrollAndFocus(dmgEl, `Need ≥ ${dmgredVal} P/M BO vs ${targetLabel}`);
    }
    return true;
  } catch (err) {
    showSnack('Validation error');
    return false;
  }
}
function renderMultiplierBreakdown(state, list, elemCtr, sizeMod, isPen) {
  const container = document.createElement('div');
  container.id = "multiplier-breakdown";
  container.className = "multiplier-breakdown";
  const bq0 = document.createElement('blockquote');
  bq0.className = "noted";
  bq0.textContent = "By default, every factor starts at ×1.00. Numbers show how it changes with your stats.";
  container.appendChild(bq0);
  const ul = document.createElement('ul');
  ul.className = "factor-breakdown";
  list.forEach(f => {
    const li = document.createElement('li');
    if (f.show === false) {
      li.textContent = `${f.label}: ×1.00 (not selected)`;
      ul.appendChild(li);
      return;
    }
    if (f.key === 'main') {
      const defLabel = (els.tDef.options[els.tDef.selectedIndex] && els.tDef.options[els.tDef.selectedIndex].text) || "Target";
      li.textContent = `Attack Type: ${isPen ? "PEN" : "CRIT"} vs ${defLabel}`;
      const ulSub = document.createElement('ul');
      if (isPen) {
        const raw = state.penVal;
        const def = state.def || 0;
        const basePen = raw - def;
        const liRaw = document.createElement('li');
        liRaw.textContent = `Raw PEN + Final PEN: ${raw}`;
        ulSub.appendChild(liRaw);
        const liDef = document.createElement('li');
        liDef.textContent = `Target DEF: ${def}`;
        ulSub.appendChild(liDef);
        if (basePen >= 150) {
          const effPercent = (basePen * 2) - 150;
          const liSpec = document.createElement('li');
          liSpec.textContent = `((${raw} - ${def}) × 2) - 150`;
          ulSub.appendChild(liSpec);
          const liRes = document.createElement('li');
          liRes.textContent = `1.00 + (${effPercent} / 100) → ×${f.mult.toFixed(2)}`;
          ulSub.appendChild(liRes);
        } else {
          const liRes = document.createElement('li');
          liRes.textContent = `1.00 + ((${raw} - ${def}) / 100) → ×${f.mult.toFixed(2)}`;
          ulSub.appendChild(liRes);
        }
      } else {
        const liRaw = document.createElement('li');
        liRaw.textContent = `Crit DMG: ${f.val}`;
        ulSub.appendChild(liRaw);
        const liRes = document.createElement('li');
        liRes.textContent = `1.00 + (${f.val} / 100) → ×${f.mult.toFixed(2)}`;
        ulSub.appendChild(liRes);
      }
      li.appendChild(ulSub);
      ul.appendChild(li);
      return;
    }
    if (f.key === 'dmg') {
      li.textContent = `Final P/M Damage Bonus`;
      const ulSub = document.createElement('ul');
      const liRaw = document.createElement('li');
      liRaw.textContent = `P/M BO: ${f.val}`;
      ulSub.appendChild(liRaw);
      const liRed = document.createElement('li');
      liRed.textContent = `Target Reduction: ${state.dmgred || 0}`;
      ulSub.appendChild(liRed);
      const liEff = document.createElement('li');
      liEff.textContent = `1.00 + ((${f.val} - ${state.dmgred || 0}) / 100) → ×${f.mult.toFixed(2)}`;
      ulSub.appendChild(liEff);
      li.appendChild(ulSub);
      ul.appendChild(li);
      return;
    }
    if (f.key === 'elem') {
      li.textContent = `Element: ${els.wElem.value || 'Neutral'} vs ${els.tAttr.value || 'Neutral'}`;
      const ulSub = document.createElement('ul');
      const li1 = document.createElement('li');
      li1.textContent = `Counter: ${elemCtr.toFixed(2)}`;
      ulSub.appendChild(li1);
      const li2 = document.createElement('li');
      li2.textContent = `${els.wElem.value} Enhance: ${f.val}`;
      ulSub.appendChild(li2);
      const li3 = document.createElement('li');
      li3.textContent = `${elemCtr.toFixed(2)} + ${(f.val/100).toFixed(2)} → ×${f.mult.toFixed(2)}`;
      ulSub.appendChild(li3);
      if (!els.tAttr.value) {
        const li4 = document.createElement('li');
        li4.textContent = "Tools assume target Neutral if you're not targeting any attribute.";
        ulSub.appendChild(li4);
      }
      li.appendChild(ulSub);
      ul.appendChild(li);
      return;
    }
    if (f.key === 'size') {
      li.textContent = `Size: ${els.weapon.value} vs ${els.tSize.value}`;
      const ulSub = document.createElement('ul');
      const li1 = document.createElement('li');
      li1.textContent = `Modifier: ${sizeMod.toFixed(2)}`;
      ulSub.appendChild(li1);
      const li2 = document.createElement('li');
      li2.textContent = `${els.tSize.value} Enhance: ${f.val}`;
      ulSub.appendChild(li2);
      const li3 = document.createElement('li');
      li3.textContent = `${sizeMod.toFixed(2)} + ${(f.val/100).toFixed(2)} → ×${f.mult.toFixed(2)}`;
      ulSub.appendChild(li3);
      li.appendChild(ulSub);
      ul.appendChild(li);
      return;
    }
    if (f.key === 'race') {
      const raceLabel = (els.tRace.options[els.tRace.selectedIndex] && els.tRace.options[els.tRace.selectedIndex].text) || "Target Race";
      li.textContent = `Race: ${raceLabel}`;
      const ulSub = document.createElement('ul');
      const liRaw = document.createElement('li');
      liRaw.textContent = `Race Bonus: ${f.val}`;
      ulSub.appendChild(liRaw);
      const liRes = document.createElement('li');
      liRes.textContent = `1.00 + (${f.val} / 100) → ×${f.mult.toFixed(2)}`;
      ulSub.appendChild(liRes);
      li.appendChild(ulSub);
      ul.appendChild(li);
      return;
    }
    if (f.key === 'attr') {
      const attrLabel = (els.tAttr.options[els.tAttr.selectedIndex] && els.tAttr.options[els.tAttr.selectedIndex].text) || "Target Attribute";
      li.textContent = `Attribute: ${attrLabel}`;
      const ulSub = document.createElement('ul');
      const liRaw = document.createElement('li');
      liRaw.textContent = `Attribute Bonus: ${f.val}`;
      ulSub.appendChild(liRaw);
      const liRes = document.createElement('li');
      liRes.textContent = `1.00 + (${f.val} / 100) → ×${f.mult.toFixed(2)}`;
      ulSub.appendChild(liRes);
      li.appendChild(ulSub);
      ul.appendChild(li);
      return;
    }
    li.textContent = `${f.label}: ${f.val} → ×${f.mult.toFixed(2)}`;
    ul.appendChild(li);
  });
  container.appendChild(ul);
  const p1 = document.createElement('p');
  p1.textContent = "your final base multiplier:";
  container.appendChild(p1);
  const p2 = document.createElement('p');
  let breakdown = "1.00 ";
  breakdown += list.map(f => {
    if (f.show === false) return `× 1.00 (${f.label.toLowerCase()} not selected)`;
    return `× ${f.mult.toFixed(2)}`;
  }).join(' ');
  breakdown += ` = ×${state.mult.toFixed(2)}`;
  p2.textContent = breakdown;
  container.appendChild(p2);
  const DEF_SWAP_OPTIONS = [
    { key: "0def", label: "Dummy (0 DEF)" },
    { key: "130boss", label: "Avg. 130 BOSS" },
    { key: "140boss", label: "Avg. 140 BOSS" },
    { key: "150boss", label: "Avg. 150 BOSS" }
  ];
  const swapWrapper = document.createElement("div");
  swapWrapper.className = "breakdown-swap-wrapper";
  const swapLabel = document.createElement("label");
  swapLabel.setAttribute("for", "breakdown-swap");
  swapLabel.textContent = "Swap Target DEF:";
  const selectSwap = document.createElement("select");
  selectSwap.id = "breakdown-swap";
  selectSwap.className = "breakdown-swap";
  DEF_SWAP_OPTIONS.forEach(optData => {
    const defData = getTargetDefData(optData.key);
    const defVal = Number(defData.def || 0);
    const dmgredVal = Number(defData.dmgred || 0);
    const opt = document.createElement("option");
    opt.value = optData.key;
    opt.textContent = optData.label;
    const atk = (state.atkType || "").toLowerCase();
    const penV = Number((els.pen && els.pen.value) || 0);
    const dmgV = Number((els.dmg && els.dmg.value) || 0);
    let notEnough = false;
    if (atk === "pen") {
      if (penV <= defVal || dmgV <= dmgredVal) {
        notEnough = true;
      }
    } else {
      if (dmgV <= dmgredVal) {
        notEnough = true;
      }
    }
    if (notEnough) {
      opt.disabled = true;
      opt.textContent += " (stats not enough)";
    }
    selectSwap.appendChild(opt);
  });
selectSwap.value = els.tDef.value || "0def";
swapWrapper.appendChild(swapLabel);
swapWrapper.appendChild(selectSwap);
container.appendChild(swapWrapper);

selectSwap.addEventListener("change", () => {
  els.tDef.value = selectSwap.value;
  processCalculation();
});

if (!els.tDef.dataset.swapBound) {
  els.tDef.addEventListener("change", () => {
    selectSwap.value = els.tDef.value;
  });
  els.tDef.dataset.swapBound = '1';
}
  const bq1 = document.createElement('blockquote');
  bq1.className = "noted";
  bq1.textContent = "Only base multipliers! Real output depends on class, skills, buffs, and more. More accurate? Just use job sims.";
  container.appendChild(bq1);
  const bq2 = document.createElement('blockquote');
  bq2.className = "noted";
  bq2.textContent = "In the table, an upward arrow means higher than your stat, a square means roughly equal (±6%), and a downward arrow means lower.";
  container.appendChild(bq2);
  els.hasil.innerHTML = "";
  els.hasil.appendChild(container);
}
function processCalculation() {
  if (!validateRequired()) return;
  const state = computeMultiplier();
  if (!validateValueVsDef(state)) return;
  const isPen = state.atkType === 'pen';
  const atkF = calcAttackFactor(isPen ? 'pen' : 'crit', state.penVal, state.critVal, state.def);
  const sizeMod = getWeaponSizeMod(els.weapon.value, els.tSize.value);
  const elemCtr = getElemCounter(els.wElem.value, els.tAttr.value);
  const includeRace = !!els.tRace.value;
  const includeAttr = !!els.tAttr.value;
  const list = [
    { key: 'main', label: (isPen ? 'Type (PEN)' : 'Type (CRIT)'), val: isPen ? state.penVal : state.critVal, mult: 1 + atkF },
    { key: 'dmg', label: 'Final P/M DMG BNS', val: state.dmgVal, mult: 1 + (state.effDmgVal || 0) / 100 },
    { key: 'elem', label: 'Element', val: state.elemEnhVal, mult: elemCtr + state.elemEnhVal / 100, extra: `counter ${elemCtr.toFixed(2)}` },
    { key: 'size', label: 'Size', val: state.sizeEnhVal, mult: sizeMod + state.sizeEnhVal / 100, extra: `mod ${sizeMod.toFixed(2)}` },
    { key: 'race', label: 'Race', val: state.raceVal, mult: 1 + state.raceVal / 100, show: includeRace },
    { key: 'attr', label: 'Attribute', val: state.attrVal, mult: 1 + state.attrVal / 100, show: includeAttr }
  ];
  renderMultiplierBreakdown(state, list, elemCtr, sizeMod, isPen);
  generateRecommendations(state);
  resultShown = true;
  els.submit.disabled = true;
  els.resetRek.disabled = false;
  els.resetAll.disabled = false;
  lockInputs();
}
function resetRecommendations(){
  if(!resultShown)return;
  const state=computeMultiplier();
  generateRecommendations(state);
}
function resetAll() {
  if(!confirm('Reset all data'))return;
  document.querySelectorAll('input').forEach(i=>i.value='');
  document.querySelectorAll('select').forEach(s=>s.selectedIndex=0);
  resultShown=false;
  els.hasil.textContent='Input your stats to see the result...';
  els.rec.textContent='Balancing stat recommendations for a higher output multiplier.';
  els.submit.disabled=false;els.resetRek.disabled=true;els.resetAll.disabled=true;
  unlockInputs();updateAtkUI();updateDynamicUI();
}
const SUPPORTS_PASSIVE = (() => {
  let supported = false;
  try {
    const opts = Object.defineProperty({}, 'passive', {
      get() { supported = true; }
    });
    window.addEventListener('testPassive', null, opts);
    window.removeEventListener('testPassive', null, opts);
  } catch (_) {}
  return supported;
})();

const SUPPORTS_POINTER = ('PointerEvent' in window);

function showLockedSnack(e) {
  const t = e && e.currentTarget;
  const now = Date.now();
  if (t) {
    if (t._lastLockTs && (now - t._lastLockTs) < 350) return;
    t._lastLockTs = now;
  }
  if (e && e.cancelable) {
    try { e.preventDefault(); } catch(_) {}
  }
  showSnack("Locked!");
}

function bindLockGuard(wrapEl) {
  if (wrapEl.hasAttribute('data-lock-bound')) return;
  const handler = showLockedSnack;
  const listeners = [];
  if (SUPPORTS_POINTER) {
    const opts = { capture: false, passive: false };
    wrapEl.addEventListener('pointerdown', handler, opts);
    listeners.push(['pointerdown', handler, opts]);
  } else {
    const touchOpts = SUPPORTS_PASSIVE ? { capture: false, passive: false } : false;
    wrapEl.addEventListener('touchstart', handler, touchOpts);
    listeners.push(['touchstart', handler, touchOpts]);
    wrapEl.addEventListener('click', handler, false);
    listeners.push(['click', handler, false]);
  }
  wrapEl._lockListeners = listeners;
  wrapEl.setAttribute('data-lock-bound', '1');
}

function unbindLockGuard(wrapEl) {
  if (!wrapEl.hasAttribute('data-lock-bound')) return;
  const listeners = wrapEl._lockListeners;
  if (Array.isArray(listeners)) {
    for (const [type, handler, opts] of listeners) {
      wrapEl.removeEventListener(type, handler, opts);
    }
  } else if (wrapEl._lockHandler) {
    const touchOpts = SUPPORTS_PASSIVE ? { capture: false, passive: false } : false;
    wrapEl.removeEventListener('pointerdown', wrapEl._lockHandler, { capture: false, passive: false });
    wrapEl.removeEventListener('touchstart', wrapEl._lockHandler, touchOpts);
    wrapEl.removeEventListener('click', wrapEl._lockHandler, false);
  }
  delete wrapEl._lockListeners;
  delete wrapEl._lockHandler;
  wrapEl.removeAttribute('data-lock-bound');
  delete wrapEl._lastLockTs;
}

function lockInputs() {
  document.querySelectorAll('.input-wrap').forEach(w => {
    const el = w.querySelector('select, input');
    if (!el) return;
    bindLockGuard(w);
    el.disabled = true;
  });
}

function unlockInputs() {
  document.querySelectorAll('.input-wrap').forEach(w => {
    const el = w.querySelector('select, input');
    if (!el) return;
    el.disabled = false;
    unbindLockGuard(w);
  });
}


function fillDropdowns() {
  const atkSel = els.atkType;
  atkSel.innerHTML = '<option value="">Select Attack Type</option>' +
    '<option value="pen">P/M PEN</option><option value="crit">Critical</option>';
  const wSel = els.weapon;
  wSel.innerHTML = '<option value="">Select Weapon</option>' +
    Object.keys(weaponSizeModifier).map(w => `<option value="${w}">${w}</option>`).join('');
  const weSel = els.wElem;
  weSel.innerHTML = '<option value="">Select Attribute</option>' +
    Object.keys(elementCounter).map(a => `<option value="${a}">${a}</option>`).join('');
  const tSizeSel = els.tSize;
  tSizeSel.innerHTML = '<option value="">Select Target Size</option>' +
    '<option value="Small">Small</option><option value="Medium">Medium</option><option value="Large">Large</option>';
  const tRaceSel = els.tRace;
  tRaceSel.innerHTML = '<option value="">Select Target Race (none)</option>' +
    raceTypes.map(r => `<option value="${r}">${r}</option>`).join('');
  const tDefSel = els.tDef;
  tDefSel.innerHTML = '<option value="">Select target DEF</option><option value="0def">Dummy (0 DEF)</option><option value="130boss">Average 130 BOSS</option><option value="140boss">Average 140 BOSS</option><option value="150boss">Average 150 BOSS</option>';
  const tAttrSel = els.tAttr;
  tAttrSel.innerHTML = '<option value="">Select Target Attribute (none)</option>' +
    Object.keys(elementCounter).map(a => `<option value="${a}">${a}</option>`).join('');
}
function bindEvents() {
  if (bindEvents.bound) return;
  bindEvents.bound = true;

  fillDropdowns();
  els.submit.addEventListener('click', processCalculation);
  els.resetRek.addEventListener('click', resetRecommendations);
  els.resetAll.addEventListener('click', resetAll);

  [
    'penCritSelect', 'weaponSelect', 'weaponElementSelect',
    'targetSizeSelect', 'targetRaceSelect', 'targetElementSelect'
  ].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('change', onDropdownChange);
  });
  
  // numeric clipboard filter
  ["pen", "crit", "dmg", "elemEnh", "sizeEnh", "race", "attr"].forEach(key => {
  const el = els[key];
  if (!el) return;
  el.addEventListener("blur", () => normalizeInput(el));
  el.addEventListener("paste", e => {
    e.preventDefault();
    let text = (e.clipboardData || window.clipboardData).getData("text");
    normalizeInput(el, text);
  });
});
}

// sticky button mobile
function safeBottom(idx = 0) {
  return `calc(${20 + idx * 56}px + env(safe-area-inset-bottom))`;
}
function handleSticky() {
  const resetRek = document.getElementById("resetRekomenBtn");
  const resetAll = document.getElementById("resetAllBtn");
  const swapBoss = document.getElementById("breakdown-swap");
  const rec = document.getElementById("recommendations");
  let toggleBtn = document.getElementById("toggleStickyBtn");
  let backBtn = document.getElementById("backToHasilBtn");

  if (!toggleBtn) {
    toggleBtn = document.createElement("button");
    toggleBtn.id = "toggleStickyBtn";
    document.body.appendChild(toggleBtn);
    toggleBtn.addEventListener("click", () => {
      toggleBtn.dataset.collapse = toggleBtn.dataset.collapse === "true" ? "false" : "true";
      toggleBtn.classList.toggle("active");
      document.querySelectorAll("#resetRekomenBtn.sticky, #resetAllBtn.sticky, #breakdown-swap.sticky, #backToHasilBtn.sticky")
        .forEach(btn => btn.classList.toggle("collapsed"));
      handleSticky();
    });
  }

  if (!backBtn) {
    backBtn = document.createElement("button");
    backBtn.id = "backToHasilBtn";
    document.body.appendChild(backBtn);
    backBtn.addEventListener("click", () => {
      const hasil = document.getElementById("hasil");
      if (hasil) hasil.scrollIntoView({ behavior: "smooth" });
    });
  }

  if (!toggleBtn.dataset.collapse) toggleBtn.dataset.collapse = "true";
  const collapsed = toggleBtn.dataset.collapse === "true";

[resetRek, resetAll].forEach(btn => {
  if (btn && !btn.getAttribute("data-original-text")) {
    btn.setAttribute("data-original-text", btn.textContent);
  }
});
  if (window.innerWidth > 480) {
    [resetRek, resetAll, swapBoss, backBtn, toggleBtn].forEach(btn => {
      if (btn) {
        btn.classList.remove("sticky");
        btn.style.right = "";
        if (btn.dataset.originalText) btn.textContent = btn.dataset.originalText;
      }
    });
    return;
  }
  const isSticky = rec && rec.getBoundingClientRect().top <= 0;
  if (resetAll) {
    resetAll.classList.toggle("sticky", isSticky);
    resetAll.textContent = isSticky && !collapsed ? "" : resetAll.dataset.originalText;
  }
  if (resetRek) {
    resetRek.classList.toggle("sticky", isSticky);
    resetRek.textContent = isSticky && !collapsed ? "" : resetRek.dataset.originalText;
  }
  if (swapBoss) swapBoss.classList.toggle("sticky", isSticky);
  if (backBtn) backBtn.classList.toggle("sticky", isSticky);
  toggleBtn.classList.toggle("sticky", isSticky);
  const activeSticky = [toggleBtn, resetRek, swapBoss, resetAll, backBtn]
    .filter(btn => btn && btn.classList.contains("sticky"));

if (!collapsed) {
  activeSticky.forEach((btn, idx) => {
    if (!btn) return;
    btn.style.right = "20px";
    btn.style.bottom = safeBottom(idx);
  });
} else {
  [resetAll, resetRek, swapBoss, backBtn].forEach(btn => {
    if (!btn) return;
    btn.style.bottom = safeBottom(btn);
    btn.style.right = "20px";
  });

  toggleBtn.style.right = "20px";
  toggleBtn.style.bottom = safeBottom(0);
}





}


document.addEventListener("DOMContentLoaded", () => {
  if (!els || !els.log) return;
  const content = els.log.querySelector(".changelog");
  els.log.style.display = "none";
  if (els.openLog) els.openLog.addEventListener("click", () => { els.log.style.display = "flex"; });
  if (els.closeLog) els.closeLog.addEventListener("click", () => { els.log.style.display = "none"; });
  bindEvents();
  updateAtkUI();
  updateDynamicUI();
  handleSticky();
  window.addEventListener("scroll", handleSticky);
  window.addEventListener("resize", handleSticky);
  const moTarget = els.hasil || document.body;
  const mo = new MutationObserver(() => {
    if (document.getElementById('breakdown-swap')) {
      mo.disconnect();
      handleSticky();
    }
  });
  mo.observe(moTarget, { childList: true, subtree: true });
});
</script>
 </body>
</html>
