<!DOCTYPE html>
<!-- 96% chatgpt, 3% claude sonnet, 1% me just asking ai to write this line -->
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1" name="viewport"/>
  <title>Alt-Sim</title>
  <meta name="description" content="Calc base multiplier and randomize around your stats for better results."/>
    <meta name="theme-color" content="#36393f">
<meta name="msapplication-TileColor" content="#36393f">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- script async src="https://www.googletagmanager.com/gtag/js?id=G-5XWWWBSH8P"></script -->
<!--script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-5XWWWBSH8P');
</script-->
<style>
/* DARK THEME CSS ORGANIZED & READABLE */

/* 1. RESET & BASE CONFIGURATION */

/* Universal Reset */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

/* CSS Custom Properties (Design Tokens) */
:root {
  
  --bg: #36393f;
  --text: #b9bbbe;
  --label: #dcddde;
  --primary: #5865f2;
  --secondary: #4f545c;
  --danger: #ed4245;
  --border: #202225;
  
  
  --card-bg: #2f3136;
  --input-bg: #40444b;
  --hover-bg: #34373c;
  --input-disabled: #2f3136;
  --text-muted: #8e9297;
  --text-subtle: #72767d;
  
  
  --radius: 8px;
  --shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  --transition: 0.28s ease-in-out;
  
  
  --font-size-xs: 0.75rem;    
  --font-size-sm: 0.875rem;   
  --font-size-base: 1rem;     
  --font-size-lg: 1.125rem;   
  --font-size-xl: 1.25rem;    
  --font-size-2xl: 1.5rem;    
  --font-size-3xl: 1.875rem;  
  
  --line-height-tight: 1.25;
  --line-height-normal: 1.5;
  --line-height-relaxed: 1.625;
  
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 600;
  --font-weight-bold: 700;
  
  --letter-spacing-tight: -0.025em;
  --letter-spacing-normal: 0;
  --letter-spacing-wide: 0.025em;
}

/* Base HTML Elements */
html {
  font-size: 100%;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}

body {
  font-family: 'Inter', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-normal);
  line-height: var(--line-height-normal);
  letter-spacing: var(--letter-spacing-normal);
  background: var(--bg);
  color: var(--text);
  padding-bottom: env(safe-area-inset-bottom);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  scroll-behavior: smooth;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior-y: none;
  -ms-scroll-chaining: none;
  -ms-touch-action: pan-y;
  touch-action: pan-y;
  -webkit-tap-highlight-color: transparent;
}

/* Typography Elements */
h1, h2, h3, h4, h5, h6 {
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-tight);
  letter-spacing: var(--letter-spacing-tight);
  color: var(--label);
  margin-bottom: 0.75rem;
}

h1 {
  font-size: var(--font-size-3xl);
  margin-bottom: 1rem;
}

h2 {
  font-size: var(--font-size-2xl);
  margin-bottom: 0.875rem;
}

h3 {
  font-size: var(--font-size-xl);
  margin-bottom: 0.75rem;
}

h4 {
  font-size: var(--font-size-lg);
  margin-bottom: 0.625rem;
}

h5, h6 {
  font-size: var(--font-size-base);
  margin-bottom: 0.5rem;
}

p {
  font-size: var(--font-size-base);
  line-height: var(--line-height-normal);
  margin-bottom: 1rem;
  color: var(--text);
}

small {
  font-size: var(--font-size-sm);
  line-height: var(--line-height-normal);
  color: var(--text-muted);
}

/* Specific Link Styling */
a {
  color: var(--primary);
  text-decoration: none;
  transition: color 0.2s ease;
}

a:hover {
  color: #7289da;
}

a:focus {
  outline: 2px solid var(--primary);
  outline-offset: 2px;
}

/* 2. LAYOUT COMPONENTS */

/* Container & Grid System */
.container {
  max-width: 800px;
  margin: 0 auto;
  padding: 24px;
}

.form-row {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 20px;
  margin-bottom: 24px;
}

.form-group {
  display: flex;
  flex-direction: column;
  margin-bottom: 8px;
}

.form-group label {
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-medium);
  line-height: var(--line-height-tight);
  color: var(--label);
  margin-bottom: 8px;
  letter-spacing: var(--letter-spacing-wide);
}

/* 3. FORM ELEMENTS */

/* Input Fields & Select Dropdowns */
.input-wrap input,
.input-wrap select {
  height: 44px;
  width: 100%;
  padding: 12px 16px;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  background: var(--input-bg);
  box-shadow: var(--shadow);
  color: var(--text);
  font-size: var(--font-size-base);
  line-height: 1;
  transition: var(--transition);
  background-clip: padding-box;
  display: flex;
  align-items: center;
}

/* Select Specific Styling */
.input-wrap select {
  padding-right: 40px;
  appearance: none;
  cursor: pointer;
  transition: border-color 0.28s ease-in-out, box-shadow 0.28s ease-in-out, background-color 0.28s ease-in-out;
}

/* Input States */
.input-wrap input:focus,
.input-wrap select:focus {
  border-color: var(--primary);
  outline: none;
  box-shadow: 0 0 0 2px rgba(88, 101, 242, .3);
  background: var(--hover-bg);
}

.input-wrap input:disabled,
.input-wrap select:disabled {
  background: var(--input-disabled);
  color: var(--text-subtle);
  opacity: .7;
  cursor: not-allowed;
  box-shadow: none;
  border-color: #1e2124;
}


.select-wrap {
  position: relative;
}

.select-wrap::after {
  content: "";
  position: absolute;
  right: 10px;
  top: 50%;
  width: 16px;
  height: 16px;
  transform: translateY(-50%) rotate(0deg);
  background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%23b9bbbe'><path d='M4 6l4 4 4-4z'/></svg>");
  background-repeat: no-repeat;
  background-size: contain;
  pointer-events: none;
  transition: transform 0.3s ease;
}

.select-wrap:focus-within::after {
  transform: translateY(-50%) rotate(180deg);
}
select.invalid-value,select.invalid-value:focus,input.invalid-value,input.invalid-value:focus {
  box-shadow: none;
  border-color: #c13537;
  transition: border-color 0.5s ease;
}

/* 4. BUTTON COMPONENTS */

/* Button Container */
.btn-row {
  display: flex;
  gap: 16px;
  margin-top: 32px;
}

/* Base Button Styling */
.btn-row button {
  height: 44px;
  padding: 0 20px;
  border: none;
  border-radius: var(--radius);
  cursor: pointer;
  color: #ffffff;
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-medium);
  line-height: var(--line-height-normal);
  letter-spacing: var(--letter-spacing-wide);
  transition: var(--transition);
}

/* Button Variants */
#submitBtn {
  background: #4752c4;
}
#submitBtn:hover {
  background: #3c45a5;
}
#submitBtn:active,
#submitBtn:focus {
  background: #343a8f;
}

#resetRekomenBtn {
  background: #5a6069;
}
#resetRekomenBtn:hover {
  background: #646b75;
}
#resetRekomenBtn:active,
#resetRekomenBtn:focus {
  background: #6e7681;
}

#resetAllBtn {
  background: #c13537;
}
#resetAllBtn:hover {
  background: #a82d2f;
}
#resetAllBtn:active,
#resetAllBtn:focus {
  background: #8f2527;
}

#testSpear {
  background: #cc8400;
}
#testSpear:hover {
  background: #b37400;
}
#testSpear:active,
#testSpear:focus {
  background: #996300;
}

#testReaper {
  background: #7e3ff2;
}
#testReaper:hover {
  background: #6931d9;
}
#testReaper:active,
#testReaper:focus {
  background: #5625b0;
}

/* Button States */
button:disabled {
  opacity: .5;
  cursor: not-allowed;
  pointer-events: none;
}

/* 5. RESULT & CONTENT CONTAINERS */

/* Main Result Containers Fixed Typography Hierarchy */
#hasil,
#recommendations {
  background: var(--hover-bg);
  padding: 24px;
  margin-top: 24px;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
}

/* Enhanced typography for #hasil Better hierarchy */
#hasil > p {
  font-size: var(--font-size-base);
  line-height: var(--line-height-normal);
  margin-bottom: 1rem;
  color: var(--text);
}

#hasil > p#breakdown-summary {
  font-size: var(--font-size-lg);
  font-weight: var(--font-weight-medium);
  line-height: var(--line-height-tight);
  color: var(--label);
  margin-bottom: 1.25rem;
  padding: 16px 20px;
  background: var(--card-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
}

#recommendations {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 24px;
}

/* 6. TABLE COMPONENTS IMPROVED TYPOGRAPHY & SPACING */

/* Table Wrapper */
.table-wrapper {
  width: 100%;
  overflow-x: auto;
  border-radius: var(--radius);
  background: var(--card-bg);
  box-shadow: var(--shadow);
  margin: 8px 0;
  border: 1px solid var(--border);
}

/* Table Structure */
#recommendations table {
  width: 100%;
  border-collapse: collapse;
  background: transparent;
  border: none;
  table-layout: auto;
  font-variant-numeric: tabular-nums; /* Better number alignment */
}

/* Table Caption Better hierarchy */
#recommendations caption {
  text-align: left;
  padding: 18px 20px 16px 20px;
  background: var(--card-bg);
  border-bottom: 1px solid var(--border);
  border-radius: var(--radius) var(--radius) 0 0;
  color: var(--label);
  font-size: var(--font-size-lg);
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-tight);
  letter-spacing: var(--letter-spacing-tight);
}

/* Table Headers Optimized for wrapping long text */
#recommendations th {
  padding: 12px 8px;
  text-align: center;
  background: var(--card-bg);
  color: var(--label);
  border-right: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-tight);
  letter-spacing: var(--letter-spacing-wide);
  text-transform: uppercase;
  font-variant: small-caps;
  word-wrap: break-word;
  hyphens: auto;
  max-width: 60px;
  vertical-align: bottom;
}

/* Table Data Cells Optimized for numeric data consistency */
#recommendations td {
  padding: 14px 10px;
  text-align: center;
  color: var(--text);
  border-right: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-medium);
  line-height: var(--line-height-normal);
  letter-spacing: var(--letter-spacing-normal);
  vertical-align: middle;
  background: var(--card-bg);
  transition: background-color 0.2s ease;
  white-space: nowrap;
  min-width: 65px;
}

/* Table row hover effect for better readability */
#recommendations tbody tr:hover td {
  background: var(--hover-bg);
}

/* Remove borders from last column and row */
#recommendations th:last-child,
#recommendations td:last-child {
  border-right: none;
}

#recommendations tbody tr:last-child td {
  border-bottom: none;
}

/* Table Cell Content Better spacing for spans */
#recommendations td span {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
  font-variant-numeric: tabular-nums;
}

/* Status Indicators Restored original precision */
#recommendations td span::before {
  font-size: calc(var(--font-size-xs) * 0.4);
}

span.up::before {
  content: "\25B2";
  color: #57f287;
  margin-right: 1px;
  position: relative;
  top: 0.5px;
}

span.down::before {
  content: "\25BC";
  color: #3498db;
  margin-right: 1px;
  position: relative;
  top: 0.5px;
}

span.neutral::before {
  content: "\25A0";
  color: var(--text-subtle);
  margin-right: 1px;
  position: relative;
  top: 0.5px;
}

/* Special Table Cells Enhanced typography */
td.mult {
  font-weight: var(--font-weight-bold);
  color: var(--label);
  font-size: var(--font-size-lg);
  letter-spacing: var(--letter-spacing-tight);
}

td.delta {
  color: #57f287;
  font-weight: var(--font-weight-bold);
  font-size: var(--font-size-lg);
  letter-spacing: var(--letter-spacing-tight);
}

/* 7. STICKY BUTTONS SYSTEM */

/* Base Sticky Button */
.sticky {
  position: fixed;
  bottom: calc(24px + env(safe-area-inset-bottom));
  right: 24px;
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  cursor: pointer;
  z-index: 1000;
  border: none;
  background-repeat: no-repeat;
  background-position: center;
  background-size: 26px;
  transition: transform .3s cubic-bezier(.4, 0, .2, 1), opacity .3s cubic-bezier(.4, 0, .2, 1);
}

/* Sticky Button States */
.sticky.collapsed {
  opacity: 0;
  pointer-events: none;
  z-index: 999;
}

.sticky:not(.collapsed) {
  opacity: 1;
  pointer-events: auto;
}

/* Toggle Button Special Handling */
#toggleStickyBtn.sticky {
  z-index: 1001;
}

#toggleStickyBtn.sticky.collapsed {
  opacity: 1 !important;
  pointer-events: auto !important;
  z-index: 1001 !important;
}

#toggleStickyBtn.sticky {
  opacity: 1 !important;
  pointer-events: auto !important;
}

/* Individual Sticky Button Styles */
#testSpear.sticky,
#testReaper.sticky {
  background: center/26px no-repeat;
}
#testSpear.sticky {
  background-color: #cc8400;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 24 24'%3E%3Cpath fill='%23fff' d='M17 10h-3.61l2.28 2.28zm0-8H7v1.61l6.13 6.13zm-13.59.86L2 4.27l5 5V13h3v9l3.58-6.15L17.73 20l1.41-1.41z'/%3E%3C/svg%3E");
}
#testReaper.sticky {
  background-color: #7e3ff2;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 24 24'%3E%3Cpath fill='%23fff' d='M17 10h-3.61l2.28 2.28zm0-8H7v1.61l6.13 6.13zm-13.59.86L2 4.27l5 5V13h3v9l3.58-6.15L17.73 20l1.41-1.41z'/%3E%3C/svg%3E");
}

/* activated state */
#testSpear.sticky.activated,
#testReaper.sticky.activated {
  overflow: hidden;
  background: center/26px no-repeat;
}
#testSpear.sticky.activated {
  background-color: #cc8400;
}
#testReaper.sticky.activated {
  background-color: #7e3ff2;
}

/* Animation effects */
#testSpear.sticky.activated::before,
#testReaper.sticky.activated::before {
  content: '';
  position: absolute;
  top: -20px;
  left: -20px;
  width: 88px;
  height: 88px;
  background: conic-gradient(
    hsla(0, 0%, 100%, 0)        0deg,
    hsla(42, 100%, 72%, 0.35)  40deg,
    hsla(42, 100%, 68%, 0.75)  80deg,
    hsla(255, 100%, 78%, 0.8) 120deg,
    hsla(255, 100%, 72%, 0.6) 160deg,
    hsla(220, 100%, 78%, 0.55)200deg,
    hsla(220, 100%, 85%, 0.4) 240deg,
    hsla(0, 0%, 100%, 0.3)    280deg,
    hsla(0, 0%, 100%, 0.15)   320deg,
    hsla(0, 0%, 100%, 0)      360deg
  );
  border-radius: 50%;
  -webkit-border-radius: 50%;
  -moz-border-radius: 50%;
  filter: blur(4px);
  -webkit-filter: blur(4px);
  opacity: 0.7;
  animation: rotate-shine 3s linear infinite;
  -webkit-animation: rotate-shine 3s linear infinite;
  -moz-animation: rotate-shine 3s linear infinite;
  -o-animation: rotate-shine 3s linear infinite;
  z-index: 1;
}

/* SVG icon foreground */
#testSpear.sticky.activated::after,
#testReaper.sticky.activated::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 26px;
  height: 26px;
  transform: translate(-50%, -50%);
  -webkit-transform: translate(-50%, -50%);
  -moz-transform: translate(-50%, -50%);
  -ms-transform: translate(-50%, -50%);
  -o-transform: translate(-50%, -50%);
  background: center/26px no-repeat;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' height='48' viewBox='0 -960 960 960' width='48'%3E%3Cpath fill='%23fff' d='m460-272 186-268H520l81-280H340v360h120v188ZM400-80v-320H280v-480h400l-80 280h160L400-80Zm60-380H340h120Z'/%3E%3C/svg%3E");
  z-index: 2;
}

/* @keyframes rotateshine */
@keyframes rotate-shine {
  0%   { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@-webkit-keyframes rotate-shine {
  0%   { -webkit-transform: rotate(0deg); }
  100% { -webkit-transform: rotate(360deg); }
}

@-moz-keyframes rotate-shine {
  0%   { -moz-transform: rotate(0deg); }
  100% { -moz-transform: rotate(360deg); }
}

@-o-keyframes rotate-shine {
  0%   { -o-transform: rotate(0deg); }
  100% { -o-transform: rotate(360deg); }
}

#resetRekomenBtn.sticky {
  background: #5a6069 url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 24 24'%3E%3Cpath d='M17.65 6.35A7.95 7.95 0 0 0 12 4a8 8 0 1 0 7.9 9h-2.02a6 6 0 1 1-5.88-7c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z'/%3E%3C/svg%3E") center/26px no-repeat;
}

#resetAllBtn.sticky {
  background: #c13537 url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 -960 960 960'%3E%3Cpath fill='%23fff' d='M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm400-600H280v520h400v-520ZM360-280h80v-360h-80v360Zm160 0h80v-360h-80v360ZM280-720v520-520Z'/%3E%3C/svg%3E") center/26px no-repeat;
}

#breakdown-swap.sticky {
  background: #c13537 url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='white' viewBox='0 -960 960 960'%3E%3Cpath d='M769-88 645-212l-88 88-43-43q-17-17-17-42t17-42l199-199q17-17 42-17t42 17l43 43-88 88 123 124q9 9 9 21t-9 21l-64 65q-9 9-21 9t-21-9Zm111-636L427-271l19 20q17 17 17 42t-17 42l-43 43-88-88L191-88q-9 9-21 9t-21-9l-65-65q-9-9-9-21t9-21l124-124-88-88 43-43q-17-17 42-17t42 17l20 19 453-453h160v160ZM320-568l38-38 38-38-38 38-38 38Zm-42 42L80-724v-160h160l198 198-42 42-181-180h-75v75l180 181-42 42Zm105 212 437-435v-75h-75L308-389l75 75Zm0 0-37-38-38-37 38 37 37 38Z'/%3E%3C/svg%3E") center/26px no-repeat;
  color: transparent;
  text-shadow: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  width: 48px;
  max-width: 48px;
  min-width: 48px;
  padding: 0;
  text-indent: -9999px;
}

#backToHasilBtn.sticky {
  background: #4a9b5e url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 24 24'%3E%3Cpath d='M4 12l1.41 1.41L11 7.83V20h2V7.83l5.59 5.58L20 12l-8-8-8 8z'/%3E%3C/svg%3E") center/26px no-repeat;
}

#toggleStickyBtn.sticky {
  background: var(--primary) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%23fff' d='M18.3 5.71L12 12l-6.3-6.29-1.41 1.41L10.59 13.4l-6.3 6.3 1.41 1.41L12 14.83l6.29 6.29 1.42-1.41-6.3-6.3 6.3-6.29z'/%3E%3C/svg%3E") center/26px no-repeat;
}

#toggleStickyBtn.sticky.active {
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%23fff' d='M3 6h18v2H3V6zm0 5h18v2H3v-2zm0 5h18v2H3v-2z'/%3E%3C/svg%3E");
}

/* 8. BREAKDOWN & MULTIPLIER SECTIONS */

/* Breakdown Swap Component */
.breakdown-swap-wrapper {
  display: flex;
  align-items: center;
  gap: 12px;
  margin: 20px 0;
}

.breakdown-swap-wrapper label {
  color: var(--label);
  white-space: nowrap;
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-medium);
  line-height: var(--line-height-normal);
}

.breakdown-swap {
  appearance: none;
  background: var(--input-bg) url("data:image/svg+xml;utf8,<svg fill='%23b9bbbe' height='20' viewBox='0 0 24 24' width='20' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/></svg>") no-repeat right 12px center/16px;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 10px 36px 10px 16px;
  cursor: pointer;
  outline: none;
  transition: border-color 0.28s ease-in-out, box-shadow 0.28s ease-in-out, background-color 0.28s ease-in-out;
  width: 180px;
  max-width: 50%;
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
  color: var(--text);
  font-size: var(--font-size-sm);
  line-height: var(--line-height-normal);
}

.breakdown-swap:hover {
  border-color: var(--text-subtle);
  background-color: var(--hover-bg);
}

.breakdown-swap:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 2px rgba(88, 101, 242, .3);
  background: var(--hover-bg);
}

/* Multiplier Breakdown Container Enhanced Typography */
#multiplier-breakdown {
  background: var(--card-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 0 20px 20px 20px;
  /* boxshadow: inset 0 0 12px rgba(0, 0, 0, 0.3), inset 0 0 6px rgba(0, 0, 0, 0.45); */
  color: var(--text);
  margin: 8px 0;
}

#multiplier-breakdown > p:first-of-type {
  color: var(--label);
  margin-bottom: 16px;
  font-size: var(--font-size-lg);
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-tight);
  padding-top: 16px;
}

#multiplier-breakdown > p:nth-of-type(2) {
  margin-bottom: 20px;
  background: var(--input-bg);
  padding: 14px 18px;
  border-radius: var(--radius);
  border: 1px solid var(--border);
  font-variant-numeric: tabular-nums;
  color: var(--label);
  /* boxshadow: inset 0 0 12px rgba(0, 0, 0, 0.3), inset 0 0 6px rgba(0, 0, 0, 0.45); */
  font-size: var(--font-size-lg);
  line-height: var(--line-height-normal);
  font-weight: var(--font-weight-semibold);
}

/* Enhanced blockquote styling for better readability */
#multiplier-breakdown blockquote.noted {
  margin: 16px 0;
  padding: 14px 18px;
  border: 1px solid var(--border);
  background: var(--input-bg);
  color: var(--text);
  border-radius: var(--radius);
  /* boxshadow: inset 0 0 12px rgba(0, 0, 0, 0.3), inset 0 0 6px rgba(0, 0, 0, 0.45); */
  font-size: var(--font-size-sm);
  line-height: var(--line-height-relaxed);
}

/* Factor Breakdown Lists Improved hierarchy */
.factor-breakdown {
  margin: 0;
  padding: 0;
  list-style: none;
  color: var(--text);
}

.factor-breakdown > li {
  margin: 14px 0;
  font-size: var(--font-size-base);
  line-height: var(--line-height-relaxed);
  color: var(--label);
  font-weight: var(--font-weight-medium);
}

.factor-breakdown li ul {
  margin: 12px 0 0 16px;
  padding-left: 16px;
  list-style: none;
  color: var(--text);
  border-left: 2px solid var(--border);
}

.factor-breakdown li ul li {
  margin: 10px 0;
  font-size: var(--font-size-sm);
  line-height: var(--line-height-relaxed);
  font-weight: var(--font-weight-normal);
}

.factor-breakdown li ul li.note {
  color: var(--text-muted);
  font-style: italic;
  padding-left: 0;
  margin-left: 0;
  font-size: var(--font-size-xs);
}

.factor-breakdown > li span.neutral-flag {
  color: var(--text-subtle);
  margin-left: 8px;
  font-family: ui-monospace, 'Fira Code', monospace;
  font-size: var(--font-size-xs);
}

/* 9. HOWTO SECTION FIXED & OPTIMIZED */

/* HowTo Container */
#howto {
  margin: 0 auto 24px;
  width: 100%;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  overflow: hidden;
}

/* HowTo Summary (Header) */
#howto summary {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 16px 16px 20px;
  cursor: pointer;
  color: var(--label);
  background: var(--card-bg);
  border: none;
  box-shadow: inset 0 1px 3px rgba(0, 0, 0, .1);
  border-radius: var(--radius) var(--radius) 0 0;
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-medium);
  line-height: var(--line-height-normal);
  transition: background-color 0.2s ease;
}

#howto summary:hover {
  background: var(--hover-bg);
}

#howto summary::-webkit-details-marker {
  display: none;
}

#howto summary span {
  color: var(--label);
}

#howto summary::after {
  content: "";
  flex-shrink: 0;
  width: 16px;
  height: 16px;
  margin-left: 12px;
  background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%23dcddde'><path d='M4 6l4 4 4-4z'/></svg>") center/16px no-repeat;
  transition: transform 0.3s ease;
}

#howto[open] summary {
  border-radius: var(--radius) var(--radius) 0 0;
}

#howto[open] summary::after {
  transform: rotate(180deg);
}

/* HowTo Body Content */
#howto .body {
  padding: 16px 20px 20px 20px;
  background: var(--card-bg);
  border: none;
  border-top: 1px solid var(--border);
  box-shadow: inset 0 1px 3px rgba(0, 0, 0, .1);
  border-radius: 0 0 var(--radius) var(--radius);
}

/* HowTo Lists Improved Typography Hierarchy */
#howto ol {
  counter-reset: step;
  margin: 0;
  padding: 0;
  list-style: none;
}

#howto ol > li {
  position: relative;
  margin: 18px 0;
  padding-left: 36px;
  color: var(--label);
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-medium);
  line-height: var(--line-height-relaxed);
}

#howto ol > li::before {
  counter-increment: step;
  content: counter(step) ".";
  position: absolute;
  left: 0;
  top: 0;
  color: var(--primary);
  font-weight: var(--font-weight-bold);
  font-size: var(--font-size-lg);
  line-height: var(--line-height-tight);
}

#howto ol > li strong {
  color: var(--label);
  font-weight: var(--font-weight-semibold);
}

/* Nested lists in howto */
#howto ul {
  margin: 12px 0 0 0;
  padding: 0;
  list-style: none;
}

#howto ul li {
  position: relative;
  margin: 10px 0;
  padding-left: 24px;
  color: var(--text);
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-normal);
  line-height: var(--line-height-normal);
}

#howto ul li::before {
  content: "\2022";
  position: absolute;
  left: 0;
  top: 0;
  color: var(--primary);
  font-weight: var(--font-weight-medium);
}

/* Nested ul inside li */
#howto li ul {
  margin: 8px 0 0 0;
  padding-left: 16px;
  border-left: 2px solid var(--border);
}

#howto li ul li {
  margin: 6px 0;
  font-size: var(--font-size-xs);
  color: var(--text-muted);
  padding-left: 20px;
}

#howto li ul li::before {
  content: "\25E6";
  color: var(--text-subtle);
  font-size: var(--font-size-sm);
}

#howto li.muted {
  color: var(--text-muted);
  font-style: italic;
  font-size: var(--font-size-sm);
}

#howto em {
  color: var(--text-muted);
  font-style: italic;
}
#howto .body {
      overflow: hidden;
      max-height: 0;
      transition: max-height 0.4s ease;
}

code {
  font-family: 'Fira Code', ui-monospace, monospace;
  background: var(--input-bg);
  color: var(--label);
  padding: 3px 6px;
  border-radius: 4px;
  font-size: var(--font-size-sm);
  border: 1px solid var(--border);
}

blockquote code {
  background: var(--card-bg);
}
#howto .content {
  overflow: hidden;
  transition: max-height 0.4s ease;
  max-height: 0;
}
/* 10. VERSION & FOOTER SECTIONS */

/* Version Information Reduced font sizes */
#version {
  margin-bottom: 32px;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 16px;
}

#version p {
  margin-bottom: 0;
  font-size: var(--font-size-xs);
  line-height: var(--line-height-normal);
  color: var(--text-muted);
}

#version p:first-child {
  display: flex;
  align-items: center;
  gap: 6px;
}

#version p:last-child {
  font-style: italic;
  color: var(--text-subtle);
  text-align: right;
  white-space: nowrap;
}

#version button,
#version a,
.toggle-precision {
  font-family: 'Fira Code', ui-monospace, monospace;
  text-decoration: none;
  outline: none;
  border: 0;
  background: none;
  color: var(--primary);
  font-size: var(--font-size-xs);
  line-height: var(--line-height-normal);
  font-weight: var(font-weight-medium);
  cursor: pointer;
  transition: color 0.2s ease;
}

#version a {
  font-weight: var(--font-weight-medium);
}

#version button:hover,
#version a:hover,
.toggle-precision:hover {
  color: #8b5cf6;
}
#version button:hover,
#version a:hover,
.toggle-precision:hover {
  color: #6366f1; 
}

.toggle-precision {
  padding: 0 4px;
  text-decoration: underline dotted;
  font-size: var(--font-size-base);
  font-family: inherit;
  font-weight: inherit;
}

/* Footer Reduced font size, kept left alignment */
.footer {
  margin-top: 32px;
  color: var(--text-muted);
  font-size: var(--font-size-xs);
  line-height: var(--line-height-relaxed);
  text-align: left;
}

/* Miscellaneous Elements */
svg {
  display: inline-block;
  margin: 0 2px -2px 0;
}

hr.separ {
  margin: 20px auto 16px;
  border: none;
  height: 2px;
  background-color: var(--border);
  border-radius: var(--radius);
}

/* 11. UI FEEDBACK COMPONENTS */

/* Snackbar Notifications */
.snackbar {
  position: fixed;
  left: 50%;
  transform: translateX(-50%) translateY(30px);
  bottom: 16px;
  background: rgba(0, 0, 0, .8);
  color: #fff;
  padding: 10px 14px;
  border-radius: var(--radius);
  opacity: 0;
  pointer-events: none;
  text-align: center;
  box-shadow: var(--shadow);
  font-size: var(--font-size-sm);
  line-height: var(--line-height-normal);
  transition: opacity 0.3s ease, transform 0.3s ease;
}

.snackbar.show {
  opacity: 1;
  pointer-events: auto;
  transform: translateX(-50%) translateY(0);
  animation: snackbarBounce 0.4s ease;
}

@keyframes snackbarBounce {
  0%   { transform: translateX(-50%) translateY(30px); }
  60%  { transform: translateX(-50%) translateY(-6px); }
  80%  { transform: translateX(-50%) translateY(3px); }
  100% { transform: translateX(-50%) translateY(0); }
}

/* 12. CHANGELOG & OVERLAY MODALS */

/* Changelog Styling */
.changelog {
  position: relative;
  max-width: 70%;
  margin: auto;
  color: var(--text);
}

.changelog .header-log {
  position: relative;
  margin-bottom: 1.5rem;
}

.changelog h2 {
  margin-bottom: 1.2rem;
  color: var(--primary);
  border-bottom: 2px solid var(--border);
  padding-bottom: 0.6rem;
  font-size: var(--font-size-2xl);
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-tight);
  letter-spacing: var(--letter-spacing-tight);
}

.changelog .version {
  margin-bottom: 2rem;
}

.changelog .version h3 {
  color: var(--label);
  margin: 0 0 1rem 0;
  font-size: var(--font-size-xl);
  font-weight: var(--font-weight-medium);
  line-height: var(--line-height-tight);
}

.changelog .version ul {
  list-style: none;
  padding-left: 0.25rem;
  margin: 0;
}

.changelog .version ul li {
  position: relative;
  margin: 0.75rem 0;
  padding-left: 1.25rem;
  font-size: var(--font-size-base);
  line-height: var(--line-height-relaxed);
  color: var(--text);
}

.changelog .version ul li::before {
  content: "\2022";
  color: var(--primary);
  position: absolute;
  left: 0;
}

.changelog .version ul ul {
  margin-top: 0.5rem;
  padding-left: 1rem;
  border-left: 1px solid var(--border);
}

.changelog .version ul ul li {
  font-size: var(--font-size-sm);
  margin: 0.5rem 0;
}

.changelog .sub-cats {
  display: inline-block;
  font-weight: var(--font-weight-semibold);
  color: var(--label);
  font-size: var(--font-size-base);
}

/* Overlay Modal */
#log {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, .6);
  z-index: 1000;
  align-items: center;
  justify-content: center;
  padding: 24px;
  display: none;
}

#log.show,
#log[style*="flex"] {
  display: flex !important;
}

#log .changelog {
  background: var(--card-bg);
  width: 100%;
  max-width: 70%;
  max-height: 500px;
  padding: 24px;
  border-radius: var(--radius);
  box-shadow: 0 4px 20px rgba(0, 0, 0, .4);
  animation: fadeInUp .3s ease;
  position: relative;
  overflow-y: auto;
  border: 1px solid var(--border);
}

#log .close {
  position: absolute;
  top: 16px;
  right: 16px;
  color: var(--text-subtle);
  cursor: pointer;
  transition: var(--transition);
  font-size: var(--font-size-lg);
  font-weight: var(--font-weight-bold);
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
}

#log .close:hover {
  color: var(--label);
  background: var(--hover-bg);
}

/* 13. UTILITY CLASSES */

.hidden {
  display: none !important;
}

/* 14. RESPONSIVE DESIGN */

/* Tablet & Small Desktop */
@media (max-width: 800px) {
  .container {
    padding: 20px;
  }
  
  .form-row {
    grid-template-columns: 1fr;
    gap: 16px;
    margin-bottom: 20px;
  }
  
  .form-group {
    margin-bottom: 0;
  }
  
  .btn-row {
    flex-direction: column;
    gap: 12px;
    margin-top: 24px;
  }
  
  #recommendations {
    grid-template-columns: 1fr;
    gap: 20px;
  }
  
  #hasil,
  #recommendations {
    padding: 20px;
    margin-top: 20px;
  }
  
  #howto summary {
    padding: 12px 12px 12px 16px;
    font-size: var(--font-size-sm);
  }
  
  #howto .body {
    padding: 12px 16px 16px 16px;
  }
  
  #howto ol > li {
    margin: 16px 0;
    font-size: var(--font-size-sm);
    padding-left: 32px;
  }
  
  #howto ol > li::before {
    font-size: var(--font-size-base);
  }
  
  #howto ul li {
    font-size: var(--font-size-xs);
  }
  
  /* Responsive table adjustments */
  #recommendations caption {
    font-size: var(--font-size-base);
    padding: 14px 16px 12px 16px;
  }
  
  #recommendations th {
    padding: 12px 10px;
    font-size: var(--font-size-sm);
  }
  
  #recommendations td {
    padding: 10px 8px;
    font-size: var(--font-size-sm);
  }
  
  td.mult,
  td.delta {
    font-size: var(--font-size-base);
  }
}

/* Mobile Phones SPECIAL STYLES FOR #hasil */
@media (max-width: 480px) {
  .container {
    padding: 16px;
  }
  #multiplier-breakdown {
    background: var(--card-bg);
    box-shadow: var(--shadow);
  }
  /* Mobilespecific #hasil styling ONLY #hasil container */
  #hasil,#recommendations {
    background: transparent;
    padding: 0;
    border: none;
    box-shadow: none;
    margin-top: 16px;
  }
  
  /* Mobile styling for blockquote.noted and p#summary inside #hasil Fixed specificity */
  #hasil > p#breakdown-summary,
  #multiplier-breakdown .noted {
    background: var(--bg);
    box-shadow: inset 0 0 5px 2px rgba(0, 0, 0, 0.3);
    padding: 16px 18px;
    margin-bottom: 16px;
    border-radius: var(--radius);
    border: 1px solid var(--border);
  }
  
  
  #log {
    padding: 16px;
  }
  
  #log .changelog {
    max-width: 80%;
    max-height: 500px;
    padding: 20px;
  }
  
  .changelog h2 {
    font-size: var(--font-size-xl);
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
  }
  
  .changelog .version h3 {
    font-size: var(--font-size-base);
    margin-bottom: 0.5rem;
  }
  
  .changelog .version ul li {
    font-size: var(--font-size-sm);
    margin: 0.375rem 0;
  }
  
  .breakdown-swap-wrapper {
    justify-content: space-between;
    gap: 8px;
  }
  
  .breakdown-swap-wrapper label {
    max-width: 35%;
    font-size: var(--font-size-xs);
  }
  
  .breakdown-swap {
    max-width: 60%;
    font-size: var(--font-size-xs);
  }
  
  
  .sticky {
    bottom: calc(20px + env(safe-area-inset-bottom));
    right: 20px;
  }
  
  /* Mobile table improvements */
  #recommendations caption {
    font-size: var(--font-size-base);
    padding: 12px 14px;
  }
  
  #recommendations th {
    padding: 8px;
    font-size: var(--font-size-xs);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  #recommendations td {
    padding: 8px;
    font-size: var(--font-size-xs);
  }
  
  td.mult,
  td.delta {
    font-size: var(--font-size-sm);
  }
  
  .factor-breakdown > li {
    font-size: var(--font-size-sm);
  }
  
  .factor-breakdown li ul li {
    font-size: var(--font-size-xs);
  }
  
  #howto summary {
    padding: 10px 10px 10px 14px;
    font-size: var(--font-size-sm);
  }
  
  #howto .body {
    padding: 10px 14px 14px 14px;
  }
  
  #howto ol > li {
    margin: 14px 0;
    font-size: var(--font-size-sm);
    padding-left: 28px;
  }
  
  #howto ol > li::before {
    font-size: var(--font-size-base);
  }
  
  #howto ul li {
    font-size: var(--font-size-xs);
    padding-left: 20px;
  }
  
  #howto li ul li {
    font-size: var(--font-size-xs);
    padding-left: 18px;
  }
}

/* 15. ANIMATIONS & TRANSITIONS */

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* DMG STACK TOOLTIP STYLES */

/* DMG STACK TOOLTIP STYLES */

.dmgstack-tips {
  position: absolute;
  z-index: 9999;
  background: rgba(0, 0, 0, .8);
  color: #b9bbbe;
  border-radius: 8px;
  box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
  font-size: 12px;
  line-height: 1.5;
  padding: 10px 14px;
  max-width: 480px;
  /* visibility: hidden; */
  display:none;
  opacity: 0;
  transform: translateY(-20px);
  transition: all 0.7s ease;
}

.dmgstack-tips.visible {
  display: block;
  opacity: 1;
  transform: translateY(0);
}

.dmgstack-tips strong {
  color: #dcddde;
  font-weight: bolder;
}

.dmgstack-tooltip {
  border: none;
  background: transparent;
  padding: 0;
  margin: 0;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
}
.dmgstack-tooltip,
.dmgstack-tooltip:focus,
.dmgstack-tooltip:active {
  outline: none;
  border: none;
  box-shadow: none;
  background: transparent;
}

.dmgstack-tooltip:focus-visible {
  outline: none;
}
.dmgstack-tooltip svg {
  width: 16px;
  height: 16px;
  pointer-events: none;
  fill: #b9bbbe;
  transition: fill 0.2s ease;
}

.dmgstack-tooltip:hover svg {
  fill: #5865f2;
}

@media (max-width: 768px) {
  .dmgstack-tips {
    max-width: 280px;
    font-size: 11px;
    padding: 8px 12px;
  }
  

}

@keyframes pulseFlashAnim {
    0% {
        opacity: 0;
        transform: scale(0.8);
    }
    25% {
        opacity: 0.6;
        transform: scale(1.2);
    }
    50% {
        opacity: 0.8;
        transform: scale(1.4);
    }
    75% {
        opacity: 0.4;
        transform: scale(1.6);
    }
    100% {
        opacity: 0;
        transform: scale(1.8);
    }
}

@keyframes lightningFlicker {
    0% {
        filter: brightness(1);
    }
    15% {
        filter: brightness(1.8) contrast(1.3);
    }
    18% {
        filter: brightness(0.9) contrast(1);
    }
    22% {
        filter: brightness(2.2) contrast(1.5);
    }
    25% {
        filter: brightness(1.1) contrast(1);
    }
    35% {
        filter: brightness(1.6) contrast(1.2);
    }
    40% {
        filter: brightness(1) contrast(1);
    }
    50% {
        filter: brightness(1.9) contrast(1.4);
    }
    55% {
        filter: brightness(1.2) contrast(1);
    }
    65% {
        filter: brightness(1.5) contrast(1.1);
    }
    75% {
        filter: brightness(1) contrast(1);
    }
    85% {
        filter: brightness(1.3) contrast(1.1);
    }
    100% {
        filter: brightness(1) contrast(1);
    }
}

@keyframes lightningAnim {
    0% {
        opacity: 0;
        transform: scale(0.8);
    }
    30% {
        opacity: 1;
        transform: scale(1.3);
    }
    70% {
        opacity: 0.8;
        transform: scale(1.5);
    }
    100% {
        opacity: 0;
        transform: scale(1.8);
    }
}

</style>
<script>
  (function() {
    if (typeof window.safeGet !== 'function') {
      window.safeGet = function(obj, path) {
        if (!path) return undefined;
        try {
          return path.split('.').reduce(function(acc, key) {
            return (acc && acc[key] !== undefined) ? acc[key] : undefined;
          }, obj);
        } catch (e) { 
          return undefined;
        }
      };
    }
    document.addEventListener("DOMContentLoaded", function() {
      const container = document.getElementById("altsim");
      if (!container) return;
      
      let lastTouchTime = 0;
      container.addEventListener("touchstart", function() {
        lastTouchTime = Date.now();
      }, true);
      
      container.addEventListener("click", function(e) {
        if (Date.now() - lastTouchTime < 300) {
          const target = e.target;
          const id = target && target.id;
          const cls = target && target.className && target.className.toString();
          const tag = target && target.tagName && target.tagName.toLowerCase();
          
          const isSummaryOrInside = (function(n) {
            while (n) {
              if (n.tagName && n.tagName.toLowerCase() === "summary") return true;
              n = n.parentNode;
            }
            return false;
          })(target);
          
          const allowedTags = ["input", "select", "option", "button", "a", "summary"];
          const isAllowed =
            id === "closeLog" ||
            (cls && cls.indexOf("sticky") !== -1) ||
            allowedTags.indexOf(tag) !== -1 || 
            isSummaryOrInside;
          
          if (!isAllowed) {
            e.stopImmediatePropagation();
            e.preventDefault();
          }
        }
      }, true);
    });
    (function() {
      const reposition = function() {
        const sb = document.querySelector('.snackbar.show');
        if (sb) {
          if (!sb.hasAttribute('data-compat-bottom')) {
            const cur = sb.style.bottom;
            if (cur) sb.setAttribute('data-compat-bottom', cur);
          }
          sb.style.bottom = sb.getAttribute('data-compat-bottom') || '20px';
        }
      };
      window.addEventListener('resize', reposition, false);
    })();
  })();
</script>

<!-- end compat-shim -->

</head>
 <body>
<div class="container" id="altsim">
<div id="version">
  <p><a href="https://discord.gg/9j2WnTAnMu" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="evenodd" clip-rule="evenodd" viewBox="0 0 512 512"><path fill="#5865F2" d="M105 0h302c57.928.155 104.845 47.072 105 104.996V407c-.155 57.926-47.072 104.844-104.996 104.998L105 512C47.074 511.844.156 464.926.002 407.003L0 105C.156 47.072 47.074.155 104.997 0H105z"/><g data-name=""><g data-name="Discord Logos"><path fill="#fff" fill-rule="nonzero" d="M368.896 153.381a269.506 269.506 0 00-67.118-20.637 186.88 186.88 0 00-8.57 17.475 250.337 250.337 0 00-37.247-2.8c-12.447 0-24.955.946-37.25 2.776-2.511-5.927-5.427-11.804-8.592-17.454a271.73 271.73 0 00-67.133 20.681c-42.479 62.841-53.991 124.112-48.235 184.513a270.622 270.622 0 0082.308 41.312c6.637-8.959 12.582-18.497 17.63-28.423a173.808 173.808 0 01-27.772-13.253c2.328-1.688 4.605-3.427 6.805-5.117 25.726 12.083 53.836 18.385 82.277 18.385 28.442 0 56.551-6.302 82.279-18.387 2.226 1.817 4.503 3.557 6.805 5.117a175.002 175.002 0 01-27.823 13.289 197.847 197.847 0 0017.631 28.4 269.513 269.513 0 0082.363-41.305l-.007.007c6.754-70.045-11.538-130.753-48.351-184.579zM201.968 300.789c-16.04 0-29.292-14.557-29.292-32.465s12.791-32.592 29.241-32.592 29.599 14.684 29.318 32.592c-.282 17.908-12.919 32.465-29.267 32.465zm108.062 0c-16.066 0-29.267-14.557-29.267-32.465s12.791-32.592 29.267-32.592c16.475 0 29.522 14.684 29.241 32.592-.281 17.908-12.894 32.465-29.241 32.465z" data-name="Discord Logo - Large - White"/></g></g></svg>Ragnarok X University</a></p>
  <p><i>v1.1.0</i> [<button id="openLog" type="button">Changelog</button>]</p>

</div>
<details id="howto">
  <summary>
    <span>How to Use</span>
  </summary>
  <div class="body">
<ol>
  <li>
    <strong>Dropdowns</strong>
    <ul>
      <li>Set <strong>Attack Type</strong>, <strong>Weapon</strong>, and <strong>Weapon Attribute</strong>.</li>
      <li>
        For <strong>MVP/MINI</strong>:
        <ul>
          <li>
            Selecting a specific MVP/Mini will auto <strong>sync and lock</strong> its <strong>size, race, and attribute</strong>.
            <em>(Example: <strong>Phreeoni = Large / Brute / Neutral</strong>. The fields stay fixed and you’ll need to fill the related numbers.)</em>
            <ul>
              <li>
                If you only have a <strong>Race enchant (or only Attribute)</strong>, just set the other field to <code>0</code>.
                <ul>
                  <li>Example: <strong>Brute 0 / Neutral 20</strong></li>
                  <li>Example: <strong>Brute 30 / Neutral 0</strong></li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Selecting an <strong>Average Lv.</strong> can skip or set target race/attribute manually.</li>
          <li><em>If you don’t have race and/or attribute enchants, better go with <strong>Average Lv. Boss</strong> and skip those.</em></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    Equipment
    <ul>
      <li>Choose the set you’re using <strong>(Vesper / Blue / White)</strong>.</li>
    </ul>
  </li>
  <li>
    <strong>Stat Inputs</strong>
    <ul>
      <li>Enter your stats exactly as shown in game.</li>
      <li>
        Extra: <strong>Final DMG Bonus %</strong>
        <ul>
          <li>
            <strong><s>F. P/M DMG BONUS</s></strong>
            <ul>
              <li>Shown in <strong>detailed stats</strong> as <strong>Final Damage Stack / Final Damage Bonus</strong>. Make sure <strong>no buffs</strong> are on. If you don’t see it, set <strong>0</strong>.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Only <strong>numbers</strong>, don’t type <strong><s>“%”</s></strong>.</li>
      <li><strong>Decimals</strong> are fine. <em>(Example: <strong>888.88</strong>)</em></li>
    </ul>
  </li>
  <li>
    <strong>Calculate</strong>
    <ul>
      <li>Once everything is filled, hit <strong>Calculate</strong>.</li>
    </ul>
  </li>
  <li>
    <strong>Results</strong>
    <ul>
      <li>You’ll see <strong>base multiplier</strong> and a breakdown of your stats.</li>
    </ul>
  </li>
  <li>
    Simulate Flash
    <ul>
      <li>
        <strong>Spear of Eternity</strong> and <strong>Reaper Scythe</strong>.
        <ul>
          <li><em>Each has 10s duration / 20s cooldown with <strong>+84% or +28%</strong> bonus. This tool normalize <strong>to 42</strong> and <strong>14</strong> for <strong>100% uptime</strong>(?)</em></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <strong>Swap Target</strong>
    <ul>
      <li>Lets you <strong>switch bosses</strong> without starting over.</li>
      <li>If the new boss has <strong>different size/race/element</strong>, the inputs unlock and you’ll need to <strong>re-input stats</strong>.</li>
      <li>
        If it’s the
        <strong>
          same type</strong>, the calc <strong>updates instantly</strong>.
      </li>
      <li>
        <em>Examples:</em>
        <ul>
          <li><strong>Phreeoni 140 → Deviling 150</strong> → re-enter <strong>Medium / Demon / Shadow</strong>.</li>
          <li><strong>Phreeoni 140 → Phreeoni 150</strong> → auto updates, no changes.</li>
          <li><strong>Phreeoni 150 → Avg. 140</strong> → race/element are <strong>cleared</strong>, treated as average <strong>Large Boss Lv.140</strong>.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <strong>Recommendations</strong>
    <ul>
      <li>At the bottom you’ll see a table with recommended <strong><s>ratios</s></strong> stat allocations.</li>
      <li>Hit <strong>Refresh</strong> to roll new sets until you see one you can actually use.</li>
    </ul>
  </li>
</ol>
  </div>
</details>
  <div class="form-row">
    <div class="form-group">
      <label for="penCritSelect" id="atkTypeLabel">Attack Type</label>
      <div class="input-wrap select-wrap">
        <select id="penCritSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="weaponSelect" id="weaponLabel">Weapon Type</label>
      <div class="input-wrap select-wrap">
        <select id="weaponSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="weaponElementSelect" id="wElemLabel">Weapon Attribute</label>
      <div class="input-wrap select-wrap">
        <select id="weaponElementSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="targetDefSelect" id="tDefLabel">MVP/MINI</label>
      <div class="input-wrap select-wrap">
        <select id="targetDefSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="targetSizeSelect" id="tSizeLabel">Target Size</label>
      <div class="input-wrap select-wrap">
        <select id="targetSizeSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="targetRaceSelect" id="tRaceLabel">Target Race</label>
      <div class="input-wrap select-wrap">
        <select id="targetRaceSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="targetElementSelect" id="tAttrLabel">Target Attribute</label>
      <div class="input-wrap select-wrap">
        <select id="targetElementSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="vesperSet" id="vesperSetLabel">Vesper Set</label>
      <div class="input-wrap select-wrap">
        <select id="vesperSet"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="blueSet" id="blueSetLabel">Blue Set</label>
      <div class="input-wrap select-wrap">
        <select id="blueSet"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="whiteSet" id="whiteSetLabel">White Set (110*3)</label>
      <div class="input-wrap select-wrap">
        <select id="whiteSet"></select>
      </div>
    </div>
  </div>

  <div class="form-row">
    <div class="form-group pen-group">
      <label for="pen" id="penLabel">Final P M PEN %</label>
      <div class="input-wrap">
        <input id="pen" type="number" min="1" max="3333" disabled placeholder="total converted raw pen + fpen..." />
      </div>
    </div>
    <div class="form-group crit-group">
      <label for="crit" id="critLabel">Critical DMG Bonus %</label>
      <div class="input-wrap">
        <input id="crit" type="number" min="1" max="3333" disabled placeholder="crit dmg bns..." />
      </div>
    </div>
    <div class="form-group">
      <label for="dmg" id="dmgLabel">Final P M DMG Bonus %</label>
      <div class="input-wrap">
        <input id="dmg" type="number" min="1" max="2222" placeholder="input f. p/m dmg bns..." />
      </div>
    </div>
    <div class="form-group">
      <label for="elemEnhance" id="elemEnhLabel">Element Enhance %</label>
      <div class="input-wrap">
        <input id="elemEnhance" type="number" min="1" max="2222"/>
      </div>
    </div>
    <div class="form-group">
      <label for="sizeEnhance" id="sizeLabel">DMG to Size %</label>
      <div class="input-wrap">
        <input id="sizeEnhance" type="number" min="1" max="2222"/>
      </div>
    </div>
    <div class="form-group">
      <label for="race" id="raceLabel">DMG to Race %</label>
      <div class="input-wrap">
        <input id="race" type="number" min="0" max="888" disabled />
      </div>
    </div>
    <div class="form-group">
      <label for="attr" id="attrLabel">DMG to Attribute %</label>
      <div class="input-wrap">
        <input id="attr" type="number" min="0" max="888" disabled />
      </div>
    </div>
    <div class="form-group">
      <label for="dmgStack" id="dmgStackLabel">Extra: Final DMG Bonus % <button type="button" id="dmgStackTips" class="dmgstack-tooltip"><svg xmlns="http://www.w3.org/2000/svg" height="70" fill="#dcddde" viewBox="0 -960 960 960" width="70"><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg></button></label>
      <div class="input-wrap">
        <input id="dmgStack" type="number" min="0" max="888" placeholder="input final dmg bonus..." />
      </div>
    </div>

  </div>

  <div class="btn-row">
    <button id="submitBtn" type="button">Calculate</button>
    <button id="testSpear" type="button" disabled>Simulate Spear</button>
    <button id="testReaper" type="button" disabled>Simulate Reaper</button>
    <button class="reset-recommendations reset-rek-btn" id="resetRekomenBtn" type="button" disabled>Refresh Recommendations</button>
    <button id="resetAllBtn" type="button" disabled>Reset All</button>
  </div>

  <div id="hasil">
    Input stats to see the result...</div>

  <div id="recommendations">
    Recommended stat allocations will show up here. This tool randomizes your stats to find the best combination for higher output.
  </div>
  <div class="footer"><i>Have an issue?</i><br/>
  Silja [Odin-Nastia] <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="evenodd" clip-rule="evenodd" viewBox="0 0 512 512"><path fill="#5865F2" d="M105 0h302c57.928.155 104.845 47.072 105 104.996V407c-.155 57.926-47.072 104.844-104.996 104.998L105 512C47.074 511.844.156 464.926.002 407.003L0 105C.156 47.072 47.074.155 104.997 0H105z"/><g data-name=""><g data-name="Discord Logos"><path fill="#fff" fill-rule="nonzero" d="M368.896 153.381a269.506 269.506 0 00-67.118-20.637 186.88 186.88 0 00-8.57 17.475 250.337 250.337 0 00-37.247-2.8c-12.447 0-24.955.946-37.25 2.776-2.511-5.927-5.427-11.804-8.592-17.454a271.73 271.73 0 00-67.133 20.681c-42.479 62.841-53.991 124.112-48.235 184.513a270.622 270.622 0 0082.308 41.312c6.637-8.959 12.582-18.497 17.63-28.423a173.808 173.808 0 01-27.772-13.253c2.328-1.688 4.605-3.427 6.805-5.117 25.726 12.083 53.836 18.385 82.277 18.385 28.442 0 56.551-6.302 82.279-18.387 2.226 1.817 4.503 3.557 6.805 5.117a175.002 175.002 0 01-27.823 13.289 197.847 197.847 0 0017.631 28.4 269.513 269.513 0 0082.363-41.305l-.007.007c6.754-70.045-11.538-130.753-48.351-184.579zM201.968 300.789c-16.04 0-29.292-14.557-29.292-32.465s12.791-32.592 29.241-32.592 29.599 14.684 29.318 32.592c-.282 17.908-12.919 32.465-29.267 32.465zm108.062 0c-16.066 0-29.267-14.557-29.267-32.465s12.791-32.592 29.267-32.592c16.475 0 29.522 14.684 29.241 32.592-.281 17.908-12.894 32.465-29.241 32.465z" data-name="Discord Logo - Large - White"/></g></g></svg>sanditama#7047</div>
</div>

<div class="log" id="log">
  <div class="changelog">
    <div class="header-log"><span class="close" id="closeLog">&times;</span>
    <h2>Changelog</h2>
    </div>
    <div class="version">
  <h3>[Unreleased]</h3>
  <ul>
    <li>MINIGAME!</li>
  </ul>
</div>
<div class="version">
  <h3>[v1.1.0] - Sept 18, 2025</h3>
  <ul>
    <li><span class="sub-cats">Added</span>
      <ul>
        <li>Welcome dark theme</li>
        <li>Equipment SET
          <ul>
            <li>Vesper</li>
            <li>Blue</li>
            <li>White 110</li>
          </ul>
        </li>
        <li>Simulate "Interactive" Divinity Flash
          <ul>
            <li>Spear of Eternity</li>
            <li>Reaper Scythe</li>
          </ul>
        </li>
        <li>Show/hide precise numb</li>
      </ul>
    </li>
    <li><span class="sub-cats">Updated</span>
      <ul>
        <li>Calculation Formula</li>
      </ul>
    </li>
    <li><span class="sub-cats">Improved</span>
      <ul>
        <li>UI/UX
          <ul>
            <li>Input validation tips</li>
            <li>each button has its own feedback</li>

          </ul>
        </li>
        <li>Balancing recommendations
          <ul>
            <li></li>
            <li></li>
          </ul>
        </li>
        <li></li>
        <li>Swap Boss
          <ul>
            <li>stats editable after swap</li>
            <li>can skip race / attr field (set to 0)</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div class="version">
  <h3>[v1.0.9] - Sept 11, 2025</h3>
  <ul>
    <li><span class="sub-cats">Added</span>
      <ul>
        <li>All MVP/MINI Lv. 140 & Lv. 150 includes
          <ul>
            <li>DEF stats</li>
            <li>Size</li>
            <li>Race</li>
            <li>and Attribute</li>
          </ul>
        </li>
      </ul>
    </li>
    <li><span class="sub-cats">Updated</span>
      <ul>
        <li>"How to Use" section</li>
      </ul>
    </li>
    <li><span class="sub-cats">Improved</span>
      <ul>
        <li>Results
          <ul>
            <li>more precise stats calc</li>
            <li>show/hide precise nums</li>
          </ul>
        </li>
        <li>Balancing recommendations
          <ul>
            <li>better logic for race and/or attr</li>
            <li>extra cats when race & attr too low</li>
          </ul>
        </li>
        <li>Sticky "smooth" button</li>
        <li>Swap Boss
          <ul>
            <li>stats editable after swap</li>
            <li>can skip race / attr field (set to 0)</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>
<div class="version">
  <h3>[v1.0.8] - Aug 31, 2025</h3>
  <ul>
    <li><span class="sub-cats">Added</span>
      <ul>
        <li>Changelog</li>
        <li>"How to Use" section at top of page</li>
        <li>Target DEF dropdown (used in calc)
          <ul>
            <li>Dummy (0 DEF)</li>
            <li>Avg. MVP/MINI Lv. 130</li>
            <li>Avg. MVP/MINI Lv. 140</li>
            <li>Avg. MVP/MINI Lv. 150</li>
          </ul>
        </li>
        <li>Swap target DEF</li>
        <li>Double tap/click guard</li>
        <li>Sticky collapsible button on scroll (mobile)</li>
      </ul>
    </li>
    
    <li><span class="sub-cats">Updated</span>
      <ul>
        <li>Calc formula
          <ul>
            <li>added counter DEF</li>
          </ul>
        </li>
      </ul>
    </li>
    
    <li><span class="sub-cats">Improved</span>
      <ul>
        <li>cross-browser support</li>
        <li>main flow + logic</li>
        <li>input validation</li>
        <li>results breakdown by factor</li>
        <li>recommendation table logic</li>
      </ul>
    </li>
  </ul>
</div>
<div class="version">
  <h3>[v1.0.0] - Aug 28, 2025</h3>
  <ul>
    <li>Initial release
      <ul>
        <li>6 dropdowns + 6 numeric inputs</li>
        <li>3 buttons</li>
        <li>Result card</li>
        <li>randomize stats in rec table</li>
      </ul>
    </li>
  </ul>
</div>
  </div>
</div>
<div aria-live="polite" class="snackbar" id="snackbar" role="status">
  </div>
<script>
// ========== DATA CONSTANTS ==========
const ELEMENT_COUNTER_TABLE = {
  Neutral:{Neutral:1,Fire:1,Water:1,Earth:1,Wind:1,Poison:1,Holy:1,Shadow:1,Ghost:0.70,Undead:1},
  Fire:{Neutral:1,Fire:0.25,Water:1,Earth:1.25,Wind:1,Poison:1,Holy:0.75,Shadow:1,Ghost:1,Undead:1.125},
  Water:{Neutral:1,Fire:1.25,Water:0.25,Earth:1,Wind:0.90,Poison:1,Holy:0.75,Shadow:1,Ghost:1,Undead:1},
  Earth:{Neutral:1,Fire:0.90,Water:1,Earth:0.25,Wind:1.25,Poison:1,Holy:0.75,Shadow:1,Ghost:1,Undead:1},
  Wind:{Neutral:1,Fire:1,Water:1.375,Earth:0.90,Wind:0.25,Poison:1,Holy:0.70,Shadow:1,Ghost:1,Undead:1},
  Poison:{Neutral:1,Fire:1.125,Water:1,Earth:1.125,Wind:1.125,Poison:0,Holy:0.75,Shadow:0.50,Ghost:1,Undead:-0.25},
  Holy:{Neutral:1,Fire:1,Water:1,Earth:1,Wind:1,Poison:1,Holy:0,Shadow:1.375,Ghost:1,Undead:1.375},
  Shadow:{Neutral:1.125,Fire:1,Water:1,Earth:1,Wind:1,Poison:0.50,Holy:1.375,Shadow:0,Ghost:1,Undead:-0.25},
  Ghost:{Neutral:0.90,Fire:1,Water:1,Earth:1,Wind:1,Poison:1,Holy:0.75,Shadow:0.75,Ghost:1.375,Undead:1},
  Undead:{Neutral:1,Fire:1,Water:1,Earth:1,Wind:1,Poison:0.50,Holy:1.375,Shadow:0,Ghost:1.25,Undead:0}
};
const WEAPON_SIZE_MODIFIER_TABLE = {
  "Empty Handed":{Large:0.5,Medium:0.5,Small:0.5},
  "One-Handed Sword":{Large:0.75,Medium:1,Small:0.75},
  "Two-Handed Sword":{Large:1,Medium:0.75,Small:0.75},
  "Two-Handed Spear":{Large:1,Medium:0.75,Small:0.75},
  "Dagger":{Large:0.75,Medium:0.75,Small:1},
  "Katar":{Large:0.75,Medium:1,Small:0.75},
  "Light Knuckle":{Large:0.75,Medium:0.75,Small:1},
  "Heavy Knuckle":{Large:1,Medium:0.75,Small:0.75},
  "GS":{Large:1,Medium:1,Small:1},
  "Ninja Sword":{Large:1,Medium:0.75,Small:0.75},
  "Huuma Shuriken":{Large:1,Medium:1,Small:1},
  "Tome":{Large:0.75,Medium:1,Small:1},
  "Book":{Large:1,Medium:1,Small:1},
  "Two-Handed Rod":{Large:1,Medium:1,Small:1},
  "One-Handed Rod":{Large:1,Medium:1,Small:1},
  "Mace":{Large:1,Medium:0.75,Small:0.75},
  "One-Handed Axe":{Large:0.75,Medium:0.75,Small:0.75},
  "Two-Handed Axe":{Large:0.5,Medium:0.75,Small:0.75},
  "Bow":{Large:0.75,Medium:1,Small:1},
  "Instrument":{Large:0.75,Medium:1,Small:0.75},
  "Whip":{Large:0.75,Medium:1,Small:0.75}
};
// def stats from Nila 
const DEFENSE_TABLE = {
  "0def": { def: 0, dmgred: 0 },
  "130boss": { def: 194.36, dmgred:156.81 },
  "140boss": { def: 158.37, dmgred: 212.41 },
  "150boss": { def: 194.77, dmgred: 304.07},
  "Phreeoni Lv.140": { def: 106.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Brute", attributeMob: "Neutral" },
  "Mistress Lv.140": { def: 130.18, dmgred: 272.80, sizeMob: "Small", raceMob: "Insect", attributeMob: "Wind" },
  "Eddga Lv.140": { def: 106.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Brute", attributeMob: "Fire" },
  "Kraken Lv.140": { def: 130.18, dmgred: 272.80, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Maya Lv.140": { def: 98.97, dmgred: 136.40, sizeMob: "Large", raceMob: "Insect", attributeMob: "Earth" },
  "Orc Hero Lv.140": { def: 82.47, dmgred: 136.40, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Pharaoh Lv.140": { def: 98.97, dmgred: 136.40, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Shadow" },
  "Orc Lord Lv.140": { def: 82.47, dmgred: 136.40, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Doppelganger Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Amon Ra Lv.140": { def: 106.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Morroc Lv.140": { def: 131.97, dmgred: 136.40, sizeMob: "Large", raceMob: "Demon", attributeMob: "Shadow" },
  "Time Holder Lv.140": { def: 164.97, dmgred: 136.40, sizeMob: "Large", raceMob: "Demon", attributeMob: "Neutral" },
  "Tao Gunka Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Demon", attributeMob: "Neutral" },
  "Lost Dragon Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Shadow" },
  "Fallen Bishop Lv.140": { def: 164.97, dmgred: 136.40, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Lord of the Dead Lv.140": { def: 131.97, dmgred: 136.40, sizeMob: "Large", raceMob: "Demon", attributeMob: "Shadow" },
  "Arc Angeling Lv.140": { def: 164.97, dmgred: 136.40, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" },
  "Gioia Lv.140": { def: 212.68, dmgred: 272.80, sizeMob: "Large", raceMob: "Formless", attributeMob: "Wind" },
  "RSX-0806 Lv.140": { def: 238.66, dmgred: 202.00, sizeMob: "Medium", raceMob: "Formless", attributeMob: "Neutral" },
  "Nidhoggr's Shadow Lv.140": { def: 181.21, dmgred: 134.00, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Shadow" },
  "Gloom Under Night Lv.140": { def: 306.00, dmgred: 300.00, sizeMob: "Large", raceMob: "Formless", attributeMob: "Ghost" },
  "Retribution Lv.140": { def: 256.50, dmgred: 300.00, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Shadow" },
  "Dragon Fly Lv.140": { def: 106.98, dmgred: 204.60, sizeMob: "Small", raceMob: "Insect", attributeMob: "Wind" },
  "Eclipse Lv.140": { def: 130.18, dmgred: 272.80, sizeMob: "Small", raceMob: "Brute", attributeMob: "Neutral" },
  "Mastering Lv.140": { def: 130.18, dmgred: 272.80, sizeMob: "Medium", raceMob: "Plant", attributeMob: "Water" },
  "Ghostring Lv.140": { def: 106.98, dmgred: 204.60, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Ghost" },
  "Toad Lv.140": { def: 98.97, dmgred: 136.40, sizeMob: "Small", raceMob: "Fish", attributeMob: "Water" },
  "King Dramoh Lv.140": { def: 82.47, dmgred: 136.40, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Angeling Lv.140": { def: 98.97, dmgred: 136.40, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" },
  "Deviling Lv.140": { def: 82.47, dmgred: 136.40, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Dark Priest Lv.140": { def: 212.68, dmgred: 272.80, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Undead" },
  "Vagabond Wolf Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Medium", raceMob: "Brute", attributeMob: "Earth" },
  "Chimera Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Brute", attributeMob: "Fire" },
  "Mysteltainn Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Formless", attributeMob: "Shadow" },
  "Ogretooth Lv.140": { def: 212.68, dmgred: 306.35, sizeMob: "Medium", raceMob: "Formless", attributeMob: "Shadow" },
  "Necromancer Lv.140": { def: 131.97, dmgred: 150.75, sizeMob: "Medium", raceMob: "Undead", attributeMob: "Undead" },
  "Coelacanth Lv.140": { def: 139.98, dmgred: 204.60, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Naght Sieger Lv.140": { def: 212.68, dmgred: 272.80, sizeMob: "Large", raceMob: "Demon", attributeMob: "Ghost" },
  "Observation Lv.140": { def: 146.68, dmgred: 272.80, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Neutral" },
  "Skeggiold Lv.140": { def: 172.98, dmgred: 204.60, sizeMob: "Small", raceMob: "Angel", attributeMob: "Holy" },
  "Queen Scaraba Lv.140": { def: 212.30, dmgred: 268.70, sizeMob: "Small", raceMob: "Insect", attributeMob: "Earth" },
  "Faceworm Queen Lv.140": { def: 245.30, dmgred: 268.70, sizeMob: "Small", raceMob: "Insect", attributeMob: "Poison" },
  "Ktullanux Lv.140": { def: 256.50, dmgred: 542.27, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Water" },
  "Shelter Lv.140": { def: 251.18, dmgred: 258.00, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" },
  "Phreeoni Lv.150": { def: 136.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Brute", attributeMob: "Neutral" },
  "Mistress Lv.150": { def: 161.98, dmgred: 361.00, sizeMob: "Small", raceMob: "Insect", attributeMob: "Wind" },
  "Eddga Lv.150": { def: 136.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Brute", attributeMob: "Fire" },
  "Kraken Lv.150": { def: 161.98, dmgred: 361.00, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Maya Lv.150": { def: 118.76, dmgred: 186.70, sizeMob: "Large", raceMob: "Insect", attributeMob: "Earth" },
  "Orc Hero Lv.150": { def: 110.67, dmgred: 261.40, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Pharaoh Lv.150": { def: 118.76, dmgred: 186.70, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Shadow" },
  "Orc Lord Lv.150": { def: 110.67, dmgred: 261.40, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Doppelganger Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Amon Ra Lv.150": { def: 136.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Demi-Human", attributeMob: "Earth" },
  "Morroc Lv.150": { def: 169.17, dmgred: 261.40, sizeMob: "Large", raceMob: "Demon", attributeMob: "Shadow" },
  "Time Holder Lv.150": { def: 196.76, dmgred: 186.70, sizeMob: "Large", raceMob: "Demon", attributeMob: "Neutral" },
  "Tao Gunka Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Demon", attributeMob: "Neutral" },
  "Lost Dragon Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Shadow" },
  "Fallen Bishop Lv.150": { def: 196.76, dmgred: 186.70, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Lord of the Dead Lv.150": { def: 169.17, dmgred: 261.40, sizeMob: "Large", raceMob: "Demon", attributeMob: "Shadow" },
  "Arc Angeling Lv.150": { def: 196.76, dmgred: 186.70, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" },
  "Gioia Lv.150": { def: 259.48, dmgred: 361.00, sizeMob: "Large", raceMob: "Formless", attributeMob: "Wind" },
  "RSX-0806 Lv.150": { def: 293.16, dmgred: 317.00, sizeMob: "Medium", raceMob: "Formless", attributeMob: "Neutral" },
  "Nidhoggr's Shadow Lv.150": { def: 228.13, dmgred: 266.00, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Shadow" },
  "Gloom Under Night Lv.150": { def: 357.57, dmgred: 367.00, sizeMob: "Large", raceMob: "Formless", attributeMob: "Ghost" },
  "Retribution Lv.150": { def: 299.07, dmgred: 367.00, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Shadow" },
  "Dragon Fly Lv.150": { def: 136.62, dmgred: 311.20, sizeMob: "Small", raceMob: "Insect", attributeMob: "Wind" },
  "Eclipse Lv.150": { def: 161.98, dmgred: 361.00, sizeMob: "Small", raceMob: "Brute", attributeMob: "Neutral" },
  "Mastering Lv.150": { def: 161.98, dmgred: 361.00, sizeMob: "Medium", raceMob: "Plant", attributeMob: "Water" },
  "Ghostring Lv.150": { def: 136.62, dmgred: 311.20, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Ghost" },
  "Toad Lv.150": { def: 118.76, dmgred: 186.70, sizeMob: "Small", raceMob: "Fish", attributeMob: "Water" },
  "King Dramoh Lv.150": { def: 110.67, dmgred: 261.40, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Angeling Lv.150": { def: 118.76, dmgred: 186.70, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" },
  "Deviling Lv.150": { def: 110.66, dmgred: 261.40, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Shadow" },
  "Dark Priest Lv.150": { def: 259.48, dmgred: 361.00, sizeMob: "Medium", raceMob: "Demon", attributeMob: "Undead" },
  "Vagabond Wolf Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Medium", raceMob: "Brute", attributeMob: "Earth" },
  "Chimera Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Brute", attributeMob: "Fire" },
  "Mysteltainn Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Formless", attributeMob: "Shadow" },
  "Ogretooth Lv.150": { def: 259.48, dmgred: 385.89, sizeMob: "Medium", raceMob: "Formless", attributeMob: "Shadow" },
  "Necromancer Lv.150": { def: 169.17, dmgred: 272.00, sizeMob: "Medium", raceMob: "Undead", attributeMob: "Undead" },
  "Coelacanth Lv.150": { def: 175.62, dmgred: 311.20, sizeMob: "Large", raceMob: "Fish", attributeMob: "Water" },
  "Naght Sieger Lv.150": { def: 259.48, dmgred: 361.00, sizeMob: "Large", raceMob: "Demon", attributeMob: "Ghost" },
  "Observation Lv.150": { def: 181.48, dmgred: 361.00, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Neutral" },
  "Skeggiold Lv.150": { def: 214.62, dmgred: 311.20, sizeMob: "Small", raceMob: "Angel", attributeMob: "Holy" },
  "Queen Scaraba Lv.150": { def: 258.55, dmgred: 351.40, sizeMob: "Small", raceMob: "Insect", attributeMob: "Earth" },
  "Faceworm Queen Lv.150": { def: 297.55, dmgred: 351.40, sizeMob: "Small", raceMob: "Insect", attributeMob: "Poison" },
  "Ktullanux Lv.150": { def: 299.07, dmgred: 575.77, sizeMob: "Large", raceMob: "Dragon", attributeMob: "Water" },
  "Shelter Lv.150": { def: 293.16, dmgred: 317.00, sizeMob: "Medium", raceMob: "Angel", attributeMob: "Holy" }
};
const RACE_TYPES = ["Angel","Demon","Formless","Insect","Fish","Demi-Human","Undead","Dragon","Plant","Brute"];
const BLUE_SET = {
  3: {
    30: 5,
    40: 7.5,
    50: 10,
    60: 12.5,
    70: 15,
    80: 17.5,
    90: 20,
    100: 22.5,
    110: 25,
    120: 27.5,
    130: 30,
    140: 32.5,
    150: 35
  /*
  },
  8: {
    30: 5,
    40: 10,
    50: 15,
    60: 20,
    70: 25,
    80: 30,
    90: 35,
    100: 40,
    110: 45,
    120: 50,
    130: 55,
    140: 60,
    150: 65
  */
  }
};
const VESPER_SET = {
  0: 8,
  1: 16,
  2: 24,
  3: 32,
  4: 40,
  5: 48,
  6: 56,
  7: 64,
  8: 72,
  9: 80
};
const WHITE_SET = {
  "Tier 0" : 30,
  "Tier 2" : 36,
  "Tier 3" : 42,
  "Tier 4" : 48
}
const RECOMMENDATION_CONFIG = {
  randomMode: 'clamp', 
  maxAttempts: 200,
  centerScale: 0.25, // rand around stats 
  jitter: 0.15, // keep closest 
  jitterStep: 0.08, // scaling jitter
  jitterStepEvery: 40, // every 40 attempt 
  jitterMax: 0.5, // stop scaling now
  clampMaxFraction: 0.6, // more closest to center
  clampMaxAbsolute: 0.3, // and more
  upDownThreshold: 3, // ±3 assume nochange
  raceAttrCap: 420, // race attr total cap = max ea + any
  raceAttrSoloCap: 270, // 3 slot ea10 
  raceAttrTol: 12, // tolerance for cap
  smallThreshold: 140, // if user race and/or attr < 2slot ea8 = small
  smallMin: 90, // new base for user (1slot ea10)
  smallExp: 0.6, 
  ratioMin: 0.2, // min ratio share
  ratioMax: 0.8, // max ratio
  ratioNoise: 0.08, // with noise 
  bias: { // weights share
    main: 1,
    dmg: 0.8,
    elem: 0.8,
    size: 0.8,
    race: 0.8,
    attr: 0.8
  },
  cats: [ // normal cats
    { label: '0-8%', min: 1.00, max: 1.08 },
    { label: '10-20%', min: 1.10, max: 1.20 },
    { label: '20-30%', min: 1.20, max: 1.30 },
    { label: '50-100%', min: 1.50, max: 2.00 }
  ],
  forSmallCats: [ // cats for lack race&attr
    { label: '50-100%', min: 1.50, max: 2.00 },
    { label: '100-200%', min: 2.00, max: 3.00 },
    { label: '200-300%', min: 3.00, max: 4.00 },
    { label: '300-400%', min: 4.00, max: 5.00 }
  ]
};

// ========== DOM ELEMENTS CACHE ==========
const DOM_ELEMENTS = {
  atkType: document.getElementById('penCritSelect'),
  weapon: document.getElementById('weaponSelect'),
  wElem: document.getElementById('weaponElementSelect'),
  tSize: document.getElementById('targetSizeSelect'),
  tRace: document.getElementById('targetRaceSelect'),
  tAttr: document.getElementById('targetElementSelect'),
  tDef: document.getElementById('targetDefSelect'),
  blueSet: document.getElementById("blueSet"),
  vesperSet: document.getElementById("vesperSet"),
  whiteSet: document.getElementById("whiteSet"),
  tDefLabel: document.getElementById('tDefLabel'),
  atkTypeLabel: document.getElementById('atkTypeLabel'),
  weaponLabel: document.getElementById('weaponLabel'),
  wElemLabel: document.getElementById('wElemLabel'),
  tSizeLabel: document.getElementById('tSizeLabel'),
  tRaceLabel: document.getElementById('tRaceLabel'),
  tAttrLabel: document.getElementById('tAttrLabel'),
  pen: document.getElementById('pen'),
  crit: document.getElementById('crit'),
  dmgStack: document.getElementById('dmgStack'),
  dmgStackTips: document.getElementById('dmgStackTips'),
  dmg: document.getElementById('dmg'),
  elemEnh: document.getElementById('elemEnhance'),
  sizeEnh: document.getElementById('sizeEnhance'),
  race: document.getElementById('race'),
  attr: document.getElementById('attr'),
  penLabel: document.getElementById('penLabel'),
  critLabel: document.getElementById('critLabel'),
  dmgLabel: document.getElementById('dmgLabel'),
  elemEnhLabel: document.getElementById('elemEnhLabel'),
  sizeLabel: document.getElementById('sizeLabel'),
  raceLabel: document.getElementById('raceLabel'),
  attrLabel: document.getElementById('attrLabel'),
  hasil: document.getElementById('hasil'),
  rec: document.getElementById('recommendations'),
  submit: document.getElementById('submitBtn'),
  resetRek: document.getElementById('resetRekomenBtn'),
  resetAll: document.getElementById('resetAllBtn'),
  testSpear: document.getElementById('testSpear'),
  testReaper: document.getElementById('testReaper'),
  snackbar: document.getElementById('snackbar'),
  log: document.getElementById("log"),
  openLog: document.getElementById("openLog"),
  closeLog: document.getElementById("closeLog")
};
// ========== UTILITY FUNCTIONS ==========
const isEmpty = (v) => v === null || v === undefined || v === '';
const clearNumericInput = (el) => { if (el) el.value = ''; };
const safeNumber = (v) => Math.max(Number(v) || 0, 0);
const formatNumber = (n, fullPrecision = false) => {
  const num = Number(n);
  return fullPrecision ? num : Math.trunc(num * 100) / 100;
};

// ========== NOTIFICATION SYSTEM ==========
let snackbarTimer = null;
function showSnackbar(text) {
  const sb = DOM_ELEMENTS.snackbar;
  if (!sb) return;
  sb.textContent = text;
  if (snackbarTimer) clearTimeout(snackbarTimer);
  sb.classList.remove('show');
  void sb.offsetWidth;
  sb.classList.add('show');
  snackbarTimer = setTimeout(() => {
    sb.classList.remove('show');
  }, 3000);
}
function scrollAndFocusElement(el, msg) {
  if (msg) showSnackbar(msg);
  const top = el.getBoundingClientRect().top + window.scrollY - 80;
  window.scrollTo({ top, behavior: 'smooth' });
  if (!el.disabled) el.focus({ preventScroll: true });
  return false;
}

// ========== INPUT VALIDATION & NORMALIZATION ==========
const ValidationSSoT = {
  // Constants
  INVALID_CLASS: 'invalid-value',
  
  // Listener Registry - track all attached listeners
  listenerRegistry: new Map(),
  
  // Helper to identify pen & dmg fields
  isPenOrDmgField(element) {
    if (!element || !element.id) return false;
    return element.id === 'pen' || element.id === 'dmg';
  },
  
  // Safe listener management
  attachListener(element, eventType, handler, listenerKey) {
    if (!element || !eventType || !handler || !listenerKey) return;
    
    const elementKey = this.getElementKey(element);
    const fullKey = `${elementKey}_${eventType}_${listenerKey}`;
    
    // Check if this specific listener already exists
    if (this.listenerRegistry.has(fullKey)) {
      return; // Already attached, skip
    }
    
    // Attach listener
    element.addEventListener(eventType, handler);
    
    // Register in registry
    this.listenerRegistry.set(fullKey, {
      element,
      eventType,
      handler,
      listenerKey
    });
  },
  
  // Remove specific listener
  removeListener(element, eventType, listenerKey) {
    if (!element || !eventType || !listenerKey) return;
    
    const elementKey = this.getElementKey(element);
    const fullKey = `${elementKey}_${eventType}_${listenerKey}`;
    
    const listenerInfo = this.listenerRegistry.get(fullKey);
    if (listenerInfo) {
      element.removeEventListener(eventType, listenerInfo.handler);
      this.listenerRegistry.delete(fullKey);
    }
  },
  
  // Remove all listeners for an element
  cleanupElementListeners(element) {
    if (!element) return;
    
    const elementKey = this.getElementKey(element);
    const keysToDelete = [];
    
    for (const [fullKey, listenerInfo] of this.listenerRegistry) {
      if (fullKey.startsWith(elementKey)) {
        element.removeEventListener(listenerInfo.eventType, listenerInfo.handler);
        keysToDelete.push(fullKey);
      }
    }
    
    keysToDelete.forEach(key => this.listenerRegistry.delete(key));
  },
  
  // Get unique element identifier
  getElementKey(element) {
    return element.id || element.className || element.tagName + '_' + Array.from(element.parentNode.children).indexOf(element);
  },

  // ===== HELPER METHODS (NESTED) =====
  helpers: {
    // Pure data fetching - realtime context
    getValidationContext() {
      const thresholds = ValidationSSoT.getCurrentThresholds(); // Always fresh
      const selectedOption = DOM_ELEMENTS.tDef.options[DOM_ELEMENTS.tDef.selectedIndex];
      const targetLabel = selectedOption ? selectedOption.textContent : 'target';
      return { thresholds, targetLabel };
    },
    
    // Pure validation check
    isInvalidNumber(value) {
      return ValidationSSoT.isEmpty(value) || isNaN(Number(value)) || !Number.isFinite(Number(value));
    },
    
    // Pure message generation
    generateRequirementMessage(fieldId, threshold, targetLabel) {
      const minRequired = (threshold + 8).toFixed(2);
      if (fieldId === 'pen') {
        return `Need at least ${minRequired} Final PEN vs ${targetLabel}`;
      } else if (fieldId === 'dmg') {
        return `Need at least ${minRequired} Final P/M BNS vs ${targetLabel}`;
      }
      return;
    },
    
    // Common initialization logic
    performInitialization() {
      // SAFETY CHECK: Only init if not already initialized
      if (!ValidationSSoT.statsValidationState.isReady) {
        ValidationSSoT.initializeStatsValidation();
      }
      
      // Setup threshold update listener - BULLETPROOF SINGLE ATTACHMENT
      if (DOM_ELEMENTS.tDef) {
        const thresholdChangeHandler = () => {
          ValidationSSoT.updateStatsThresholds();
        };
        
        // SAFETY: Clean any existing threshold listeners first
        ValidationSSoT.cleanupElementListeners(DOM_ELEMENTS.tDef);
        ValidationSSoT.attachListener(DOM_ELEMENTS.tDef, 'change', thresholdChangeHandler, 'thresholdUpdate');
      }
    }
  },
  
  // Field Configuration
  getFieldValidationRules() {
    return [
      { el: DOM_ELEMENTS.atkType, label: 'Attack Type' },
      { el: DOM_ELEMENTS.weapon, label: 'Weapon Type' },
      { el: DOM_ELEMENTS.wElem, label: 'Weapon Attribute' },
      { el: DOM_ELEMENTS.tDef, label: 'Target Boss' },
      { el: DOM_ELEMENTS.tSize, label: 'Target Size' },
      { el: DOM_ELEMENTS.tRace, label: 'Target Race', condition: () => !DOM_ELEMENTS.race.disabled },
      { el: DOM_ELEMENTS.tAttr, label: 'Target Attribute', condition: () => !DOM_ELEMENTS.attr.disabled },
      { el: DOM_ELEMENTS.pen, label: 'Final P M PEN %', condition: () => DOM_ELEMENTS.atkType.value === 'pen' },
      { el: DOM_ELEMENTS.crit, label: 'Critical DMG Bonus %', condition: () => DOM_ELEMENTS.atkType.value === 'crit' },
      { el: DOM_ELEMENTS.dmg, label: 'Final P M DMG Bonus %' },
      { el: DOM_ELEMENTS.elemEnh, label: 'Element Enhance %' },
      { el: DOM_ELEMENTS.sizeEnh, label: 'DMG to Size %' },
      { el: DOM_ELEMENTS.race, label: 'DMG to Race %', condition: () => !DOM_ELEMENTS.race.disabled },
      { el: DOM_ELEMENTS.attr, label: 'DMG to Attribute %', condition: () => !DOM_ELEMENTS.attr.disabled },
      { el: DOM_ELEMENTS.dmgStack, label: 'Final DMG Bonus %' }
    ];
  },
  
  // Get current thresholds dynamically (always fresh)
  getCurrentThresholds() {
    try {
      const defData = getTargetDefenseData(DOM_ELEMENTS.tDef.value || '0def');
      return {
        defVal: Number(defData.def || 0),
        dmgredVal: Number(defData.dmgred || 0)
      };
    } catch (err) {
      return { defVal: 0, dmgredVal: 0 };
    }
  },

  // Centralized Class Management - REALTIME ADD/REMOVE
  applyClassState(element, isValid, context = 'default') {
    if (!element) return;
    
    // REALTIME: add invalid class when invalid, remove when valid
    if (isValid) {
      element.classList.remove(this.INVALID_CLASS);
    } else {
      element.classList.add(this.INVALID_CLASS);
    }
    
    // Setup realtime removal only for invalid elements
    if (!isValid) {
      const removeOnValid = () => {
        if (element.value && element.value !== '') {
          element.classList.remove(this.INVALID_CLASS);
        }
      };
      
      this.attachListener(element, "input", removeOnValid, "fieldValidation");
      this.attachListener(element, "change", removeOnValid, "fieldValidation");
    }
  },
  
  // State tracking for readiness
  statsValidationState: {
    isReady: false,
    isStandby: false,
    touchedFields: new Set()
  },

  // Setup stats validation (always ready, not active) - BULLETPROOF NO DOUBLE LISTENERS
  setupStatsValidation(element) {
    if (!element) return;
    
    // SAFETY: Clean existing listeners for this element first
    this.cleanupElementListeners(element);
    
    // ===== REALTIME CLASS MANAGEMENT - ALWAYS ACTIVE =====
    const realtimeClassValidation = () => {
      // Only run if field has been touched and we're not in standby
      if (!this.statsValidationState.touchedFields.has(element.id)) return;
      if (this.statsValidationState.isStandby) return;
      
      const currentValue = Number(element.value) || 0;
      const { thresholds } = this.helpers.getValidationContext(); // REALTIME THRESHOLD - ALWAYS FRESH
      let minRequired, isCurrentlyValid;
      
      switch (element.id) {
        case 'dmg':
          minRequired = thresholds.dmgredVal;
          isCurrentlyValid = currentValue > 0 && (currentValue - minRequired) > 0;
          break;
          
        case 'pen':
          minRequired = thresholds.defVal;
          isCurrentlyValid = currentValue > 0 && (currentValue - minRequired) > 0;
          break;
          
        default:
          return;
      }
      
      // REALTIME CLASS MANAGEMENT - SILENT BUT HELPFUL
      if (isCurrentlyValid) {
        element.classList.remove(this.INVALID_CLASS);
      } else {
        element.classList.add(this.INVALID_CLASS);
      }
    };
    
    // ===== TOUCH DETECTION =====
    const onTouch = () => {
      const wasAlreadyTouched = this.statsValidationState.touchedFields.has(element.id);
      this.statsValidationState.touchedFields.add(element.id);
      this.statsValidationState.isStandby = false; // Exit standby when user touches
      
      realtimeClassValidation(); // Run validation immediately on touch
    };
    
    // ===== DEDICATED BLUR VALIDATION PER FIELD - INDEPENDENT JALUR =====
    let onBlur;
    
    if (element.id === 'pen') {
      // DEDICATED PEN BLUR - INDEPENDENT
      onBlur = () => {
        if (!this.statsValidationState.touchedFields.has('pen')) return;
        if (this.statsValidationState.isStandby) return;
        if (DOM_ELEMENTS.atkType.value.toLowerCase() !== 'pen') return; // Skip if not PEN mode
        
        const penValue = Number(DOM_ELEMENTS.pen.value) || 0;
        const { thresholds, targetLabel } = this.helpers.getValidationContext(); // REALTIME THRESHOLD
        const defVal = thresholds.defVal;
        
        if (this.helpers.isInvalidNumber(DOM_ELEMENTS.pen.value) || penValue <= 0) {
          return;
        }
        
        const isPenValid = penValue > 0 && (penValue - defVal) > 0;
        if (!isPenValid) {
          const message = this.helpers.generateRequirementMessage('pen', defVal, targetLabel);
          showSnackbar(message);
        }
      };
    } else if (element.id === 'dmg') {
      // DEDICATED DMG BLUR - INDEPENDENT
      onBlur = () => {
        if (!this.statsValidationState.touchedFields.has('dmg')) return;
        if (this.statsValidationState.isStandby) return;
        
        const dmgValue = Number(DOM_ELEMENTS.dmg.value) || 0;
        const { thresholds, targetLabel } = this.helpers.getValidationContext(); // REALTIME THRESHOLD
        const dmgredVal = thresholds.dmgredVal;
        
        if (this.helpers.isInvalidNumber(DOM_ELEMENTS.dmg.value) || dmgValue <= 0) {
          return;
        }
        
        const isDmgValid = dmgValue > 0 && (dmgValue - dmgredVal) > 0;
        if (!isDmgValid) {
          const message = this.helpers.generateRequirementMessage('dmg', dmgredVal, targetLabel);
          showSnackbar(message);
        }
      };
    }
    
    // ===== ATTACH LISTENERS WITH UNIQUE KEYS - BULLETPROOF =====
    this.attachListener(element, "focus", onTouch, "statsTouch");
    this.attachListener(element, "input", realtimeClassValidation, "statsInput");
    this.attachListener(element, "change", realtimeClassValidation, "statsChange");
    if (onBlur) {
      this.attachListener(element, "blur", onBlur, "statsBlur");
    }
    
    this.statsValidationState.isReady = true;
  },

  // Apply class state (immediate, for manual validation) - REALTIME ADD/REMOVE
  applyStatsClassState(element, isValid) {
    if (!element) return;
    
    // REALTIME: add invalid class when invalid, remove when valid
    if (isValid) {
      element.classList.remove(this.INVALID_CLASS);
    } else {
      element.classList.add(this.INVALID_CLASS);
    }
  },

  // Initialize stats validation (setup ready state)
  initializeStatsValidation() {
    if (DOM_ELEMENTS.pen) {
      this.setupStatsValidation(DOM_ELEMENTS.pen);
    }
    
    if (DOM_ELEMENTS.dmg) {
      this.setupStatsValidation(DOM_ELEMENTS.dmg);
    }
  },

  // Update stats thresholds (enter standby mode) - ENHANCED REALTIME THRESHOLD
  updateStatsThresholds() {
    // Enter standby mode - ready but not actively validating
    this.statsValidationState.isStandby = true;
    
    // Clear all touched states so validation waits for next user interaction
    this.statsValidationState.touchedFields.clear();
    
    // Remove any existing invalid classes until user touches inputs again
    if (DOM_ELEMENTS.pen) {
      DOM_ELEMENTS.pen.classList.remove(this.INVALID_CLASS);
    }
    
    if (DOM_ELEMENTS.dmg) {
      DOM_ELEMENTS.dmg.classList.remove(this.INVALID_CLASS);
    }
    
    // REALTIME THRESHOLD: Check if current stats are invalid with NEW thresholds and show snackbar
    //this.checkStatsAfterThresholdChange();
  },
  
  // Check stats validity after threshold change - REALTIME THRESHOLD FEEDBACK
  checkStatsAfterThresholdChange() {
    const mockState = { atkType: DOM_ELEMENTS.atkType.value };
    const { thresholds, targetLabel } = this.helpers.getValidationContext(); // Use helper
    
    // INDEPENDENT CHECK: PEN field (if applicable)
    if (mockState.atkType.toLowerCase() === 'pen' && DOM_ELEMENTS.pen && !this.isEmpty(DOM_ELEMENTS.pen.value)) {
      const penValue = Number(DOM_ELEMENTS.pen.value) || 0;
      const defVal = thresholds.defVal;
      const isPenValid = penValue > 0 && (penValue - defVal) > 0;
      
      if (!isPenValid) {
        const message = this.helpers.generateRequirementMessage('pen', defVal, targetLabel);
        showSnackbar(message);
      }
    }
    
    // INDEPENDENT CHECK: DMG field (always check)
    if (DOM_ELEMENTS.dmg && !this.isEmpty(DOM_ELEMENTS.dmg.value)) {
      const dmgValue = Number(DOM_ELEMENTS.dmg.value) || 0;
      const dmgredVal = thresholds.dmgredVal;
      const isDmgValid = dmgValue > 0 && (dmgValue - dmgredVal) > 0;
      
      if (!isDmgValid) {
        const message = this.helpers.generateRequirementMessage('dmg', dmgredVal, targetLabel);
        showSnackbar(message);
      }
    }
  },
  
  // Shared Validation Logic
  isEmpty(value) {
    return !value || value.trim() === '';
  },
  
  // Numeric normalization - SIMPLE VERSION
  normalizeNumeric(originalValue) {
  let v = originalValue.trim();
  let hasChanges = false;
  
  const beforeClean = v;
  v = v.replace(/[^\d.,]/g, '');
  if (v !== beforeClean) {
    hasChanges = true;
  }
  
  if (v.includes(',')) {
    v = v.replace(/,/g, '.');
    hasChanges = true;
  }
  
  const dotCount = (v.match(/\./g) || []).length;
  if (dotCount > 1) {
    const dotIndex = v.indexOf('.');
    v = v.slice(0, dotIndex + 1) + v.slice(dotIndex + 1).replace(/\./g, '');
    hasChanges = true;
  }
  
  const beforeZeros = v;
  v = v.replace(/^0+(?=\d)/, '');
  if (v !== beforeZeros) {
    hasChanges = true;
  }
  
  if (v.endsWith('.')) {
    v = v.slice(0, -1);
    hasChanges = true;
  }
  
  if (v.startsWith('.')) {
    const beforeDotFix = v;
    v = v.replace(/^\./, '0.');
    if (v !== beforeDotFix) {
      hasChanges = true;
    }
  }
  
  const validNumberPattern = /^\d*\.?\d*$/;
  if (!validNumberPattern.test(v) && v !== '') {
    v = '';
    hasChanges = true;
  }
  
  return { value: v, hasChanges };
},
  
  // Numeric validation - SIMPLE VERSION
  validateNumericInput(value, element) {
    if (value === '' || isNaN(Number(value)) || !Number.isFinite(Number(value))) {
      this.applyClassState(element, false); // REALTIME ADD INVALID CLASS
      return { isValid: false };
    }
    
    const minVal = Number(element.getAttribute("min")) || 0;
    if (Number(value) < minVal) {
      this.applyClassState(element, false); // REALTIME ADD INVALID CLASS
      return { isValid: false };
    }
    
    const maxAttr = element.getAttribute("max");
    const maxVal = (maxAttr !== null && maxAttr !== '') ? Number(maxAttr) : NaN;
    if (!isNaN(maxVal) && Number(value) > maxVal) {
      this.applyClassState(element, false); // REALTIME ADD INVALID CLASS
      return { isValid: false };
    }
    
    this.applyClassState(element, true); // REALTIME REMOVE INVALID CLASS
    return { isValid: true };
  },
  
  // Enhanced validation with auto-normalization
  validateAndNormalizeInput(element) {
    const originalValue = element.value;
    if (!originalValue) {
      // Apply invalid class for non-PEN/DMG fields - REALTIME
      if (!this.isPenOrDmgField(element)) {
        this.applyClassState(element, false);
      }
      return { isValid: false };
    }
    
    // First normalize the input
    const normalized = this.normalizeNumeric(originalValue);
    
    if (normalized.hasChanges) {
      element.value = normalized.value;
    }
    
    // Then validate the normalized value
    const validationResult = this.validateNumericInput(normalized.value, element);
    
    // Apply class state for non-PEN/DMG fields only - REALTIME
    if (!this.isPenOrDmgField(element)) {
      this.applyClassState(element, validationResult.isValid);
    }
    
    return validationResult;
  },
  
  // Required fields validation
  validateRequiredFieldsWithClasses() {
  const fields = this.getFieldValidationRules();
  
  for (const field of fields) {
    if (!field.el) continue;
    if (field.condition && !field.condition()) continue;
    
    if (this.isEmpty(field.el.value)) {
      // -------------------------------
      // Field kosong = invalid
      // -------------------------------
      if (!this.isPenOrDmgField(field.el)) {
        // Untuk field biasa → update class
        this.applyClassState(field.el, false, 'validation');
      }
      // Untuk pen/dmg → tetap return invalid,
      // supaya scrollAndFocus tetap bisa bekerja,
      // tapi tanpa update class
      return { isValid: false, field, skipClass: this.isPenOrDmgField(field.el) };
      
    } else {
      // -------------------------------
      // Field berisi = valid
      // -------------------------------
      if (!this.isPenOrDmgField(field.el)) {
        // Untuk field biasa → update class
        this.applyClassState(field.el, true, 'validation');
      }
      // Untuk pen/dmg → dibiarkan, class dikelola lewat validasi stats
    }
  }
  
  return { isValid: true, field: null, skipClass: false };
},
  
  // Enhanced Stats validation - INDEPENDENT PEN & DMG VALIDATION
  validateStatsWithClasses(state, focusedElement = null) {
    try {
      const { thresholds, targetLabel } = this.helpers.getValidationContext(); // Use helper
      const defVal = thresholds.defVal;
      const dmgredVal = thresholds.dmgredVal;
      
      let penValidationResult = { isValid: true, element: null };
      let dmgValidationResult = { isValid: true, element: null };
      
      // ===== INDEPENDENT PEN VALIDATION =====
      if (state.atkType.toLowerCase() === 'pen' && DOM_ELEMENTS.pen) {
        const penVal = Number(DOM_ELEMENTS.pen.value) || 0;
        
        if (this.helpers.isInvalidNumber(DOM_ELEMENTS.pen.value)) {
          this.applyStatsClassState(DOM_ELEMENTS.pen, false); // REALTIME ADD INVALID CLASS
          penValidationResult = {
            isValid: false,
            element: DOM_ELEMENTS.pen
          };
        } else {
          const isPenValid = penVal > 0 && (penVal - defVal) > 0;
          
          if (!isPenValid) {
            this.applyStatsClassState(DOM_ELEMENTS.pen, false); // REALTIME ADD INVALID CLASS
            
            penValidationResult = {
              isValid: false,
              element: DOM_ELEMENTS.pen
            };
          } else {
            this.applyStatsClassState(DOM_ELEMENTS.pen, true); // REALTIME REMOVE INVALID CLASS
          }
        }
      }
      
      // ===== INDEPENDENT DMG VALIDATION (ALWAYS RUN) =====
      if (DOM_ELEMENTS.dmg) {
        const dmgVal = Number(DOM_ELEMENTS.dmg.value) || 0;
        
        if (this.helpers.isInvalidNumber(DOM_ELEMENTS.dmg.value)) {
          this.applyStatsClassState(DOM_ELEMENTS.dmg, false); // REALTIME ADD INVALID CLASS
          dmgValidationResult = {
            isValid: false,
            element: DOM_ELEMENTS.dmg
          };
        } else {
          const isDmgValid = dmgVal > 0 && (dmgVal - dmgredVal) > 0;
          
          if (!isDmgValid) {
            this.applyStatsClassState(DOM_ELEMENTS.dmg, false); // REALTIME ADD INVALID CLASS
            
            dmgValidationResult = {
              isValid: false,
              element: DOM_ELEMENTS.dmg
            };
          } else {
            this.applyStatsClassState(DOM_ELEMENTS.dmg, true); // REALTIME REMOVE INVALID CLASS
          }
        }
      }
      
      // ===== CONTEXT-BASED RETURN LOGIC =====
      // Jika dipanggil dari PEN field dan PEN invalid
      if (focusedElement === DOM_ELEMENTS.pen && !penValidationResult.isValid) {
        return penValidationResult;
      }
      
      // Jika dipanggil dari DMG field dan DMG invalid  
      if (focusedElement === DOM_ELEMENTS.dmg && !dmgValidationResult.isValid) {
        return dmgValidationResult;
      }
      
      // Default priority untuk kasus lainnya: PEN > DMG
      if (!penValidationResult.isValid) {
        return penValidationResult;
      }
      
      if (!dmgValidationResult.isValid) {
        return dmgValidationResult;
      }
      
      // Keduanya valid
      return { isValid: true, element: null };
      
    } catch (err) {
      return { 
        isValid: false, 
        element: null
      };
    }
  }
};
function normalizeNumericInput(el, pastedValue) {
  if (!el) return;
  
  const value = (pastedValue ?? el.value).trim();
  const norm = ValidationSSoT.normalizeNumeric(value);
  
  if (ValidationSSoT.isPenOrDmgField(el)) {
    el.value = norm.value;
    return;
  }
  
  const isValid = ValidationSSoT.validateNumericInput(norm.value, el).isValid;
  el.value = isValid ? norm.value : '';
}
function validateRequiredFields() {
  const result = ValidationSSoT.validateRequiredFieldsWithClasses();
  
  if (!result.isValid) {
    scrollAndFocusElement(result.field.el);
    return false;
  }
  
  return true;
}
function validateStatsVsTarget(state, focusedElement = null) {
  const result = ValidationSSoT.validateStatsWithClasses(state, focusedElement);
  
  if (!result.isValid) {
    // Generate and show appropriate message for DMG/PEN fields
    if (result.element) {
      const { thresholds, targetLabel } = ValidationSSoT.helpers.getValidationContext(); // Use helper
      
      let message = "Invalid input! Only numbers are allowed.";
      
      if (result.element.id === 'pen') {
        const penVal = Number(DOM_ELEMENTS.pen.value) || 0;
        const defVal = thresholds.defVal;
        
        if (!ValidationSSoT.helpers.isInvalidNumber(DOM_ELEMENTS.pen.value)) {
          const isPenValid = penVal > 0 && (penVal - defVal) > 0;
          if (!isPenValid) {
            message = ValidationSSoT.helpers.generateRequirementMessage('pen', defVal, targetLabel);
          }
        }
      } else if (result.element.id === 'dmg') {
        const dmgVal = Number(DOM_ELEMENTS.dmg.value) || 0;
        const dmgredVal = thresholds.dmgredVal;
        
        if (!ValidationSSoT.helpers.isInvalidNumber(DOM_ELEMENTS.dmg.value)) {
          const isDmgValid = dmgVal > 0 && (dmgVal - dmgredVal) > 0;
          if (!isDmgValid) {
            message = ValidationSSoT.helpers.generateRequirementMessage('dmg', dmgredVal, targetLabel);
          }
        }
      }
      
      showSnackbar(message);
      return scrollAndFocusElement(result.element);
    } else {
      return false;
    }
  }
  
  return true;
}
function initDmgTooltip(triggerElement) {
  if (!triggerElement || triggerElement.dataset.tooltipInit === "true") return;
  
  triggerElement.dataset.tooltipInit = "true";
  
  // Create tooltip
  const tooltip = document.createElement("div");
  tooltip.className = "dmgstack-tips";
  tooltip.innerHTML = `<strong>Final DMG Bonus</strong> and <strong>F. P/M DMG BONUS</strong> are two <strong>different</strong> things! Look for it in your <strong>detailed stats</strong> where it shows as <strong>Final Damage Stack</strong> or <strong>Final Damage Bonus</strong>. Make sure you don't have any buffs active. Can't find it? Just set 0.`;
  document.body.appendChild(tooltip);
  
  let isVisible = false;
  
  // Toggle tooltip
  function toggle(e) {
    e.stopPropagation();
    e.preventDefault();
    
    if (isVisible) {
      hide();
    } else {
      show();
    }
  }
  
  function show() {
    position();
    tooltip.classList.add('visible');
    isVisible = true;
  }
  
  function hide() {
    tooltip.classList.remove('visible');
    isVisible = false;
  }
  
  function position() {
    const rect = triggerElement.getBoundingClientRect();
    const scrollX = window.pageXOffset;
    const scrollY = window.pageYOffset;
    
    // Get tooltip dimensions
    tooltip.style.visibility = 'hidden';
    tooltip.style.display = 'block';
    const tooltipWidth = tooltip.offsetWidth;
    const tooltipHeight = tooltip.offsetHeight;
    tooltip.style.display = '';
    tooltip.style.visibility = '';
    
    // Calculate position
    let left = rect.left + scrollX + (rect.width / 2) - (tooltipWidth / 2);
    let top = rect.top + scrollY - tooltipHeight - 12;
    
    // Keep in viewport
    const padding = 16;
    left = Math.max(padding, Math.min(left, window.innerWidth - tooltipWidth - padding));
    
    // Flip to bottom if needed
    if (top < padding) {
      top = rect.bottom + scrollY + 12;
      tooltip.classList.add('tooltip-below');
    } else {
      tooltip.classList.remove('tooltip-below');
    }
    
    tooltip.style.left = left + "px";
    tooltip.style.top = top + "px";
  }
  
  // Events - compatible with double tap guard
  triggerElement.addEventListener("click", toggle);
  triggerElement.addEventListener("touchend", function(e) {
    e.preventDefault();
    toggle(e);
  });
  
  triggerElement.addEventListener("keydown", function(e) {
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      toggle(e);
    } else if (e.key === "Escape" && isVisible) {
      hide();
    }
  });
  
  document.addEventListener("click", function(e) {
    if (isVisible && !triggerElement.contains(e.target) && !tooltip.contains(e.target)) {
      hide();
    }
  });
  
  // Also handle touch events for mobile
  document.addEventListener("touchend", function(e) {
    if (isVisible && !triggerElement.contains(e.target) && !tooltip.contains(e.target)) {
      hide();
    }
  });
  
  document.addEventListener("keydown", function(e) {
    if (e.key === "Escape" && isVisible) hide();
  });
  
  // Reposition on resize/scroll
  window.addEventListener('resize', () => isVisible && position());
  window.addEventListener('scroll', () => isVisible && position());
}

// ========== CORE CALCULATION HELPER ==========
function getWeaponSizeModifier(weapon, size) {
  const modMap = WEAPON_SIZE_MODIFIER_TABLE[weapon];
  if (!modMap) return 1.0;
  const val = modMap[size];
  return Number.isFinite(val) ? Number(val) : 1.0;
}
function getElementCounter(weaponElem, targetElem) {
  // fallback to neutral attr or 1.00 if still undefined/null
  const elemMap = ELEMENT_COUNTER_TABLE[weaponElem] || ELEMENT_COUNTER_TABLE['Neutral'];
  const base = targetElem ? 
    ((elemMap[targetElem] !== undefined && elemMap[targetElem] !== null) ? elemMap[targetElem] : elemMap['Neutral']) : 
    ((elemMap['Neutral'] !== undefined && elemMap['Neutral'] !== null) ? elemMap['Neutral'] : 1.0);
  return Number.isFinite(base) ? Number(base) : 1.0;
}
function getTargetDefenseData(key) {
  return DEFENSE_TABLE[key] || DEFENSE_TABLE["0def"];
}
function calculateAttackFactor(type, pen, crit, def = 0) {
  // pen / crit design
  if (type === 'pen') {
    const rawPen = (Number(pen) || 0) - (Number(def) || 0);
    if (rawPen <= 0) return 0;
    const effPen = rawPen >= 150 ? ((rawPen * 2) - 150) : rawPen;
    return effPen / 100;
  }
  if (type === 'crit') {
    return (Number(crit) || 0) / 100;
  }
  return 0;
}

// ====================== CORE CALCULATION ======================
// SSOT CALC
function calculateMultiplier({
  atkType, penVal, critVal, dmgVal,
  sizeEnhVal, elemEnhVal, raceVal, attrVal,
  weapon, tSize, wElem, tAttr, tRace, tDefKey,
  extras = {}
}) {
  const { def, dmgred } = getTargetDefenseData(tDefKey);
  const atkF = calculateAttackFactor(atkType, penVal, critVal, def);

  const effDmgVal = Number(dmgVal) - dmgred;
  const sizeMod = getWeaponSizeModifier(weapon, tSize);
  const elemCtr = getElementCounter(wElem, tAttr);

  // Base multiplier (core factors only)
  const baseMult = (1 + atkF) *
    (1 + (effDmgVal / 100)) *
    (sizeMod + (Number(sizeEnhVal) / 100)) *
    (elemCtr + (Number(elemEnhVal) / 100)) *
    (1 + (tAttr ? (Number(attrVal) / 100) : 0)) *
    (1 + (tRace ? (Number(raceVal) / 100) : 0));

  // extras single object (single source of truth)
  const blueGroup3Val = Number(extras.blueGroup3Val || extras.blue3 || 0);
  const blueGroup8Val = Number(extras.blueGroup8Val || extras.blue8 || 0);
  const vesperVal = Number(extras.vesperVal || extras.vesper || 0);
  const whiteVal = Number(extras.whiteVal || extras.white || 0);
  const dmgStackVal = Number(extras.dmgStackVal || extras.dmgStack || 0);

  const extraBonuses = [];

  if (Number(vesperVal) > 0) extraBonuses.push({ key: 'Vesper', type: 'extra1', value: Number(vesperVal) / 100 });
  if (Number(blueGroup3Val) > 0) extraBonuses.push({ key: 'BlueGroup3', type: 'extra1', value: Number(blueGroup3Val) / 100 });
  if (Number(whiteVal) > 0) extraBonuses.push({ key: 'White', type: 'extra1', value: Number(whiteVal) / 100 });
  if (Number(dmgStackVal) > 0) extraBonuses.push({ key: 'DmgStack', type: 'extra1', value: Number(dmgStackVal) / 100 });

  // Reaper independent in group1 when active
  try {
    if (typeof isTestReaperActive !== 'undefined' && isTestReaperActive) {
      const reaperVal = ((wElem === tAttr) || (wElem === "Neutral" && !tAttr)) ? (42 / 100) : (14 / 100);
      extraBonuses.push({ key: 'Reaper', type: 'extra1', value: reaperVal });
    }
  } catch(e) {}

  if (Number(blueGroup8Val) > 0) extraBonuses.push({ key: 'BlueGroup8', type: 'extra2', value: Number(blueGroup8Val) / 100 });

  // Spear independent in group2 when active
  try {
    if (typeof isTestSpearActive !== 'undefined' && isTestSpearActive) {
      extraBonuses.push({ key: 'Spear', type: 'extra2', value: (42 / 100) });
    }
  } catch(e) {}

  const groups = {};
  extraBonuses.forEach(b => {
    if (!groups[b.type]) groups[b.type] = { sum: 0, items: [] };
    groups[b.type].sum += b.value;
    groups[b.type].items.push(b);
  });

  let extraMult = 1;
  const extraGroups = [];
  Object.keys(groups).forEach(type => {
    const g = groups[type];
    const factor = 1 + g.sum;
    extraGroups.push({ type, sum: g.sum, factor, items: g.items });
    extraMult *= factor;
  });

  const totalMult = baseMult * extraMult;

  return {
    mult: totalMult,
    def, dmgred, effDmgVal, atkF,
    parts: {
      baseMult: baseMult,
      extraGroups: extraGroups
    }
  };
}
// State management
let isResultShown = false;
function getCurrentCalculationState() {
  const atkType = DOM_ELEMENTS.atkType.value;
  const penVal = Number(DOM_ELEMENTS.pen.value) || 0;
  const critVal = Number(DOM_ELEMENTS.crit.value) || 0;
  const dmgVal = Number(DOM_ELEMENTS.dmg.value) || 0;
  const sizeEnhVal = Number(DOM_ELEMENTS.sizeEnh.value) || 0;
  const elemEnhVal = Number(DOM_ELEMENTS.elemEnh.value) || 0;
  const raceVal = Number(DOM_ELEMENTS.race.value) || 0;
  const attrVal = Number(DOM_ELEMENTS.attr.value) || 0;

  // Detect BlueSet group (*3 or *8) by label text
  const blueSelect = DOM_ELEMENTS.blueSet;
  const selectedBlueOption = blueSelect && blueSelect.options && blueSelect.options[blueSelect.selectedIndex];
  let blueGroup3Val = 0;
  let blueGroup8Val = 0;
  if (selectedBlueOption) {
    const optionText = selectedBlueOption.textContent || "";
    const blueValue = Number(blueSelect.value) || 0;
    if (optionText.includes('*3')) {
      blueGroup3Val = blueValue;
    }
    if (optionText.includes('*8')) {
      blueGroup8Val = blueValue;
    }
  }

  // Extra sets and manual stack
  const vesperVal = Number(DOM_ELEMENTS.vesperSet.value) || 0;
  const whiteVal = Number(DOM_ELEMENTS.whiteSet.value) || 0;
  const dmgStackVal = Number(DOM_ELEMENTS.dmgStack.value) || 0;

  
  // Build extras object (single parameter)
  const extras = {
    blueGroup3Val: blueGroup3Val,
    blueGroup8Val: blueGroup8Val,
    vesperVal: vesperVal,
    whiteVal: whiteVal,
    dmgStackVal: dmgStackVal
  };

const result = calculateMultiplier({
    atkType, penVal, critVal, dmgVal, sizeEnhVal, elemEnhVal,
    raceVal, attrVal,
    weapon: DOM_ELEMENTS.weapon.value,
    tSize: DOM_ELEMENTS.tSize.value,
    wElem: DOM_ELEMENTS.wElem.value,
    tAttr: DOM_ELEMENTS.tAttr.value,
    tRace: DOM_ELEMENTS.tRace.value,
    tDefKey: DOM_ELEMENTS.tDef.value,
    extras
  });

  return {
    atkType, penVal, critVal, dmgVal, sizeEnhVal, elemEnhVal,
    raceVal, attrVal, blueGroup3Val, blueGroup8Val,
    vesperVal, whiteVal, dmgStackVal,
    mult: result.mult, def: result.def, dmgred: result.dmgred,
    effDmgVal: result.effDmgVal, atkF: result.atkF
  ,
    parts: result.parts || {},
    extraGroups: (result.parts && Array.isArray(result.parts.extraGroups)) ? result.parts.extraGroups : []
  };
}
function processMainCalculation() {
  if (!validateRequiredFields()) return;

  const calculationState = getCurrentCalculationState();
  if (!validateStatsVsTarget(calculationState)) return;

  const isPenMode = calculationState.atkType === 'pen';
  const attackFactor = calculateAttackFactor(
    isPenMode ? 'pen' : 'crit',
    calculationState.penVal,
    calculationState.critVal,
    calculationState.def
  );
  const sizeModifier = getWeaponSizeModifier(DOM_ELEMENTS.weapon.value, DOM_ELEMENTS.tSize.value);
  const elementCounter = getElementCounter(DOM_ELEMENTS.wElem.value, DOM_ELEMENTS.tAttr.value);

  const includeRace = !!DOM_ELEMENTS.tRace.value && (calculationState.raceVal > 0);
  const includeAttr = !!DOM_ELEMENTS.tAttr.value && (calculationState.attrVal > 0);
  const includeExtra = (calculationState.blueGroup3Val > 0 || calculationState.blueGroup8Val > 0 || 
                       calculationState.vesperVal > 0 || calculationState.whiteVal > 0 || 
                       calculationState.dmgStackVal > 0);

  // Breakdown list for UI display (must match render logic)
  
  // compute extra group authoritative factors (prefer calculation result)
  var extra1Factor = 1;
  var extra2Factor = 1;
  try {
    if (calculationState.parts && Array.isArray(calculationState.parts.extraGroups)) {
      var eg1 = calculationState.parts.extraGroups.find(function(g){ return g.type === 'extra1'; });
      var eg2 = calculationState.parts.extraGroups.find(function(g){ return g.type === 'extra2'; });
      extra1Factor = eg1 ? eg1.factor : (1 + (calculationState.blueGroup3Val / 100) + (calculationState.vesperVal / 100) + (calculationState.whiteVal / 100) + (calculationState.dmgStackVal / 100));
      extra2Factor = eg2 ? eg2.factor : (1 + (calculationState.blueGroup8Val / 100));
    } else {
      extra1Factor = 1 + (calculationState.blueGroup3Val / 100) + (calculationState.vesperVal / 100) + (calculationState.whiteVal / 100) + (calculationState.dmgStackVal / 100);
      extra2Factor = 1 + (calculationState.blueGroup8Val / 100);
    }
  } catch (e) {
    extra1Factor = 1 + (calculationState.blueGroup3Val / 100) + (calculationState.vesperVal / 100) + (calculationState.whiteVal / 100) + (calculationState.dmgStackVal / 100);
    extra2Factor = 1 + (calculationState.blueGroup8Val / 100);
  }

  const includeExtraTwo = (calculationState.blueGroup8Val > 0 || (typeof isTestSpearActive !== 'undefined' && isTestSpearActive));
const factorList = [
    {
      key: 'main',
      label: (isPenMode ? 'Type (PEN)' : 'Type (CRIT)'),
      val: isPenMode ? calculationState.penVal : calculationState.critVal,
      mult: 1 + attackFactor
    },
    {
      key: 'dmg',
      label: 'Final P/M DMG BNS',
      val: calculationState.dmgVal,
      mult: 1 + (calculationState.effDmgVal || 0) / 100
    },
    {
      key: 'elem',
      label: 'Element',
      val: calculationState.elemEnhVal,
      mult: elementCounter + calculationState.elemEnhVal / 100,
      extra: `counter ${elementCounter}`
    },
    {
      key: 'size',
      label: 'Size',
      val: calculationState.sizeEnhVal,
      mult: sizeModifier + calculationState.sizeEnhVal / 100,
      extra: `mod ${sizeModifier}`
    },
    {
      key: 'race',
      label: 'Race',
      val: calculationState.raceVal,
      mult: 1 + calculationState.raceVal / 100,
      show: includeRace
    },
    {
      key: 'attr',
      label: 'Attribute',
      val: calculationState.attrVal,
      mult: 1 + calculationState.attrVal / 100,
      show: includeAttr
    },
    {
      key: 'extra',
      label: 'Extra#1',
      val: calculationState.blueGroup3Val + calculationState.vesperVal + calculationState.whiteVal + calculationState.dmgStackVal,
      mult: extra1Factor,
      show: includeExtra
    },
    {
      key: 'extraTwo',
      label: 'Extra#2',
      val: calculationState.blueGroup8Val,
      mult: extra2Factor,
      show: includeExtraTwo
    }
  ];

  renderMultiplierBreakdown(calculationState, factorList, elementCounter, sizeModifier, isPenMode);
  generateRecommendationTable(calculationState);

  // Enable test buttons after successful calculation
  try {
    if (DOM_ELEMENTS.testReaper) DOM_ELEMENTS.testReaper.disabled = false;
    if (DOM_ELEMENTS.testSpear) DOM_ELEMENTS.testSpear.disabled = false;
  } catch (e) { console.warn('enable test buttons', e); }

  isResultShown = true;
  DOM_ELEMENTS.submit.disabled = true;
  DOM_ELEMENTS.resetRek.disabled = false;
  DOM_ELEMENTS.resetAll.disabled = false;
  DOM_ELEMENTS.testSpear.disabled = false;
  DOM_ELEMENTS.testReaper.disabled = false;
  lockAllInputs();
    if (typeof showSnackbar === 'function') {
    showSnackbar("Stats Calculated!");
  }
}

// === dom manipulation (#result n #recommendations) ===
function createElementNode(tag, props = {}, children = []) {
  const element = document.createElement(tag);
  
  Object.entries(props).forEach(([key, value]) => {
    if (key === "class") {
      element.className = value;
    } else if (key === "for") {
      element.setAttribute("for", value);
    } else if (key === "text") {
      element.textContent = value;
    } else {
      element.setAttribute(key, value);
    }
  });
  
  const childArray = Array.isArray(children) ? children : [children];
  childArray.forEach(child => {
    if (child) {
      element.appendChild(typeof child === "string" ? document.createTextNode(child) : child);
    }
  });
  
  return element;
}
function renderMultiplierBreakdown(state, factorList, elementCounter, sizeModifier, isPenMode) {
  const resultElement = DOM_ELEMENTS.hasil;
  const showFullPrecision = resultElement?.dataset?.showFullPrecision === "1";

  // Cache DOM elements
  const dom = {
    tDef: DOM_ELEMENTS.tDef,
    tSize: DOM_ELEMENTS.tSize,
    tRace: DOM_ELEMENTS.tRace,
    tAttr: DOM_ELEMENTS.tAttr,
    wElem: DOM_ELEMENTS.wElem,
    weapon: DOM_ELEMENTS.weapon,
    vesperSet: DOM_ELEMENTS.vesperSet,
    blueSet: DOM_ELEMENTS.blueSet,
    whiteSet: DOM_ELEMENTS.whiteSet,
    pen: DOM_ELEMENTS.pen,
    crit: DOM_ELEMENTS.crit
  };

  const formatValue = (n) => {
    const num = Number(n) || 0;
    return showFullPrecision ? num : Math.trunc(num * 100) / 100;
  };

  // authoritative extra groups from calculation state (single source of truth for display)
  let authoritativeExtra1 = null;
  let authoritativeExtra2 = null;
  try {
    if (state && state.parts && Array.isArray(state.parts.extraGroups)) {
      authoritativeExtra1 = state.parts.extraGroups.find(function (g) { return g.type === 'extra1'; }) || null;
      authoritativeExtra2 = state.parts.extraGroups.find(function (g) { return g.type === 'extra2'; }) || null;
    }
  } catch (e) { /* ignore */ }

  // Re-lock all inputs after target swap
  function relockAllNumericInputs() {
    document.querySelectorAll(".input-wrap").forEach(wrapper => {
      if (wrapper.dataset.tempUnlocked === "1") return;
      const element = wrapper.querySelector("select, input");
      if (!element) return;
      try {
        bindInputLockGuard(wrapper);
      } catch (e) { }
      wrapper.classList.add("locked");
      element.disabled = true;
    });
  }

  // Local helper for creating factor breakdown items
  const createFactorItem = (factor) => {
    if (factor.show === false) {
      return createElementNode("li", {
        text: `${factor.label}: ×1.00 (no stat)`
      });
    }

    switch (factor.key) {
      case "main":
        return createMainFactorItem(factor);
      case "dmg":
        return createDmgFactorItem(factor);
      case "elem":
        return createElemFactorItem(factor);
      case "size":
        return createSizeFactorItem(factor);
      case "race":
        return createRaceFactorItem(factor);
      case "attr":
        return createAttrFactorItem(factor);
      case "extra":
        return createExtraFactorItem(factor);
      case "extraTwo":
        return createExtraTwoFactorItem(factor);
      default:
        return createElementNode("li", {}, [
          `${factor.label}: ${formatValue(factor.val)} → `,
          createElementNode("code", { text: `×${formatValue(factor.mult)}` })
        ]);
    }
  };

  const createMainFactorItem = (factor) => {
    const defenseLabel = (dom.tDef.options[dom.tDef.selectedIndex]?.text) || "Target";
    const subList = createElementNode("ul");

    if (isPenMode) {
      const rawPen = state.penVal || 0;
      const def = state.def || 0;
      const basePen = rawPen - def;

      const items = [
        createElementNode("li", { text: `Raw PEN + Final PEN: ${formatValue(rawPen)}` }),
        createElementNode("li", { text: `Target DEF: ${formatValue(def)}` })
      ];

      if (basePen >= 150) {
        const effectivePercent = (basePen * 2) - 150;
        items.push(
          createElementNode("li", { text: `1.00 + ((( ${formatValue(rawPen)} - ${formatValue(def)} ) × 2 ) - 150 ) / 100` }),
          createElementNode("li", {}, [
            `1.00 + ( ${formatValue(effectivePercent)} / 100 ) → `,
            createElementNode("code", { text: `×${formatValue(factor.mult)}` })
          ])
        );
      } else {
        items.push(createElementNode("li", {}, [
          `1.00 + (( ${formatValue(rawPen)} - ${formatValue(def)} ) / 100 ) → `,
          createElementNode("code", { text: `×${formatValue(factor.mult)}` })
        ]));
      }

      items.forEach(item => subList.appendChild(item));
    } else {
      subList.appendChild(createElementNode("li", { text: `Crit DMG: ${formatValue(factor.val)}` }));
      subList.appendChild(createElementNode("li", {}, [
        `1.00 + ( ${formatValue(factor.val)} / 100 ) → `,
        createElementNode("code", { text: `×${formatValue(factor.mult)}` })
      ]));
    }

    return createElementNode("li", {
      text: `Attack Type: ${isPenMode ? "PEN" : "CRIT"} vs ${defenseLabel}`
    }, subList);
  };

  const createDmgFactorItem = (factor) => {
    const subItems = [
      createElementNode("li", { text: `P/M BO: ${formatValue(factor.val)}` }),
      createElementNode("li", { text: `Target Reduction: ${formatValue(state.dmgred || 0)}` }),
      createElementNode("li", {}, [
        `1.00 + (( ${formatValue(factor.val)} - ${formatValue(state.dmgred || 0)} ) / 100 ) → `,
        createElementNode("code", { text: `×${formatValue(factor.mult)}` })
      ])
    ];

    return createElementNode("li", { text: "Final P/M Damage Bonus" },
      createElementNode("ul", {}, subItems)
    );
  };

  const createElemFactorItem = (factor) => {
    const subItems = [
      createElementNode("li", { text: `Counter: ${formatValue(elementCounter)}` }),
      createElementNode("li", { text: `${dom.wElem.value} Enhance: ${formatValue(factor.val)}` }),
      createElementNode("li", {}, [
        `${formatValue(elementCounter)} + ${formatValue(factor.val / 100)} → `,
        createElementNode("code", { text: `×${formatValue(factor.mult)}` })
      ])
    ];

    if (!dom.tAttr.value) {
      subItems.push(createElementNode("li", {
        text: "Tools assume target Neutral if you're not targeting any attribute."
      }));
    }

    return createElementNode("li", {
      text: `Element: ${dom.wElem.value || "Neutral"} vs ${dom.tAttr.value || "Neutral"}`
    }, createElementNode("ul", {}, subItems));
  };

  const createSizeFactorItem = (factor) => {
    const subItems = [
      createElementNode("li", { text: `Modifier: ${formatValue(sizeModifier)}` }),
      createElementNode("li", { text: `${dom.tSize.value} Enhance: ${formatValue(factor.val)}` }),
      createElementNode("li", {}, [
        `${formatValue(sizeModifier)} + ${formatValue(factor.val / 100)} → `,
        createElementNode("code", { text: `×${formatValue(factor.mult)}` })
      ])
    ];

    return createElementNode("li", {
      text: `Size: ${dom.weapon.value || "Weapon"} vs ${dom.tSize.value}`
    }, createElementNode("ul", {}, subItems));
  };

  const createRaceFactorItem = (factor) => {
    const raceLabel = (dom.tRace.options[dom.tRace.selectedIndex]?.text) || "Target Race";
    const subItems = [
      createElementNode("li", { text: `DMG to ${raceLabel}: ${formatValue(factor.val)}` }),
      createElementNode("li", {}, [
        `1.00 + ( ${formatValue(factor.val)} / 100 ) → `,
        createElementNode("code", { text: `×${formatValue(factor.mult)}` })
      ])
    ];

    return createElementNode("li", { text: `Race: ${raceLabel}` },
      createElementNode("ul", {}, subItems)
    );
  };

  const createAttrFactorItem = (factor) => {
    const attrLabel = (dom.tAttr.options[dom.tAttr.selectedIndex]?.text) || "Target Attribute";
    const subItems = [
      createElementNode("li", { text: `DMG to ${attrLabel} Attribute: ${formatValue(factor.val)}` }),
      createElementNode("li", {}, [
        `1.00 + ( ${formatValue(factor.val)} / 100 ) → `,
        createElementNode("code", { text: `×${formatValue(factor.mult)}` })
      ])
    ];

    return createElementNode("li", { text: `Attribute: ${attrLabel}` },
      createElementNode("ul", {}, subItems)
    );
  };

const createExtraFactorItem = (factor) => {
  const subList = createElementNode("ul");
  
  const values = {
    g3: Number(state.blueGroup3Val) || 0,
    ves: Number(state.vesperVal) || 0,
    white: Number(state.whiteVal) || 0,
    stack: Number(state.dmgStackVal) || 0
  };
  
  const rawParts = [];
  
  if (values.ves > 0) {
    subList.appendChild(createElementNode("li", { text: "Vesper SET: " + dom.vesperSet.options[dom.vesperSet.selectedIndex].text }));
    subList.appendChild(createElementNode("li", { text: formatValue(values.ves) + " / 100" }));
    rawParts.push(values.ves / 100);
  }
  if (values.g3 > 0) {
    subList.appendChild(createElementNode("li", { text: "Blue SET (Ferocity): " + dom.blueSet.options[dom.blueSet.selectedIndex].text }));
    subList.appendChild(createElementNode("li", { text: formatValue(values.g3) + " / 100" }));
    rawParts.push(values.g3 / 100);
  }
  if (values.white > 0) {
    subList.appendChild(createElementNode("li", { text: "White SET (110*3): " + dom.whiteSet.options[dom.whiteSet.selectedIndex].text }));
    subList.appendChild(createElementNode("li", { text: formatValue(values.white) + " / 100" }));
    rawParts.push(values.white / 100);
  }
  if (values.stack > 0) {
    subList.appendChild(createElementNode("li", { text: "Final DMG BNS: " + formatValue(values.stack) }));
    subList.appendChild(createElementNode("li", { text: formatValue(values.stack) + " / 100" }));
    rawParts.push(values.stack / 100);
  }
  
  // Reaper toggle
  if (typeof isTestReaperActive !== "undefined" && isTestReaperActive) {
    const reaperPercent = (
  (dom.wElem.value && dom.tAttr.value && dom.wElem.value === dom.tAttr.value) ||
  (dom.wElem.value === "Neutral" && !dom.tAttr.value)
) ? 42 : 14;
    subList.appendChild(createElementNode("li", { text: "Reaper Scythe: " + (dom.wElem.value || "?") + " vs " + (dom.tAttr.value || "Neutral") }));
    subList.appendChild(createElementNode("li", { text: formatValue(reaperPercent) + " / 100" }));
    subList.appendChild(createElementNode("li", {
  class: "note",
  text: (dom.wElem.value === dom.tAttr.value || (dom.wElem.value === "Neutral" && !dom.tAttr.value)) ?
    "Elements match. Real bonus is 84% (10s duration / 20s CD), displayed here as(sume) 42% for 100% uptime." :
    "Elements differ. Real bonus is 28% (10s duration / 20s CD), displayed here as(sume) 14% for 100% uptime."
}));
    rawParts.push(reaperPercent / 100);
  }
  
  const sum = rawParts.reduce((a, b) => a + b, 0);
  const sumDisplay = rawParts.map(v => formatValue(v)).join(" + ");
  if (authoritativeExtra1) {
    try {
      const authSum = Number(authoritativeExtra1.sum) || 0;
      const display = (Array.isArray(authoritativeExtra1.items) && authoritativeExtra1.items.length) ?
        authoritativeExtra1.items.map(i => formatValue(i.val || i.value || i)).join(" + ") :
        formatValue(authSum);
      subList.appendChild(createElementNode("li", {}, ["1 + " + display + " → ", createElementNode("code", { text: "×" + formatValue(1 + authSum) })]));
    } catch (e) {
      subList.appendChild(createElementNode("li", {}, ["1 + " + sumDisplay + " → ", createElementNode("code", { text: "×" + formatValue(1 + sum) })]));
    }
  } else if (rawParts.length > 0) {
    subList.appendChild(createElementNode("li", {}, ["1 + " + sumDisplay + " → ", createElementNode("code", { text: "×" + formatValue(1 + sum) })]));
  } else {
    subList.appendChild(createElementNode("li", { text: "× 1.00 (no stat)" }));
  }
  
  return createElementNode("li", { text: "Extra#1: Final DMG Bonus" }, subList);
};

const createExtraTwoFactorItem = (factor) => {
  const subList = createElementNode("ul");
  const g8 = Number(state.blueGroup8Val) || 0;
  const rawParts = [];
  
  if (g8 > 0) {
    subList.appendChild(createElementNode("li", { text: "Blue SET: " + dom.blueSet.options[dom.blueSet.selectedIndex].text }));
    subList.appendChild(createElementNode("li", { text: formatValue(g8) + " / 100" }));
    rawParts.push(g8 / 100);
  }
  
  // Spear toggle
  if (typeof isTestSpearActive !== "undefined" && isTestSpearActive) {
    subList.appendChild(createElementNode("li", { text: "Spear of Eternity" }));
    subList.appendChild(createElementNode("li", { text: formatValue(42) + " / 100" }));
    subList.appendChild(createElementNode("li", {
  class: "note",
  text: "This bonus is shown as(sume) 100% uptime (actual bonus is 84%)."
}));
    rawParts.push(42 / 100);
  }
  
  const sum = rawParts.reduce((a, b) => a + b, 0);
  const sumDisplay = rawParts.map(v => formatValue(v)).join(" + ");
  if (authoritativeExtra2) {
    try {
      const authSum2 = Number(authoritativeExtra2.sum) || 0;
      const display = (Array.isArray(authoritativeExtra2.items) && authoritativeExtra2.items.length) ?
        authoritativeExtra2.items.map(i => formatValue(i.val || i.value || i)).join(" + ") :
        formatValue(authSum2);
      subList.appendChild(createElementNode("li", {}, ["1 + " + display + " → ", createElementNode("code", { text: "×" + formatValue(1 + authSum2) })]));
    } catch (e) {
      subList.appendChild(createElementNode("li", {}, ["1 + " + sumDisplay + " → ", createElementNode("code", { text: "×" + formatValue(1 + sum) })]));
    }
  } else if (rawParts.length > 0) {
    subList.appendChild(createElementNode("li", {}, ["1 + " + sumDisplay + " → ", createElementNode("code", { text: "×" + formatValue(1 + sum) })]));
  } else {
    subList.appendChild(createElementNode("li", { text: "× 1.00 (no stat)" }));
  }
  
  return createElementNode("li", { text: "Extra#2: Bonus DMG to MVP/MINI" }, subList);
};

  const createBreakdownList = () => {
    const list = createElementNode("ul", { class: "factor-breakdown" });
    const fragment = document.createDocumentFragment();

    factorList.forEach(factor => {
      fragment.appendChild(createFactorItem(factor));
    });

    list.appendChild(fragment);
    return list;
  };

  // Create precision toggle button
  const precisionToggleButton = createElementNode("button", {
    type: "button",
    class: "toggle-precision",
    text: showFullPrecision ? "Beautify!" : "Want to see?"
  });

  precisionToggleButton.addEventListener("click", (event) => {
    event.preventDefault();
    if (!resultElement?.dataset) return;
    resultElement.dataset.showFullPrecision =
      resultElement.dataset.showFullPrecision === "1" ? "0" : "1";
    processMainCalculation();
    showSnackbar(resultElement.dataset.showFullPrecision === "1"
  ? "Precise numbers displayed"
  : "Rounded numbers displayed"
);
  });

  // Target swap functionality
  const createSwapSelect = () => {
    const DEFENSE_SWAP_OPTIONS = [
      { key: "0def", label: "Dummy (0 DEF)" },
      { key: "130boss", label: "Avg. 130 BOSS" },
      { key: "140boss", label: "Avg. 140 BOSS" },
      { key: "150boss", label: "Avg. 150 BOSS" }
    ];

    const presetKeys = new Set(["0def", "130boss", "140boss", "150boss"]);
    Object.keys(DEFENSE_TABLE).forEach(key => {
      if (!presetKeys.has(key)) DEFENSE_SWAP_OPTIONS.push({ key, label: key });
    });

    const swapSelect = createElementNode("select", {
      id: "breakdown-swap",
      class: "breakdown-swap"
    });

    const fragment = document.createDocumentFragment();
    DEFENSE_SWAP_OPTIONS.forEach(optionData => {
      const defenseData = getTargetDefenseData(optionData.key);
      const defValue = Number(defenseData.def || 0);
      const dmgredValue = Number(defenseData.dmgred || 0);
      const option = createElementNode("option", {
        value: optionData.key,
        text: optionData.label
      });

      const atkType = state.atkType.toLowerCase();
      const penValue = Number(dom.pen?.value || 0);
      const dmgValue = Number(DOM_ELEMENTS.dmg?.value || 0);
      const insufficientStats = atkType === "pen"
        ? (penValue <= defValue || dmgValue <= dmgredValue)
        : (dmgValue <= dmgredValue);

      if (insufficientStats) {
        option.disabled = true;
        option.textContent += " (stats not enough)";
      }
      fragment.appendChild(option);
    });

    swapSelect.appendChild(fragment);
    swapSelect.value = dom.tDef.value || "0def";
    return { swapSelect, presetKeys };
  };

  const { swapSelect, presetKeys } = createSwapSelect();

  // Create main container elements
  const fragment = document.createDocumentFragment();

  const elements = [
    createElementNode("blockquote", { class: "noted" }, [
      "By default, every factor starts at ×1.00. Numbers show how it changes with your stats.",
      createElementNode("br"),
      createElementNode("br"),
      "Values shown to two decimal places for readability. The final result is computed with full precision(",
      precisionToggleButton,
      "), so it may differ slightly if you recompute using the displayed (rounded) numbers."
    ]),
    createBreakdownList(),
    createElementNode("hr", { class: "separ" }),
    createElementNode("div", {
      id: "swap-wrapper",
      class: "breakdown-swap-wrapper"
    }, [
      createElementNode("label", {
        for: "breakdown-swap",
        id: "swap-label",
        text: "Swap Target:"
      }),
      swapSelect
    ]),
    createElementNode("p", {}, [
      "Your multiplier to ",
      createElementNode("i", {}, [
        [dom.tSize.value, dom.tRace.value, dom.tAttr.value]
          .filter(v => v)
          .join(" + "),
        " (",
        dom.tDef.options[dom.tDef.selectedIndex]?.text || "",
        ")"
      ]),
      ":"
    ]),
    createElementNode("blockquote", { class: "noted" }, [
  (() => {
    const partsArr = [];
    (factorList || []).forEach(f => {
      partsArr.push(
        f.show === false ?
        "× 1.00 (no " + f.label.toLowerCase() + ")" :
        "× " + formatValue(f.mult)
      );
    });
    return "1.00 " + partsArr.join(" ") + " = ";
  })(),
  createElementNode("code", { text: "×" + formatValue(state.mult) }),
  createElementNode("br"),
  createElementNode("br"),
  "Only base multipliers! Real output depends on class, skills, buffs, and more. More accurate? Just use job sims.",
  createElementNode("br"),
  createElementNode("br"),
  "Avg 130, Necro, Ogre, Ktul defs less accurate than others!",
  createElementNode("br"),
  createElementNode("br"),
  "In the table, an upward arrow means higher than your stat, a square means roughly equal (±3%), and a downward means lower."
])
  ];

  elements.forEach(el => fragment.appendChild(el));

  const container = createElementNode("div", {
    id: "multiplier-breakdown",
    class: "multiplier-breakdown"
  });
  container.appendChild(fragment);

  // Target swap event handler
  swapSelect.addEventListener("change", () => {
    const previousKey = dom.tDef.value;
    const currentKey = swapSelect.value;
    const previousData = DEFENSE_TABLE[previousKey] || {};
    const currentData = DEFENSE_TABLE[currentKey] || {};
    const isPresetKey = key => presetKeys.has(key);

    dom.tDef.value = currentKey;

    const sameFactors = currentData.sizeMob === previousData.sizeMob &&
      currentData.raceMob === previousData.raceMob &&
      currentData.attributeMob === previousData.attributeMob;

    // Simple swap - just defense changes
    if ((isPresetKey(previousKey) && isPresetKey(currentKey)) ||
        (!isPresetKey(previousKey) && isPresetKey(currentKey)) ||
        (!isPresetKey(previousKey) && !isPresetKey(currentKey) && 
         previousKey.replace(/\d+$/, "") === currentKey.replace(/\d+$/, "")) ||
        (!isPresetKey(previousKey) && !isPresetKey(currentKey) && sameFactors)) {

      if (!isPresetKey(previousKey) && isPresetKey(currentKey)) {
        // Clear race and attr when switching from specific to preset
        [dom.tRace, dom.tAttr].forEach((element, index) => {
          if (element) {
            element.value = "";
            try {
              element.dispatchEvent(new Event("input", { bubbles: true }));
              element.dispatchEvent(new Event("change", { bubbles: true }));
            } catch (e) {}
          }
          const fieldId = index === 0 ? "race" : "attr";
          const inputElement = DOM_ELEMENTS[fieldId];
          if (inputElement) {
            inputElement.value = "";
            try {
              inputElement.dispatchEvent(new Event("input", { bubbles: true }));
              inputElement.dispatchEvent(new Event("change", { bubbles: true }));
            } catch (e) {}
          }
        });
        updateDynamicFieldLabels();
      }

      relockAllNumericInputs();
      resultElement.dataset.specificMode = "0";
      processMainCalculation();
      showSnackbar('Swap to same type mob, auto calc!')
      return;
    }

    // Complex swap - mob characteristics change (SPECIFIC TARGET LOGIC)
    dom.tSize.value = currentData.sizeMob || "";
    dom.tRace.value = currentData.raceMob || "";
    dom.tAttr.value = currentData.attributeMob || "";
    updateDynamicFieldLabels();

    const atkType = state.atkType.toLowerCase();
    const unlockFieldIds = ["dmg", "dmgStack"];
    if (atkType === "pen") unlockFieldIds.push("pen");
    if (atkType === "crit") unlockFieldIds.push("crit");
    if (dom.tSize.value) unlockFieldIds.push("sizeEnh");
    if (dom.tRace.value) unlockFieldIds.push("race");
    if (dom.tAttr.value) unlockFieldIds.push("attr");
    if (dom.wElem.value) unlockFieldIds.push("elemEnh");

    const unlockInputs = [];
    unlockFieldIds.forEach(fieldId => {
      const element = DOM_ELEMENTS[fieldId];
      if (!element) return;
      const wrapper = element.closest(".input-wrap");
      if (wrapper) {
        try { 
          unbindInputLockGuard(wrapper); 
        } catch (e) {}
        wrapper.classList.remove("locked");
        wrapper.dataset.tempUnlocked = "1";
      }
      element.disabled = false;
      unlockInputs.push({ fieldId, element, wrapper });
    });

    // Enable submit button and disable ALL OTHER elements for specific target swap
    if (DOM_ELEMENTS.submit) {
      DOM_ELEMENTS.submit.disabled = false;
    }
    
    // Disable ALL other elements except submit button
    Object.keys(DOM_ELEMENTS).forEach(key => {
      const element = DOM_ELEMENTS[key];
      if (key !== 'submit' && element && typeof element.disabled !== 'undefined') {
        element.disabled = true;
      }
    });
    
    // Also disable test buttons specifically
    if (DOM_ELEMENTS.testSpear) {
      DOM_ELEMENTS.testSpear.disabled = true;
    }
    if (DOM_ELEMENTS.testReaper) {
      DOM_ELEMENTS.testReaper.disabled = true;
    }
    
    // Keep the unlocked inputs enabled (they need to be editable for user to input stats)
    unlockInputs.forEach(({ element }) => {
      element.disabled = false;
    });

    function validateAndRelock() {
      let allValid = true;
      unlockInputs.forEach(({ fieldId, element }) => {
        const shouldSkip = (fieldId === "sizeEnh" && !dom.tSize.value) ||
          (fieldId === "race" && !dom.tRace.value) ||
          (fieldId === "attr" && !dom.tAttr.value) ||
          (fieldId === "elemEnh" && !dom.wElem.value);
        if (shouldSkip) return;

        const numValue = Number(element.value);
        const minRequired = Number(element.getAttribute("min")) || 0;
        if (!(element.value && !isNaN(numValue) && numValue >= minRequired)) {
          allValid = false;
        }
      });

      if (!allValid) return;

      try {
        if (!validateRequiredFields()) return;
      } catch (e) { 
        return; 
      }

      unlockInputs.forEach(({ element, wrapper }) => {
        if (wrapper) {
          wrapper.removeAttribute("data-temp-unlocked");
          wrapper.classList.add("locked");
          try { 
            bindInputLockGuard(wrapper); 
          } catch (e) {}
        }
        element.disabled = true;
        element.removeEventListener("blur", validateAndRelock);
      });

      // Re-enable all other elements after manual calculation
      Object.keys(DOM_ELEMENTS).forEach(key => {
        const element = DOM_ELEMENTS[key];
        if (key !== 'submit' && element && typeof element.disabled !== 'undefined') {
          element.disabled = false;
        }
      });
      
      // Re-enable test buttons specifically
      if (DOM_ELEMENTS.testSpear) {
        DOM_ELEMENTS.testSpear.disabled = false;
      }
      if (DOM_ELEMENTS.testReaper) {
        DOM_ELEMENTS.testReaper.disabled = false;
      }

      resultElement.dataset.specificMode = "0";
      // Remove auto calculation - let user trigger manually via submit button
      showSnackbar('Please click Submit button to calculate with new target!');
    }

    // Don't add blur event listeners for specific swap - user must click Submit manually
    // unlockInputs.forEach(({ element }) => {
    //   element.removeEventListener("blur", validateAndRelock);
    //   element.addEventListener("blur", validateAndRelock);
    // });

    const fieldMappings = [
      { condition: currentData.sizeMob !== previousData.sizeMob, fieldId: "sizeEnh" },
      { condition: currentData.raceMob !== previousData.raceMob, fieldId: "race" },
      { condition: currentData.attributeMob !== previousData.attributeMob, fieldId: "attr" }
    ];

    let focusTarget = null;
    fieldMappings.forEach(({ condition, fieldId }) => {
      if (!condition) return;
      const element = DOM_ELEMENTS[fieldId];
      if (element) {
        element.value = "";
        try {
          element.dispatchEvent(new Event("input", { bubbles: true }));
          element.dispatchEvent(new Event("change", { bubbles: true }));
        } catch (e) {}
        if (!focusTarget) focusTarget = element;
      }
    });

    const firstEmpty = unlockInputs.find(({ element }) => !element.value);
    const target = focusTarget || (firstEmpty ? firstEmpty.element : (unlockInputs[0]?.element));
    if (target) {
      scrollAndFocusElement(target, "Please re-enter your stats and click Submit.");
    }
  });

  // Bind main target select to swap select (prevent duplicate listeners)
  if (!dom.tDef.dataset.swapBound) {
    dom.tDef.addEventListener("change", () => {
      swapSelect.value = dom.tDef.value;
    });
    dom.tDef.dataset.swapBound = "1";
  }

  // Update attack type disabled states
  const atkType = state.atkType.toLowerCase();
  if (dom.pen && dom.crit) {
    if (atkType === "pen") {
      dom.pen.disabled = false;
      dom.crit.disabled = true;
    } else {
      dom.pen.disabled = true;
      dom.crit.disabled = false;
    }
  }

  resultElement.innerHTML = "";
  resultElement.appendChild(container);
}
function calculateRecommendationWeights({ includeRace, includeAttr, baseMain, baseDmg, baseElem, baseSize, baseRace, baseAttr }) {
  const BIAS = RECOMMENDATION_CONFIG.bias;
  const rawWeights = [
    safeNumber(baseMain) * BIAS.main,
    safeNumber(baseDmg) * BIAS.dmg,
    safeNumber(baseElem) * BIAS.elem,
    safeNumber(baseSize) * BIAS.size
  ];

  const maxRaw = Math.max(...rawWeights, 1);
  const normalizedWeights = rawWeights.map(v => v / maxRaw);
  const coreSum = normalizedWeights.reduce((a, b) => a + b, 0) || 1;
  const coreShare = (includeRace || includeAttr) ? 0.8 : 1.0;
  const additionalShare = 1 - coreShare;

  let weights = {
    main: normalizedWeights[0] / coreSum * coreShare,
    dmg: normalizedWeights[1] / coreSum * coreShare,
    elem: normalizedWeights[2] / coreSum * coreShare,
    size: normalizedWeights[3] / coreSum * coreShare,
    race: 0,
    attr: 0
  };

  const effRace = includeRace ? Math.max(Math.pow(baseRace, RECOMMENDATION_CONFIG.smallExp), RECOMMENDATION_CONFIG.smallMin) : 0;
  const effAttr = includeAttr ? Math.max(Math.pow(baseAttr, RECOMMENDATION_CONFIG.smallExp), RECOMMENDATION_CONFIG.smallMin) : 0;

  const raceAvailable = includeRace && effRace > 0 && effRace < RECOMMENDATION_CONFIG.raceAttrCap;
  const attrAvailable = includeAttr && effAttr > 0 && effAttr < RECOMMENDATION_CONFIG.raceAttrCap;

  if (raceAvailable && attrAvailable) {
    const raceAttrSum = safeNumber(effRace) + safeNumber(effAttr);
    if (raceAttrSum > 0) {
      weights.race = (safeNumber(effRace) / raceAttrSum) * additionalShare;
      weights.attr = (safeNumber(effAttr) / raceAttrSum) * additionalShare;
    } else {
      weights.race = additionalShare / 2;
      weights.attr = additionalShare / 2;
    }
  } else if (raceAvailable) {
    weights.race = additionalShare;
  } else if (attrAvailable) {
    weights.attr = additionalShare;
  } else if (includeRace || includeAttr) {
    const keys = ["main", "dmg", "elem", "size"];
    normalizedWeights.forEach((v, i) => {
      weights[keys[i]] += (v / coreSum) * additionalShare;
    });
  }

  const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0) || 1;
  Object.keys(weights).forEach(k => { weights[k] /= totalWeight; });
  return weights;
}
function applySmallValueAdjustment(value, baseRace, baseAttr) {
  const total = baseRace + baseAttr;
  if (total > 0 && total < RECOMMENDATION_CONFIG.smallThreshold) {
    // Enhance small values for better recommendations
    return Math.max(Math.pow(value, RECOMMENDATION_CONFIG.smallExp), RECOMMENDATION_CONFIG.smallMin);
  }
  return value;
}
function generateRandomValue(baseValue, jitter = RECOMMENDATION_CONFIG.jitter) {
  const v = Number(baseValue) || 0;
  const mode = RECOMMENDATION_CONFIG.randomMode;
  
  if (mode === "clamp") {
    const delta = (Math.random() * 2 - 1) * jitter;
    const maxClamp = Math.min(RECOMMENDATION_CONFIG.clampMaxFraction * jitter, RECOMMENDATION_CONFIG.clampMaxAbsolute);
    const clamped = Math.max(Math.min(delta, maxClamp), -maxClamp);
    return Math.max(0, v * (1 + clamped));
  }
  
  if (mode === "normal") {
    let u = 0, v2 = 0;
    while (u === 0) u = Math.random();
    while (v2 === 0) v2 = Math.random();
    const num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v2);
    return Math.max(0, v * (1 + num * jitter * 0.5));
  }
  
  const delta = (Math.random() * 2 - 1) * jitter;
  return Math.max(0, v * (1 + delta));
}
function getMaxAllowedValue(userValue, cap, tolerance, isSmall) {
  return userValue >= cap ? (isSmall ? cap + tolerance : userValue + tolerance) : cap;
}
function avoidCapLimit(value, cap) {
  // Avoid rendering exactly at cap value
  if (value < cap) return value;
  const offset = cap * (0.01 + Math.random() * 0.02);
  return cap - offset;
}
function createFactorCell(value, baseValue) {
  const rounded = Math.round(value);
  const baseRounded = Math.round(baseValue);
  let className = 'neutral';
  
  if (rounded >= baseRounded + RECOMMENDATION_CONFIG.upDownThreshold) {
    className = 'up';
  } else if (rounded <= baseRounded - RECOMMENDATION_CONFIG.upDownThreshold) {
    className = 'down';
  }
  
  const span = document.createElement('span');
  span.className = className;
  span.textContent = rounded;
  
  const cell = document.createElement('td');
  cell.appendChild(span);
  return cell;
}
function generateRecommendationTable(state) {
  const baseMultiplier = state.mult;
  const recommendationsRoot = DOM_ELEMENTS.rec;
  recommendationsRoot.innerHTML = '';
  
  const includeRace = !!DOM_ELEMENTS.tRace.value && (Number(state.raceVal) || 0) > 0;
  const includeAttr = !!DOM_ELEMENTS.tAttr.value && (Number(state.attrVal) || 0) > 0;
  const isPenMode = state.atkType === 'pen';

  const baseMain = isPenMode ? state.penVal : state.critVal;
  const baseDmg = state.dmgVal || 0;
  const baseSize = state.sizeEnhVal || 0;
  const baseElem = state.elemEnhVal || 0;
  const baseAttr = includeAttr ? (state.attrVal || 0) : 0;
  const baseRace = includeRace ? (state.raceVal || 0) : 0;

  const weights = calculateRecommendationWeights({
    includeRace, includeAttr, baseMain, baseDmg, baseElem, baseSize, baseRace, baseAttr
  });
  
  const centerScale = RECOMMENDATION_CONFIG.centerScale;
  const centerValue = (base, weight) => safeNumber(base) * (1 + weight * centerScale);

  const centeredMain = centerValue(baseMain, weights.main);
  const centeredDmg = centerValue(baseDmg, weights.dmg);
  const centeredElem = centerValue(baseElem, weights.elem);
  const centeredSize = centerValue(baseSize, weights.size);

  const effectiveAttr = includeAttr ? applySmallValueAdjustment(baseAttr, baseRace, baseAttr) : 0;
  const effectiveRace = includeRace ? applySmallValueAdjustment(baseRace, baseRace, baseAttr) : 0;

  const centeredAttr = includeAttr ? Math.min(centerValue(effectiveAttr, weights.attr), RECOMMENDATION_CONFIG.raceAttrCap) : 0;
  const centeredRace = includeRace ? Math.min(centerValue(effectiveRace, weights.race), RECOMMENDATION_CONFIG.raceAttrCap) : 0;

  const calculateRaceAttrValues = (jitter) => {
    let raceValue = 0, attrValue = 0;

    if (includeAttr && includeRace) {
      const userTotal = baseRace + baseAttr;
      const boostedTotal = effectiveRace + effectiveAttr;
      const isSmall = userTotal > 0 && userTotal < RECOMMENDATION_CONFIG.smallThreshold;
      const maxTotal = getMaxAllowedValue(userTotal, RECOMMENDATION_CONFIG.raceAttrCap, RECOMMENDATION_CONFIG.raceAttrTol, isSmall);

      const total = avoidCapLimit(Math.min(generateRandomValue(boostedTotal, jitter), maxTotal), maxTotal);
      const ratio = RECOMMENDATION_CONFIG.ratioMin + Math.random() * (RECOMMENDATION_CONFIG.ratioMax - RECOMMENDATION_CONFIG.ratioMin);

      [raceValue, attrValue] = [total * ratio, total * (1 - ratio)];
      const sum = raceValue + attrValue;
      
      if (sum > maxTotal) {
        const scale = avoidCapLimit(maxTotal, maxTotal) / sum;
        raceValue *= scale;
        attrValue *= scale;
      }
    } else if (includeRace || includeAttr) {
      const userTotal = includeRace ? baseRace : baseAttr;
      const boostedTotal = includeRace ? effectiveRace : effectiveAttr;
      const isSmall = userTotal > 0 && userTotal < RECOMMENDATION_CONFIG.smallThreshold;
      const maxVal = getMaxAllowedValue(userTotal, RECOMMENDATION_CONFIG.raceAttrSoloCap, RECOMMENDATION_CONFIG.raceAttrTol, isSmall);

      if (includeRace) {
        raceValue = avoidCapLimit(Math.min(generateRandomValue(boostedTotal, jitter), maxVal), maxVal);
      } else {
        attrValue = avoidCapLimit(Math.min(generateRandomValue(boostedTotal, jitter), maxVal), maxVal);
      }
    }

    return { raceValue, attrValue };
  };

  const generateRecommendationRow = (jitter) => {
    let penValue = state.penVal, critValue = state.critVal;
    
    if (isPenMode) {
      penValue = generateRandomValue(centeredMain, jitter);
    } else {
      critValue = generateRandomValue(centeredMain, jitter);
    }

    const dmgValue = generateRandomValue(centeredDmg, jitter);
    const elemValue = generateRandomValue(centeredElem, jitter);
    const sizeValue = generateRandomValue(centeredSize, jitter);
    const { raceValue, attrValue } = calculateRaceAttrValues(jitter);

    const extras = {
      blueGroup3Val: state.blueGroup3Val || 0,
      blueGroup8Val: state.blueGroup8Val || 0,
      vesperVal: state.vesperVal || 0,
      whiteVal: state.whiteVal || 0,
      dmgStackVal: state.dmgStackVal || 0
    };

    const { mult: newMultiplier } = calculateMultiplier({
      atkType: isPenMode ? 'pen' : 'crit',
      penVal: penValue,
      critVal: critValue,
      dmgVal: dmgValue,
      sizeEnhVal: sizeValue,
      elemEnhVal: elemValue,
      raceVal: raceValue,
      attrVal: attrValue,
      weapon: DOM_ELEMENTS.weapon.value,
      tSize: DOM_ELEMENTS.tSize.value,
      wElem: DOM_ELEMENTS.wElem.value,
      tAttr: DOM_ELEMENTS.tAttr.value,
      tRace: DOM_ELEMENTS.tRace.value,
      tDefKey: DOM_ELEMENTS.tDef.value,
      extras
    });

    
    // Avoid round tens for better visual variety
    const avoidRoundTen = (v) => (v % 10 === 0 ? v + 1 : v);

    return {
      mainVal: avoidRoundTen(Math.round(isPenMode ? penValue : critValue)),
      dmgVal: avoidRoundTen(Math.round(dmgValue)),
      elemVal: avoidRoundTen(Math.round(elemValue)),
      sizeVal: avoidRoundTen(Math.round(sizeValue)),
      raceVal: includeRace ? avoidRoundTen(Math.round(raceValue)) : null,
      attrVal: includeAttr ? avoidRoundTen(Math.round(attrValue)) : null,
      newMultiplier
    };
  };

  const isSmallCombined = includeRace && includeAttr &&
    (baseRace + baseAttr > 0 && baseRace + baseAttr < RECOMMENDATION_CONFIG.smallThreshold);

  const activeCats = isSmallCombined ? RECOMMENDATION_CONFIG.forSmallCats : RECOMMENDATION_CONFIG.cats;

  for (const category of activeCats) {
    const table = document.createElement('table');
    table.className = 'recommend-table';
    
    const caption = document.createElement('caption');
    caption.textContent = 'Increase ' + category.label;
    table.appendChild(caption);

    const headerRow = document.createElement('tr');
    const headers = [isPenMode ? 'PEN' : 'CRIT', 'P/M BO', 'Element', 'Size'];
    if (includeRace) headers.push('Race');
    if (includeAttr) headers.push('Attribute');
    headers.push('Multiplier', 'Δ');
    
    headers.forEach(headerText => {
      const th = document.createElement('th');
      th.textContent = headerText;
      headerRow.appendChild(th);
    });
    table.appendChild(headerRow);

    const tbody = document.createElement('tbody');
    const seenKeys = new Set();
    const seenDeltas = new Set();
    const seenValues = { 
      main: new Set(), 
      dmg: new Set(), 
      elem: new Set(), 
      size: new Set(), 
      attr: new Set(), 
      race: new Set() 
    };
    const validRows = [];
    
    let attempts = 0;
    let jitter = RECOMMENDATION_CONFIG.jitter;

    while (validRows.length < 5 && attempts < RECOMMENDATION_CONFIG.maxAttempts) {
      attempts++;
      
      const row = generateRecommendationRow(jitter);
      
      if (row.newMultiplier <= baseMultiplier) continue;
      
      const ratio = row.newMultiplier / Math.max(baseMultiplier, 1e-9);
      if (ratio < category.min || ratio > category.max) continue;

      const uniqueKey = [row.mainVal, row.dmgVal, row.elemVal, row.sizeVal, row.raceVal || '-', row.attrVal || '-'].join('|');
      if (seenKeys.has(uniqueKey)) continue;
      if (seenValues.main.has(row.mainVal)) continue;
      if (seenValues.dmg.has(row.dmgVal)) continue;
      if (seenValues.elem.has(row.elemVal)) continue;
      if (seenValues.size.has(row.sizeVal)) continue;
      if (includeAttr && seenValues.attr.has(row.attrVal)) continue;
      if (includeRace && seenValues.race.has(row.raceVal)) continue;
if (
  row.mainVal > baseMain &&
  row.dmgVal > baseDmg &&
  row.elemVal > baseElem &&
  row.sizeVal > baseSize &&
  (!includeRace || row.raceVal > baseRace) &&
  (!includeAttr || row.attrVal > baseAttr)
) {
  continue;
}
      const deltaPercent = ((row.newMultiplier - baseMultiplier) / baseMultiplier) * 100;
      const deltaKey = Number(deltaPercent.toFixed(1));
      if (seenDeltas.has(deltaKey)) continue;

      seenKeys.add(uniqueKey);
      seenDeltas.add(deltaKey);
      seenValues.main.add(row.mainVal);
      seenValues.dmg.add(row.dmgVal);
      seenValues.elem.add(row.elemVal);
      seenValues.size.add(row.sizeVal);
      if (includeAttr) seenValues.attr.add(row.attrVal);
      if (includeRace) seenValues.race.add(row.raceVal);

      validRows.push({
        main: row.mainVal, 
        dmg: row.dmgVal, 
        elem: row.elemVal, 
        size: row.sizeVal,
        attr: row.attrVal, 
        race: row.raceVal,
        newMultiplier: row.newMultiplier, 
        deltaPercent
      });

      // Increase jitter if having trouble finding valid rows
      if (validRows.length < 5 && attempts % RECOMMENDATION_CONFIG.jitterStepEvery === 0) {
        jitter = Math.min(jitter + RECOMMENDATION_CONFIG.jitterStep, RECOMMENDATION_CONFIG.jitterMax);
      }
    }

    // Sort by delta percentage and multiplier
    validRows.sort((a, b) => b.deltaPercent - a.deltaPercent || b.newMultiplier - a.newMultiplier || b.main - a.main);

    for (const row of validRows) {
      const tr = document.createElement('tr');
      
      tr.appendChild(createFactorCell(row.main, baseMain));
      tr.appendChild(createFactorCell(row.dmg, baseDmg));
      tr.appendChild(createFactorCell(row.elem, baseElem));
      tr.appendChild(createFactorCell(row.size, baseSize));
      if (includeRace) tr.appendChild(createFactorCell(row.race, baseRace));
      if (includeAttr) tr.appendChild(createFactorCell(row.attr, baseAttr));
      
      const multCell = document.createElement('td');
      multCell.className = 'mult';
      multCell.textContent = 'x' + row.newMultiplier.toFixed(2);
      tr.appendChild(multCell);
      
      const deltaCell = document.createElement('td');
      deltaCell.className = 'delta';
      deltaCell.textContent = '+' + row.deltaPercent.toFixed(1) + '%';
      tr.appendChild(deltaCell);
      
      tbody.appendChild(tr);
    }

    table.appendChild(tbody);
    const wrapper = document.createElement('div');
    wrapper.className = 'table-wrapper';
    wrapper.appendChild(table);
    
    if (validRows.length) {
      recommendationsRoot.appendChild(wrapper);
    }
  }
  
  showSnackbar('Recommendations updated');
}
function regenerateRecommendations() {
  if (!isResultShown) return;
  const calculationState = getCurrentCalculationState();
  generateRecommendationTable(calculationState);
}
let isTestReaperActive = false;
let isTestSpearActive = false;
function simulateFlash(event) {
  try {
    const btn = event?.currentTarget;
    if (!btn) return;
    
    if (btn === DOM_ELEMENTS.testReaper) {
      isTestReaperActive = !isTestReaperActive;
      btn.classList.toggle('activated', isTestReaperActive);
      
      // Trigger pulse flash when activated
      if (isTestReaperActive && typeof triggerPulseFlash === 'function') {
        triggerPulseFlash();
      }
      
      if (typeof processMainCalculation === 'function') {
        processMainCalculation();
      }
      
      if (typeof showSnackbar === 'function') {
        showSnackbar(isTestReaperActive ? 'Reaper Flash Active' : 'Reaper Off');
      }
    }
    
    if (btn === DOM_ELEMENTS.testSpear) {
      isTestSpearActive = !isTestSpearActive;
      btn.classList.toggle('activated', isTestSpearActive);
      
      // Trigger pulse flash when activated
      if (isTestSpearActive && typeof triggerPulseFlash === 'function') {
        triggerPulseFlash();
      }
      
      if (typeof processMainCalculation === 'function') {
        processMainCalculation();
      }
      
      if (typeof showSnackbar === 'function') {
        showSnackbar(isTestSpearActive ? 'Spear Flash Active' : 'Spear Off');
      }
    }
  } catch (e) {
    console.warn('simulateFlash error', e);
  }
}
function triggerPulseFlash() {
  // Mobile check - early exit
  if (window.innerWidth >= 480) {
    console.log('Flash effect hanya untuk mobile (<480px)');
    return;
  }
  
  const flash = document.createElement('div');
  flash.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    background: radial-gradient(ellipse 120% 150% at center,
      rgba(88, 101, 242, 0.4) 0%, rgba(88, 101, 242, 0.25) 35%,
      rgba(79, 84, 92, 0.15) 65%, rgba(54, 57, 63, 0.08) 85%, transparent 100%);
    opacity: 0; transform: scale(0.8); pointer-events: none; z-index: 999;
    mix-blend-mode: overlay; display: flex; align-items: center; justify-content: center;
    animation: pulseFlashAnim 1.2s ease-out forwards, lightningFlicker 1.2s ease-out forwards;
  `;
  
  const lightning = document.createElement('div');
  lightning.innerHTML = '&#x26A1;';
  lightning.style.cssText = `
    font-size: 3.2rem; color: #dcddde; opacity: 0; transform: scale(0.8);
    text-shadow: 0 0 6px rgba(220, 221, 222, 0.9), 0 0 18px rgba(88, 101, 242, 0.7), 0 0 30px rgba(88, 101, 242, 0.3);
    filter: drop-shadow(0 0 4px rgba(185, 187, 190, 0.5));
    animation: lightningAnim 1.2s ease-out forwards;
  `;
  
  flash.appendChild(lightning);
  document.body.appendChild(flash);
  
  // Auto cleanup
  setTimeout(() => flash.remove(), 1300);
}
function resetAllData() {
  if (!confirm('Reset all data')) return;
  
  // Reset DOM elements
  document.querySelectorAll('input').forEach(input => {
    input.value = '';
    input.checked = false; // untuk checkbox/radio
    input.classList.remove('invalid-value'); // remove validation classes
  });
  
  document.querySelectorAll('select').forEach(select => {
    select.selectedIndex = 0;
    select.classList.remove('invalid-value');
  });
  
  // Reset global variables/flags
  isResultShown = false;
  isTestReaperActive = false;
  isTestSpearActive = false;
  
  // Reset UI states
  DOM_ELEMENTS.hasil.textContent = 'Input your stats to see the result...';
  DOM_ELEMENTS.rec.textContent = 'Balancing stat recommendations for a higher output multiplier.';
  
  // Reset button states
  DOM_ELEMENTS.submit.disabled = false;
  DOM_ELEMENTS.resetRek.disabled = true;
  DOM_ELEMENTS.resetAll.disabled = true;
  DOM_ELEMENTS.testSpear.disabled = true;
  DOM_ELEMENTS.testReaper.disabled = true;
  
  // Reset test button UI
  try {
    if (DOM_ELEMENTS.testReaper) {
      DOM_ELEMENTS.testReaper.classList.remove('active');
      DOM_ELEMENTS.testReaper.disabled = true;
    }
    if (DOM_ELEMENTS.testSpear) {
      DOM_ELEMENTS.testSpear.classList.remove('active');
      DOM_ELEMENTS.testSpear.disabled = true;
    }
  } catch (e) {}
  
  // Reset dynamic content yang mungkin di-generate
  document.querySelectorAll('.dynamic-content, .generated-content').forEach(el => {
    el.remove(); // atau el.innerHTML = '';
  });
  
  // Reset sticky elements
  try {
    manageStickyElements();
  } catch (e) {}
  
  // Reset form validation states
  document.querySelectorAll('.error, .success, .warning').forEach(el => {
    el.classList.remove('error', 'success', 'warning');
  });
  
  // Clear any timeouts/intervals yang mungkin masih jalan
  // clearTimeout(someTimeoutId);
  // clearInterval(someIntervalId);
  
  unlockAllInputs();
  updateAttackTypeUI();
  updateDynamicFieldLabels();
  
  // Reset any cached calculations
  // calculationCache = {};
  // lastCalculationResult = null;
  
  if (typeof showSnackbar === 'function') {
    showSnackbar("All stats cleared!");
  }
}

// ========== UI UPDATE FUNCTIONS ==========
function updateAttackTypeUI() {
  // show hide field by atktype
  const atkType = DOM_ELEMENTS.atkType.value;
  const penGroup = document.querySelector('.form-group.pen-group');
  const critGroup = document.querySelector('.form-group.crit-group');
  
  if (penGroup && critGroup) {
    penGroup.classList.add('hidden');
    critGroup.classList.add('hidden');
  }
  
  if (atkType === 'pen') {
    if (penGroup) penGroup.classList.remove('hidden');
    DOM_ELEMENTS.pen.disabled = false;
    DOM_ELEMENTS.crit.disabled = true;
    DOM_ELEMENTS.crit.value = '';
  } else if (atkType === 'crit') {
    if (critGroup) critGroup.classList.remove('hidden');
    DOM_ELEMENTS.crit.disabled = false;
    DOM_ELEMENTS.pen.disabled = true;
    DOM_ELEMENTS.pen.value = '';
  } else {
    DOM_ELEMENTS.pen.disabled = true;
    DOM_ELEMENTS.crit.disabled = true;
    DOM_ELEMENTS.pen.value = '';
    DOM_ELEMENTS.crit.value = '';
  }
}
function updateDynamicFieldLabels() {
  // Race field
  if (DOM_ELEMENTS.tRace.value) {
    DOM_ELEMENTS.race.disabled = false;
    DOM_ELEMENTS.raceLabel.textContent = 'DMG to ' + DOM_ELEMENTS.tRace.value + ' %';
    DOM_ELEMENTS.race.placeholder = 'dmg to ' + DOM_ELEMENTS.tRace.value + '...';
  } else {
    DOM_ELEMENTS.race.disabled = true;
    DOM_ELEMENTS.raceLabel.textContent = 'DMG to Race %';
    DOM_ELEMENTS.race.placeholder = 'no race enchant';
    DOM_ELEMENTS.race.value = '';
  }

  // Attribute field
  if (DOM_ELEMENTS.tAttr.value) {
    DOM_ELEMENTS.attr.disabled = false;
    DOM_ELEMENTS.attrLabel.textContent = 'DMG to ' + DOM_ELEMENTS.tAttr.value + ' Attribute %';
    DOM_ELEMENTS.attr.placeholder = 'dmg to ' + DOM_ELEMENTS.tAttr.value + ' attr mob...';
  } else {
    DOM_ELEMENTS.attr.disabled = true;
    DOM_ELEMENTS.attrLabel.textContent = 'DMG to Attribute %';
    DOM_ELEMENTS.attr.placeholder = 'no attribute enchant';
    DOM_ELEMENTS.attr.value = '';
  }

  // Element field
  if (DOM_ELEMENTS.wElem.value) {
    DOM_ELEMENTS.elemEnh.disabled = false;
    DOM_ELEMENTS.elemEnhLabel.textContent = DOM_ELEMENTS.wElem.value + ' Enhance %';
    DOM_ELEMENTS.elemEnh.placeholder = DOM_ELEMENTS.wElem.value + ' enhance...';
  } else {
    DOM_ELEMENTS.elemEnh.disabled = true;
    DOM_ELEMENTS.elemEnhLabel.textContent = 'Element Enhance %';
    DOM_ELEMENTS.elemEnh.placeholder = 'Select weapon attribute first';
    DOM_ELEMENTS.elemEnh.value = '';
  }

  // Size enhance field
  if (DOM_ELEMENTS.tSize.value) {
    DOM_ELEMENTS.sizeEnh.disabled = false;
    DOM_ELEMENTS.sizeLabel.textContent = 'DMG to ' + DOM_ELEMENTS.tSize.value + ' %';
    DOM_ELEMENTS.sizeEnh.placeholder = 'dmg to ' + DOM_ELEMENTS.tSize.value + '...';
  } else {
    DOM_ELEMENTS.sizeEnh.disabled = true;
    DOM_ELEMENTS.sizeLabel.textContent = 'DMG to Size %';
    DOM_ELEMENTS.sizeEnh.placeholder = 'Select target size first';
    DOM_ELEMENTS.sizeEnh.value = '';
  }
}

// ========== DROPDOWN ==========
function setOptions(select, options, placeholder, customLabels = {}) {
  // Generate HTML for options
  const optionElements = [];
  
  if (placeholder) {
    optionElements.push(`<option value="">${placeholder}</option>`);
  }
  
  options.forEach(opt => {
    const value = typeof opt === "string" ? opt : opt.value;
    const label = customLabels[value] || (typeof opt === "string" ? opt : opt.label);
    const disabled = opt.disabled ? 'disabled' : '';
    
    optionElements.push(`<option value="${value}" ${disabled}>${label}</option>`);
  });
  
  select.innerHTML = optionElements.join("");
}
function populateDropdownOptions() {
  // Populate attack type dropdown
  setOptions(DOM_ELEMENTS.atkType, [
    { value: "pen", label: "P/M PEN" },
    { value: "crit", label: "Critical" }
  ], "Select Attack Type");
  
  // Populate weapon dropdown from lookup table
  setOptions(DOM_ELEMENTS.weapon, Object.keys(WEAPON_SIZE_MODIFIER_TABLE), "Select Weapon");
  
  // Populate weapon element dropdown
  setOptions(DOM_ELEMENTS.wElem, Object.keys(ELEMENT_COUNTER_TABLE), "Select Attribute");
  
  populateTargetDropdowns();
  populateSetDropdowns();
  bindTargetDefenseListener();
  bindThreeSetListeners();
}
function populateTargetDropdowns() {
  const targetDropdowns = [
    {
      element: DOM_ELEMENTS.tSize,
      options: [
        { value: "Small", label: "Small" },
        { value: "Medium", label: "Medium" },
        { value: "Large", label: "Large" }
      ],
      placeholder: "Select Target Size"
    },
    {
      element: DOM_ELEMENTS.tRace,
      options: RACE_TYPES,
      placeholder: "skip race"
    },
    {
      element: DOM_ELEMENTS.tAttr,
      options: Object.keys(ELEMENT_COUNTER_TABLE),
      placeholder: "skip attribute"
    }
  ];
  
  // Populate target dropdowns and enable them
  targetDropdowns.forEach(({ element, options, placeholder }) => {
    setOptions(element, options, placeholder);
    element.disabled = false;
  });
  
  // Populate defense dropdown with custom labels
  setOptions(DOM_ELEMENTS.tDef, Object.keys(DEFENSE_TABLE), "Select target monster", {
    "0def": "Dummy (0 DEF)",
    "130boss": "Average 130 BOSS",
    "140boss": "Average 140 BOSS",
    "150boss": "Average 150 BOSS"
  });
}
function populateSetDropdowns() {
  // Vesper Set dropdown
  const vesperOptions = [
    { value: "", label: "skip" },
    ...Object.entries(VESPER_SET).map(([tier, val]) => ({
      value: val,
      label: `Tier ${tier}`
    }))
  ];
  setOptions(DOM_ELEMENTS.vesperSet, vesperOptions);
  
  // White Set dropdown
  const whiteOptions = [
    { value: "", label: "skip" },
    ...Object.entries(WHITE_SET).map(([tier, val]) => ({
      value: val,
      label: tier
    }))
  ];
  setOptions(DOM_ELEMENTS.whiteSet, whiteOptions);
  
  // Blue Set dropdown with nested mapping
  const blueOptions = [
    { value: "", label: "skip" },
    ...Object.entries(BLUE_SET).flatMap(([multiplier, levels]) =>
      Object.entries(levels).map(([lvl, val]) => ({
        value: val,
        label: `Level ${lvl}*${multiplier}`
      }))
    )
  ];
  setOptions(DOM_ELEMENTS.blueSet, blueOptions);
}
function bindTargetDefenseListener() {
  // Prevent duplicate listeners
  if (DOM_ELEMENTS.tDef.dataset.boundDefense) return;
  
  DOM_ELEMENTS.tDef.addEventListener('change', function() {
    const selectedKey = this.value;
    const defenseData = DEFENSE_TABLE[selectedKey];
    const targetElements = {
      size: DOM_ELEMENTS.tSize,
      race: DOM_ELEMENTS.tRace,
      attr: DOM_ELEMENTS.tAttr
    };
    
    // Auto-populate and disable fields if defense data contains mob info
    if (defenseData && selectedKey.includes("Lv.")) {
      updateTargetField(targetElements.size, defenseData.sizeMob);
      updateTargetField(targetElements.race, defenseData.raceMob);
      updateTargetField(targetElements.attr, defenseData.attributeMob);
    } else {
      // Reset and enable all target fields
      Object.values(targetElements).forEach(element => {
        element.value = "";
        element.disabled = false;
      });
    }
    
    updateDynamicFieldLabels();
  });
  
  DOM_ELEMENTS.tDef.dataset.boundDefense = "1";
}
function updateTargetField(element, value) {
  // Update field with value and disable if value exists
  if (value) {
    element.value = value;
    element.disabled = true;
  }
}
// flow n logic for (vesper, blue, and white)
const selectionOrder = [];
function recordSelection(selectEl) {
  const wasCycleComplete = isCycleComplete();
  
  // Remove from order if deselected
  if (!selectEl?.value) {
    removeFromSelectionOrder(selectEl);
    return;
  }
  
  // Reset cycle if previously complete, otherwise add to order
  if (wasCycleComplete) {
    selectionOrder.length = 0;
    selectionOrder.push(selectEl);
  } else if (!selectionOrder.includes(selectEl)) {
    selectionOrder.push(selectEl);
  }
}
function removeFromSelectionOrder(selectEl) {
  // Remove element from selection order array
  const index = selectionOrder.indexOf(selectEl);
  if (index !== -1) {
    selectionOrder.splice(index, 1);
  }
}
function isCycleComplete() {
  // Check if selection cycle is complete (3 sets or blue *8 multiplier)
  const blueText = DOM_ELEMENTS.blueSet?.selectedOptions[0]?.textContent ?? "";
  const blueIs8x = blueText.includes("*8");
  
  return selectionOrder.length >= 3 || (DOM_ELEMENTS.blueSet?.value && blueIs8x);
}
function resetSelectionOrder() {
  // Reset selection order based on current dropdown values
  selectionOrder.length = 0;
  
  const setElements = [DOM_ELEMENTS.blueSet, DOM_ELEMENTS.vesperSet, DOM_ELEMENTS.whiteSet]
    .filter(Boolean)
    .filter(el => el.value);
  
  selectionOrder.push(...setElements);
}
function setOnlySkip(selectEl) {
  // Disable all options except placeholder
  if (!selectEl) return;
  
  Array.from(selectEl.options).forEach(opt => {
    opt.disabled = !!opt.value;
  });
  selectEl.value = "";
}
function enableAllOptions(selectEl) {
  // Enable all options in select element
  if (!selectEl) return;
  
  Array.from(selectEl.options).forEach(opt => {
    opt.disabled = false;
  });
}
function syncThreeSets() {
  // Synchronize three-set dropdowns based on selection rules
  const setElements = {
    blue: DOM_ELEMENTS.blueSet,
    vesper: DOM_ELEMENTS.vesperSet,
    white: DOM_ELEMENTS.whiteSet
  };
  
  if (!setElements.blue || !setElements.vesper) return;
  
  // Enable all options initially
  Object.values(setElements).filter(Boolean).forEach(enableAllOptions);
  
  const blueText = setElements.blue.selectedOptions[0]?.textContent ?? "";
  const blueIs8x = blueText.includes("*8");
  
  // Blue *8 multiplier rule: disable other sets
  if (setElements.blue.value && blueIs8x) {
    setOnlySkip(setElements.vesper);
    if (setElements.white) setOnlySkip(setElements.white);
    return;
  }
  
  // If any set is selected, disable *8 multiplier options
  if (selectionOrder.length > 0) {
    disableBlue8xOptions(setElements.blue);
  }
  
  // Apply two-set limit rule
  applyTwoSetLimit(setElements);
}
function disableBlue8xOptions(blueElement) {
  // Disable Blue *8 multiplier options and reset if currently selected
  Array.from(blueElement.options).forEach(opt => {
    if (opt.value && opt.textContent.includes("*8")) {
      opt.disabled = true;
    }
  });
  
  // Reset blue selection if it's now disabled
  if (blueElement.value && blueElement.selectedOptions[0]?.disabled) {
    blueElement.value = "";
    removeFromSelectionOrder(blueElement);
  }
}
function applyTwoSetLimit(setElements) {
  // Apply two-set selection limit by disabling unselected sets
  const allSets = Object.values(setElements).filter(Boolean);
  const unselectedSets = allSets.filter(el => !selectionOrder.includes(el));
  
  if (selectionOrder.length >= 2 && unselectedSets.length > 0) {
    unselectedSets.forEach(setOnlySkip);
  }
}
function bindThreeSetListeners() {
  // Bind change event listeners to three-set dropdowns
  const setElements = [DOM_ELEMENTS.blueSet, DOM_ELEMENTS.vesperSet, DOM_ELEMENTS.whiteSet]
    .filter(Boolean);
  
  setElements.forEach(element => {
    // Skip if already bound to prevent duplicate listeners
    if (element.dataset.boundThree) return;
    
    element.addEventListener("change", () => {
      recordSelection(element);
      syncThreeSets();
    });
    
    element.dataset.boundThree = "1";
  });
  
  // Initialize selection order and sync state
  resetSelectionOrder();
  syncThreeSets();
}
function handleDropdownChange(event) {
  if (isResultShown) return;
  const elementId = event?.target?.id;
  if (!elementId) return;
  
  if (elementId === 'penCritSelect') {
    clearNumericInput(DOM_ELEMENTS.pen);
    clearNumericInput(DOM_ELEMENTS.crit);
    updateAttackTypeUI();
  }
  if (elementId === 'targetRaceSelect') clearNumericInput(DOM_ELEMENTS.race);
  if (elementId === 'targetElementSelect') clearNumericInput(DOM_ELEMENTS.attr);
  updateDynamicFieldLabels();
}

// ========== INPUT LOCK SYSTEM ==========
const PASSIVE_SUPPORT = (() => {
  let supported = false;
  try {
    const opts = Object.defineProperty({}, 'passive', {
      get() { supported = true; }
    });
    window.addEventListener('testPassive', null, opts);
    window.removeEventListener('testPassive', null, opts);
  } catch (_) {}
  return supported;
})();
const POINTER_SUPPORT = ('PointerEvent' in window);
function showLockedInputMessage(event) {
  const target = event?.currentTarget;
  const now = Date.now();
  if (target) {
    if (target._lastLockTimestamp && (now - target._lastLockTimestamp) < 350) return;
    target._lastLockTimestamp = now;
  }
  if (event?.cancelable) {
    try { event.preventDefault(); } catch(_) {}
  }
  showSnackbar("Your Stats Locked!");
}
function bindInputLockGuard(wrapElement) {
  if (wrapElement.hasAttribute('data-lock-bound')) return;
  const handler = showLockedInputMessage;
  const listeners = [];
  
  if (POINTER_SUPPORT) {
    const opts = { capture: false, passive: false };
    wrapElement.addEventListener('pointerdown', handler, opts);
    listeners.push(['pointerdown', handler, opts]);
  } else {
    const touchOpts = PASSIVE_SUPPORT ? { capture: false, passive: false } : false;
    wrapElement.addEventListener('touchstart', handler, touchOpts);
    listeners.push(['touchstart', handler, touchOpts]);
    wrapElement.addEventListener('click', handler, false);
    listeners.push(['click', handler, false]);
  }
  
  wrapElement._lockListeners = listeners;
  wrapElement.setAttribute('data-lock-bound', '1');
}
function unbindInputLockGuard(wrapElement) {
  if (!wrapElement.hasAttribute('data-lock-bound')) return;
  const listeners = wrapElement._lockListeners;
  
  if (Array.isArray(listeners)) {
    for (const [type, handler, opts] of listeners) {
      wrapElement.removeEventListener(type, handler, opts);
    }
  }
  
  delete wrapElement._lockListeners;
  wrapElement.removeAttribute('data-lock-bound');
  delete wrapElement._lastLockTimestamp;
}
function lockAllInputs() {
  document.querySelectorAll('.input-wrap').forEach(wrapper => {
    const element = wrapper.querySelector('select, input');
    if (!element) return;
    bindInputLockGuard(wrapper);
    element.disabled = true;
  });
}
function unlockAllInputs() {
  document.querySelectorAll('.input-wrap').forEach(wrapper => {
    const element = wrapper.querySelector('select, input');
    if (!element) return;
    element.disabled = false;
    unbindInputLockGuard(wrapper);
  });
}

// ========== STICKY UI SYSTEM ==========
function calculateSafeBottomPosition(index = 0) {
  return `calc(${20 + index * 56}px + env(safe-area-inset-bottom))`;
}
function manageStickyElements() {
  const stickyElements = {
    resetRek: document.getElementById("resetRekomenBtn"),
    resetAll: document.getElementById("resetAllBtn"),
    swapBoss: document.getElementById("breakdown-swap"),
    swapLabel: document.getElementById("swap-label"),
    stickyStart: DOM_ELEMENTS.hasil,
    toggleBtn: document.getElementById("toggleStickyBtn"),
    backBtn: document.getElementById("backToHasilBtn"),
    testSpear: DOM_ELEMENTS.testSpear,
    testReaper: DOM_ELEMENTS.testReaper
  };
  
  if (!stickyElements.toggleBtn) {
    stickyElements.toggleBtn = document.createElement("button");
    stickyElements.toggleBtn.id = "toggleStickyBtn";
    stickyElements.toggleBtn.dataset.collapse = "false";
    document.body.appendChild(stickyElements.toggleBtn);
    
    stickyElements.toggleBtn.addEventListener("click", () => {
      const collapsed = stickyElements.toggleBtn.dataset.collapse === "true";
      stickyElements.toggleBtn.dataset.collapse = collapsed ? "false" : "true";
      stickyElements.toggleBtn.classList.toggle("active", !collapsed);
      manageStickyElements();
    });
  }
  
  if (!stickyElements.backBtn) {
    stickyElements.backBtn = document.createElement("button");
    stickyElements.backBtn.id = "backToHasilBtn";
    document.body.appendChild(stickyElements.backBtn);
    stickyElements.backBtn.addEventListener("click", () => {
      stickyElements.stickyStart?.scrollIntoView({ behavior: "smooth" });
    });
  }
  
  [stickyElements.resetRek, stickyElements.resetAll, stickyElements.testSpear, stickyElements.testReaper].forEach(button => {
    if (button && !button.hasAttribute("data-original-text")) {
      button.setAttribute("data-original-text", button.textContent || "");
    }
  });
  
  const allStickyButtons = [
    stickyElements.resetRek,
    stickyElements.resetAll,
    stickyElements.swapBoss,
    stickyElements.testSpear,
    stickyElements.testReaper,
    stickyElements.backBtn,
    stickyElements.toggleBtn
  ];
  
  // Desktop mode - disable sticky behavior  
  if (window.innerWidth > 480) {
    allStickyButtons.forEach(button => {
      if (!button) return;
      button.classList.remove("sticky", "collapsed");
      button.style.transform = "";
      const originalText = button.getAttribute("data-original-text");
      if (originalText !== null) button.textContent = originalText;
    });
    stickyElements.swapLabel?.classList.remove("hidden");
    return;
  }
  
  // Mobile mode - check if sticky should be active  
  const isStickyActive = stickyElements.stickyStart?.getBoundingClientRect().top <= 0;
  stickyElements.swapLabel?.classList.toggle("hidden", isStickyActive);
  
  if (!isStickyActive) {
    allStickyButtons.forEach(button => {
      if (!button) return;
      button.classList.remove("sticky", "collapsed");
      button.style.transform = "";
      const originalText = button.getAttribute("data-original-text");
      if (originalText !== null) button.textContent = originalText;
    });
    return;
  }
  
  // Sticky mode active  
  const buttonOrder = [
    stickyElements.toggleBtn,
    stickyElements.swapBoss,
    stickyElements.testSpear,
    stickyElements.testReaper,
    stickyElements.resetRek,
    stickyElements.resetAll,
    stickyElements.backBtn
  ].filter(Boolean);
  
  buttonOrder.forEach(button => button.classList.add("sticky"));
  
  const isCollapsed = stickyElements.toggleBtn.dataset.collapse === "true";
  
  buttonOrder.forEach((button, index) => {
    if (!button) return;
    if (isCollapsed) {
      button.classList.add("collapsed");
      button.style.transform = "translateY(0)";
    } else {
      button.classList.remove("collapsed");
      button.style.transform = `translateY(-${index * 56}px)`;
    }
  });
  
  [stickyElements.resetRek, stickyElements.resetAll, stickyElements.testSpear, stickyElements.testReaper].forEach(button => {
    if (!button) return;
    const originalText = button.getAttribute("data-original-text") || "";
    button.textContent = isStickyActive ? "" : originalText;
  });
}
const mutationObserver = new MutationObserver(() => {
  if (document.getElementById('breakdown-swap')) {
    // Double check
    requestAnimationFrame(() => {
      setTimeout(() => {
        manageStickyElements();
      }, 5);
    });
  }
});

// ========== EVENT BINDING & INITIALIZATION ==========
function bindAllEventListeners() {
  if (bindAllEventListeners.bound) return;
  bindAllEventListeners.bound = true;

  populateDropdownOptions();
DOM_ELEMENTS.submit.addEventListener('click', () => {
  processMainCalculation();
});

DOM_ELEMENTS.resetRek.addEventListener('click', () => {
  regenerateRecommendations();
  if (typeof showSnackbar === 'function') {
    showSnackbar("Table Refreshed!");
  }
});

DOM_ELEMENTS.resetAll.addEventListener('click', () => {
  resetAllData()});

  // Test button listeners (guarded to avoid double binding)
  try {
    if (DOM_ELEMENTS.testReaper && !DOM_ELEMENTS.testReaper.dataset.simBound) {
      DOM_ELEMENTS.testReaper.addEventListener('click', simulateFlash);
      DOM_ELEMENTS.testReaper.dataset.simBound = '1';
    }
    if (DOM_ELEMENTS.testSpear && !DOM_ELEMENTS.testSpear.dataset.simBound) {
      DOM_ELEMENTS.testSpear.addEventListener('click', simulateFlash);
      DOM_ELEMENTS.testSpear.dataset.simBound = '1';
    }
  } catch (e) { console.warn('attach test listeners', e); }


  // Dropdown change listeners
  [
    'penCritSelect', 'weaponSelect', 'weaponElementSelect',
    'targetSizeSelect', 'targetRaceSelect', 'targetElementSelect'
  ].forEach(elementId => {
    const element = document.getElementById(elementId);
    if (element) element.addEventListener('change', handleDropdownChange);
  });
  
  // Numeric input validation
  ["pen", "crit", "dmg", "elemEnh", "sizeEnh", "race", "attr", "dmgStack"].forEach(fieldKey => {
    const element = DOM_ELEMENTS[fieldKey];
    if (!element) return;
    element.addEventListener("blur", () => normalizeNumericInput(element));
    element.addEventListener("paste", event => {
      event.preventDefault();
      let pastedText = (event.clipboardData || window.clipboardData).getData("text");
      normalizeNumericInput(element, pastedText);
    });
  });
}
function initializeApp() {
  if (!DOM_ELEMENTS?.log) return;
  
  // Initialize changelog modal
  DOM_ELEMENTS.log.style.display = "none";
  if (DOM_ELEMENTS.openLog) {
    DOM_ELEMENTS.openLog.addEventListener("click", () => { 
      DOM_ELEMENTS.log.style.display = "flex"; 
    });
  }
  if (DOM_ELEMENTS.closeLog) {
    DOM_ELEMENTS.closeLog.addEventListener("click", () => { 
      DOM_ELEMENTS.log.style.display = "none"; 
    });
  }
  
  // Initialize core functionality
  bindAllEventListeners();
  updateAttackTypeUI();
  updateDynamicFieldLabels();
  manageStickyElements();
  
  // Single scroll/resize handler
  const handleViewportChange = () => manageStickyElements();
  window.addEventListener("scroll", handleViewportChange, { passive: true });
  window.addEventListener("resize", handleViewportChange, { passive: true });
  
  // Initialize tooltip if available
  if (typeof DOM_ELEMENTS !== 'undefined' && DOM_ELEMENTS.dmgStackTips) {
    initDmgTooltip(DOM_ELEMENTS.dmgStackTips);
  }
  
  // Initialize ValidationSSoT
  ValidationSSoT.helpers.performInitialization();
}
let isInitialized = false;
function safeInit() {
  if (isInitialized) return;
  isInitialized = true;
  initializeApp();
}
if (document.readyState === 'loading') {
  document.addEventListener("DOMContentLoaded", safeInit, { once: true });
} else {
  safeInit();
}

document.querySelectorAll("details").forEach(details => {
  const summary = details.querySelector("summary");
  const content = details.querySelector(".body");
  
  if (!summary || !content) return;
  
  // Set CSS transition untuk smoothness
  content.style.transition = 'max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
  content.style.overflow = 'hidden';
  
  summary.addEventListener("click", function(e) {
    e.preventDefault();
    
    if (details.hasAttribute("open")) {
      // Closing - set current height first, then animate to 0
      content.style.maxHeight = content.scrollHeight + "px";
      
      // Double RAF for ultra smooth transition
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          content.style.maxHeight = "0px";
        });
      });
      
      const closeHandler = () => {
        details.removeAttribute("open");
        content.removeEventListener("transitionend", closeHandler);
      };
      content.addEventListener("transitionend", closeHandler, { once: true });
      
    } else {
      // Opening - set open first, measure, then animate
      details.setAttribute("open", "");
      
      // Get actual content height
      const actualHeight = content.scrollHeight;
      content.style.maxHeight = "0px";
      
      // Double RAF for ultra smooth transition  
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          content.style.maxHeight = actualHeight + "px";
        });
      });
      
      // Optional: Clear maxHeight after animation completes for dynamic content
      const openHandler = () => {
        content.style.maxHeight = "none";
        content.removeEventListener("transitionend", openHandler);
      };
      content.addEventListener("transitionend", openHandler, { once: true });
    }
  });
});
</script>
 </body>
</html>
